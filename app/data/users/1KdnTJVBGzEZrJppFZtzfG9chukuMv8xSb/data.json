{"next_paste_id":20,"next_comment_id":0,"paste":[{"paste_id":12,"description":"Game 1 Demo (Cave2D.com)","body":"\n\n// Game 1 by Aaron Whyte (CAVE2D.com)\n\n\nif (!Math.sign) {\n  // Mozilla's suggested polyfill.\n  Math.sign = function sign(x) {\n    x = +x; // convert to a number\n    if (x === 0 || isNaN(x))\n      return x;\n    return x > 0 ? 1 : -1\n  }\n}\n\n\n/**\n * Adds a static pool, plus alloc and free methods, to a constructor.\n *\n * That constructor's instances must implement \"reset()\" which clears\n * the instance in preparation for re-use, taking the same arguments\n * as the constructor.\n *\n * @param {Function} ctor A constructor.\n */\nfunction Poolify(ctor) {\n  ctor.pool = [];\n  ctor.alloc = Poolify.alloc;\n  ctor.free = Poolify.free;\n  ctor.prototype.free = function() {\n    ctor.free(this);\n  }\n}\n\nPoolify.alloc = function() {\n  var retval;\n  if (this.pool.length) {\n    retval = this.pool.pop();\n    retval.reset.apply(retval, arguments);\n  } else {\n    retval = Object.create(this.prototype);\n    this.apply(retval, arguments);\n  }\n  return retval;\n};\n\nPoolify.free = function(o) {\n  this.pool.push(o);\n};\n\n\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @constructor\n */\nfunction Vec2d(opt_x, opt_y) {\n  this.reset(opt_x, opt_y);\n}\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n */\nVec2d.prototype.reset = function(opt_x, opt_y) {\n  this.x = opt_x || 0;\n  this.y = opt_y || 0;\n  return this;\n};\n\nVec2d.pool = [];\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n */\nVec2d.alloc = function(opt_x, opt_y) {\n  if (Vec2d.pool.length) {\n    return Vec2d.pool.pop().reset(opt_x, opt_y);\n  }\n  return new Vec2d(opt_x, opt_y);\n};\n\nVec2d.prototype.free = function() {\n  Vec2d.pool.push(this);\n};\n\nVec2d.X = 'x';\nVec2d.Y = 'y';\n\nVec2d.AXES = [Vec2d.X, Vec2d.Y];\n\nVec2d.ZERO = new Vec2d(0, 0);\n\nVec2d.otherAxis = function(axis) {\n  return axis === Vec2d.X ? Vec2d.Y : Vec2d.X;\n};\n\nVec2d.prototype.add = function(v) {\n  this.x += v.x;\n  this.y += v.y;\n  return this;\n};\n\nVec2d.prototype.addXY = function(x, y) {\n  this.x += x;\n  this.y += y;\n  return this;\n};\n\nVec2d.prototype.subtract = function(v) {\n  this.x -= v.x;\n  this.y -= v.y;\n  return this;\n};\n\nVec2d.prototype.multiply = function(v) {\n  this.x *= v.x;\n  this.y *= v.y;\n  return this;\n};\n\nVec2d.prototype.roundToGrid = function(cellSize) {\n  this.x = Math.round(this.x / cellSize);\n  this.y = Math.round(this.y / cellSize);\n  return this.scale(cellSize);\n};\n\nVec2d.prototype.set = function(v) {\n  this.x = v.x;\n  this.y = v.y;\n  return this;\n};\n\nVec2d.prototype.setXY = function(xx, yy) {\n  this.x = xx;\n  this.y = yy;\n  return this;\n};\n\nVec2d.prototype.scale = function(s) {\n  this.x *= s;\n  this.y *= s;\n  return this;\n};\n\nVec2d.prototype.scaleXY = function(sx, sy) {\n  this.x *= sx;\n  this.y *= sy;\n  return this;\n};\n\nVec2d.prototype.abs = function() {\n  this.x = Math.abs(this.x);\n  this.y = Math.abs(this.y);\n  return this;\n};\n\nVec2d.prototype.sign = function() {\n  this.x = Math.sign(this.x);\n  this.y = Math.sign(this.y);\n  return this;\n};\n\nVec2d.prototype.rot90Right = function() {\n  var tmp = this.x;\n  this.x = -this.y;\n  this.y = tmp;\n  return this;\n};\n\nVec2d.prototype.rot = function(rads) {\n  if (!rads) {\n    // no rotation\n    return this;\n  }\n  var sin = Math.sin(rads);\n  var cos = Math.cos(rads);\n  var nx = cos * this.x + sin * this.y;\n  var ny = -sin * this.x + cos * this.y;\n  this.x = nx;\n  this.y = ny;\n  return this;\n};\n\nVec2d.prototype.dot = function(that) {\n  return this.x * that.x + this.y * that.y;\n};\n\nVec2d.dotXYXY = function(x0, y0, x1, y1) {\n  return x0 * x1 + y0 * y1;\n};\n\nVec2d.prototype.magnitudeSquared = function() {\n  return this.x * this.x + this.y * this.y;\n};\n\nVec2d.prototype.magnitude = function() {\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\nVec2d.prototype.distanceSquared = function(that) {\n  var dx = this.x - that.x;\n  var dy = this.y - that.y;\n  return dx * dx + dy * dy;\n};\n\nVec2d.prototype.distance = function(that) {\n  var dx = this.x - that.x;\n  var dy = this.y - that.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nVec2d.magnitude = function(x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n\n/**\n * Scales to the desired length, or 0 if the vector is {0, 0}\n */\nVec2d.prototype.scaleToLength = function(length) {\n  var m = this.magnitude();\n  if (m) {\n    this.scale(length / m);\n  }\n  return this;\n};\n\n/**\n * If the magnitude is over the max, this scales it down.\n */\nVec2d.prototype.clipToMaxLength = function(maxLength) {\n  var m = this.magnitude();\n  if (m > maxLength) {\n    this.scale(maxLength / m);\n  }\n  return this;\n};\n\nVec2d.prototype.slideByFraction = function(towardsPoint, fraction) {\n  this.x = this.x * (1 - fraction) + towardsPoint.x * fraction;\n  this.y = this.y * (1 - fraction) + towardsPoint.y * fraction;\n};\n\n\nVec2d.prototype.equals = function(v) {\n  return (this.x == v.x && this.y == v.y);\n};\n\nVec2d.prototype.isZero = function() {\n  return this.x == 0 && this.y == 0;\n};\n\nVec2d.prototype.toString = function() {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nVec2d.dirs = [\n  new Vec2d(0, -1),\n  new Vec2d(1, -1),\n  new Vec2d(1, 0),\n  new Vec2d(1, 1),\n  new Vec2d(0, 1),\n  new Vec2d(-1, 1),\n  new Vec2d(-1, 0),\n  new Vec2d(-1, -1)\n];\n\n// static func\nVec2d.randDir = function() {\n  var dir = Vec2d.dirs[Math.floor(Math.random()*8)];\n  return new Vec2d(dir.x, dir.y);\n};\n\nVec2d.alongRayDistance = function(startPoint, towardsPoint, distance) {\n  return new Vec2d()\n      .set(towardsPoint)\n      .subtract(startPoint)\n      .scaleToLength(distance)\n      .add(startPoint);\n};\n\nVec2d.alongRayFraction = function(startPoint, towardsPoint, fraction) {\n  return new Vec2d()\n      .set(towardsPoint)\n      .subtract(startPoint)\n      .scale(fraction)\n      .add(startPoint);\n};\n\nVec2d.midpoint = function(a, b) {\n  return new Vec2d()\n      .set(a)\n      .add(b)\n      .scale(0.5);\n};\n\nVec2d.distance = function(x0, y0, x1, y1) {\n  var dx = x0 - x1;\n  var dy = y0 - y1;\n  return Math.sqrt((dx * dx) + (dy * dy));\n};\n\nVec2d.distanceSq = function(x0, y0, x1, y1) {\n  var dx = x0 - x1;\n  var dy = y0 - y1;\n  return (dx * dx) + (dy * dy);\n};\n\nVec2d.prototype.projectOnto = function(that) {\n  var coef = this.dot(that) / that.dot(that);\n  return this.set(that).scale(coef);\n};\n\nVec2d.prototype.toJSON = function() {\n  return [this.x, this.y];\n};\n\nVec2d.prototype.setFromJSON = function(json) {\n  this.x = json[0];\n  this.y = json[1];\n};\n\nVec2d.fromJSON = function(json) {\n  return new Vec2d(json[0], json[1]);\n};\n\n\n\n/**\n * A 4D vector, for use as a 3D vector, plus a \"w\" value to help with\n * 3D matrix transformations.\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_z\n * @param {=number} opt_w\n * @constructor\n */\nfunction Vec4(opt_x, opt_y, opt_z, opt_w) {\n  this.v = [0, 0, 0, 1];\n  this.reset(opt_x, opt_y, opt_z, opt_w);\n}\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_z\n * @param {=number} opt_w\n */\nVec4.prototype.reset = function(opt_x, opt_y, opt_z, opt_w) {\n  this.v[0] = opt_x || 0;\n  this.v[1] = opt_y || 0;\n  this.v[2] = opt_z || 0;\n  this.v[3] = (typeof opt_w != 'undefined' ? opt_w : 1);\n  return this;\n};\n\nVec4.pool = [];\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_z\n * @param {=number} opt_w\n */\nVec4.alloc = function(opt_x, opt_y, opt_z, opt_w) {\n  if (Vec4.pool.length) {\n    return Vec4.pool.pop().reset(opt_x, opt_y, opt_z, opt_w);\n  }\n  return new Vec4(opt_x, opt_y, opt_z, opt_w);\n};\n\nVec4.prototype.free = function() {\n  Vec4.pool.push(this);\n};\n\nVec4.ZERO = new Vec4();\n\nVec4.temp = new Vec4();\n\n/**\n * Transforms this vector by multiplying it by the matrix.\n * @param {Matrix44} matrix\n * @returns {Vec4}\n */\nVec4.prototype.transform = function(matrix) {\n  Vec4.temp.reset();\n  // In this case we want even \"w\" to be 0. It will get a 1 if the math works out.\n  Vec4.temp.v[3] = 0;\n  for (var row = 0; row < 4; row++) {\n    for (var col = 0; col < 4; col++) {\n      Vec4.temp.v[row] += this.v[col] * matrix.m[col + 4*row];\n    }\n  }\n  return this.set(Vec4.temp);\n};\n\nVec4.prototype.add = function(that) {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] += that.v[i];\n  }\n  return this;\n};\n\nVec4.prototype.addXYZ = function(x, y, z) {\n  this.v[0] += x;\n  this.v[1] += y;\n  this.v[2] += z;\n  return this;\n};\n\nVec4.prototype.subtract = function(that) {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] -= that.v[i];\n  }\n  return this;\n};\n\nVec4.prototype.set = function(that) {\n  for (var i = 0; i < 4; i++) {\n    this.v[i] = that.v[i];\n  }\n  return this;\n};\n\nVec4.prototype.setXYZ = function(x, y, z) {\n  this.v[0] = x;\n  this.v[1] = y;\n  this.v[2] = z;\n  return this;\n};\n\nVec4.prototype.setRGBA = function(r, g, b, a) {\n  this.v[0] = r;\n  this.v[1] = g;\n  this.v[2] = b;\n  this.v[3] = a;\n  return this;\n};\n\nVec4.prototype.getX = Vec4.prototype.getR = function() {\n  return this.v[0];\n};\n\nVec4.prototype.getY = Vec4.prototype.getG = function() {\n  return this.v[1];\n};\n\nVec4.prototype.getZ = Vec4.prototype.getB = function() {\n  return this.v[2];\n};\n\nVec4.prototype.getW = Vec4.prototype.getA = function() {\n  return this.v[2];\n};\n\nVec4.prototype.scale1 = function(s) {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] *= s;\n  }\n  return this;\n};\n\nVec4.prototype.abs = function() {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] = Math.abs(this.v[i]);\n  }\n  return this;\n};\n\nVec4.prototype.sign = function() {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] = Math.sign(this.v[i]);\n  }\n  return this;\n};\n\nVec4.prototype.dot = function(that) {\n  var dot = 0;\n  for (var i = 0; i < 3; i++) {\n    dot += this.v[i] * that.v[i];\n  }\n  return dot;\n};\n\nVec4.prototype.magnitudeSquared = function() {\n  return this.dot(this);\n};\n\nVec4.prototype.magnitude = function() {\n  return Math.sqrt(this.magnitudeSquared());\n};\n\n/**\n * Scales to the desired length, or 0 if the vector is {0, 0}\n */\nVec4.prototype.scaleToLength = function(length) {\n  var m = this.magnitude();\n  if (m) {\n    this.scale1(length / m);\n  }\n  return this;\n};\n\n/**\n * If the magnitude is over the max, this scales it down.\n */\nVec4.prototype.clipToMaxLength = function(maxLength) {\n  var m = this.magnitude();\n  if (m > maxLength) {\n    this.scale1(maxLength / m);\n  }\n  return this;\n};\n\nVec4.prototype.setToInterpolation = function(a, b, t) {\n  for (var i = 0; i < 4; i++) {\n    this.v[i] = a.v[i] * (1-t) + b.v[i] * t;\n  }\n  return this;\n};\n\n\nVec4.prototype.equals = function(that, opt_slop) {\n  var slop = opt_slop || 0;\n  for (var i = 0; i < 3; i++) {\n    if (Math.abs(this.v[i] - that.v[i]) > slop) return false;\n  }\n  return true;\n};\n\nVec4.prototype.toString = function() {\n  return '(' + this.v.join(', ') + ')';\n};\n\nVec4.alongRayDistance = function(startPoint, towardsPoint, distance) {\n  return new Vec4()\n      .set(towardsPoint)\n      .subtract(startPoint)\n      .scaleToLength(distance)\n      .add(startPoint);\n};\n\nVec4.alongRayFraction = function(startPoint, towardsPoint, fraction) {\n  return new Vec4()\n      .set(towardsPoint)\n      .subtract(startPoint)\n      .scale(fraction)\n      .add(startPoint);\n};\n\nVec4.midpoint = function(a, b) {\n  return new Vec4()\n      .set(a)\n      .add(b)\n      .scale(0.5);\n};\n\nVec4.prototype.projectOnto = function(that) {\n  var coef = this.dot(that) / that.dot(that);\n  return this.set(that).scale(coef);\n};\n\nVec4.prototype.toJSON = function() {\n  return [this.v[0], this.v[1], this.v[2], this.v[3]];\n};\n\nVec4.prototype.setFromJSON = function(json) {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] = json[i];\n  }\n};\n\nVec4.fromJSON = function(json) {\n  return new Vec4(json[0], json[1], json[2], json[3]);\n};\n\n\n\n/**\n * @constructor\n */\nfunction Matrix33() {\n  // (0,0), (1,0), (2,0), (0,1), (1,0)...\n  this.m = [];\n  this.reset();\n}\n\nMatrix33.IDENTITY_ARRAY = [\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, 1];\n\nMatrix33.tempArray = [\n  0, 0, 0,\n  0, 0, 0,\n  0, 0, 0];\n\n/**\n * Start as the the identity matrix.\n * @returns {Matrix33}\n */\nMatrix33.prototype.reset = function() {\n  return this.toIdentity();\n};\n\nMatrix33.pool = [];\n\nMatrix33.alloc = function() {\n  if (Matrix33.pool.length) {\n    return Matrix33.pool.pop().reset();\n  }\n  return new Matrix33();\n};\n\nMatrix33.prototype.free = function() {\n  Matrix33.pool.push(this);\n};\n\nMatrix33.prototype.toIdentity = function() {\n  for (var i = 0; i < 9; i++) {\n    this.m[i] = Matrix33.IDENTITY_ARRAY[i];\n  }\n  return this;\n};\n\nMatrix33.prototype.setColRowVal = function(col, row, val) {\n  this.m[col + 3 * row] = val;\n};\n\nMatrix33.prototype.getColRowVal = function(col, row) {\n  return this.m[col + 3 * row];\n};\n\nMatrix33.prototype.toTranslateXYOp = function(tx, ty) {\n  this.toIdentity();\n  this.setColRowVal(2, 0, tx);\n  this.setColRowVal(2, 1, ty);\n  return this;\n};\n\nMatrix33.prototype.toScaleXYOp = function(sx, sy) {\n  this.toIdentity();\n  this.setColRowVal(0, 0, sx);\n  this.setColRowVal(1, 1, sy);\n  return this;\n};\n\n/**\n * Right-handed rotation clockwise as you look from the origin to positive-Z.\n * @param {number} angle\n * @returns {Matrix33}\n */\nMatrix33.prototype.toRotateOp = function(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  this.toIdentity();\n  this.setColRowVal(0, 0, cos);\n  this.setColRowVal(1, 0, -sin);\n  this.setColRowVal(0, 1, sin);\n  this.setColRowVal(1, 1, cos);\n  return this;\n};\n/**\n * Mutates this matrix by multiplying it by that one.\n * @param {Matrix33} that\n * @return {Matrix33} this, mutated\n */\nMatrix33.prototype.multiply = function(that) {\n  for (var y = 0; y < 3; y++) {\n    for (var x = 0; x < 3; x++) {\n      var val = 0;\n      for (var i = 0; i < 3; i++) {\n        val += this.m[i + 3*y] * that.m[x + 3*i];\n      }\n      Matrix33.tempArray[x + 3*y] = val;\n    }\n  }\n  for (var a = 0; a < 9; a++) {\n    this.m[a] = Matrix33.tempArray[a];\n  }\n  return this;\n};\n\nMatrix33.prototype.set = function(that) {\n  for (var i = 0; i < 9; i++) {\n    this.m[i] = that.m[i];\n  }\n  return this;\n};\n\nMatrix33.prototype.equals = function(that, opt_slop) {\n  var slop = opt_slop || 0;\n  for (var i = 0; i < 9; i++) {\n    if (Math.abs(this.m[i] - that.m[i]) > slop) return false;\n  }\n  return true;\n};\n\nMatrix33.prototype.determinant = function() {\n  var m = this.m;\n  return m[0] * m[4] * m[8] +\n       m[1] * m[5] * m[6] +\n       m[2] * m[3] * m[7] -\n       m[2] * m[4] * m[6] -\n       m[1] * m[3] * m[8] -\n       m[0] * m[5] * m[7];\n};\n\nMatrix33.prototype.toString = function() {\n  return JSON.stringify(this.m);\n};\n\nMatrix33.prototype.toJSON = function() {\n  return this.m.concat();\n};\n\nMatrix33.fromJSON = function(json) {\n  return (new Matrix33()).set(json);\n};\n\n\n\n/**\n * @constructor\n */\nfunction Matrix44() {\n  // (0,0), (1,0), (2,0), (3,0), (0,1), (1,0)...\n  this.m = [];\n  this.reset();\n}\n\nMatrix44.IDENTITY_ARRAY = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1];\n\nMatrix44.tempArray = [\n  0, 0, 0, 0,\n  0, 0, 0, 0,\n  0, 0, 0, 0,\n  0, 0, 0, 0];\n\n/**\n * Start as the the identity matrix.\n * @returns {Matrix44}\n */\nMatrix44.prototype.reset = function() {\n  return this.toIdentity();\n};\n\nMatrix44.pool = [];\n\nMatrix44.alloc = function() {\n  if (Matrix44.pool.length) {\n    return Matrix44.pool.pop().reset();\n  }\n  return new Matrix44();\n};\n\nMatrix44.prototype.free = function() {\n  Matrix44.pool.push(this);\n};\n\nMatrix44.prototype.toIdentity = function() {\n  for (var i = 0; i < 16; i++) {\n    this.m[i] = Matrix44.IDENTITY_ARRAY[i];\n  }\n  return this;\n};\n\nMatrix44.prototype.toTranslateOp = function(vec4) {\n  this.toIdentity();\n  for (var row = 0; row < 3; row++) {\n    this.m[3 + 4 * row] = vec4.v[row];\n  }\n  return this;\n};\n\nMatrix44.prototype.toTranslateOpXYZ = function(x, y, z) {\n  this.toIdentity();\n  this.m[3] = x;\n  this.m[7] = y;\n  this.m[11] = z;\n  return this;\n};\n\nMatrix44.prototype.toScaleOp = function(vec4) {\n  this.toIdentity();\n  for (var xy = 0; xy < 3; xy++) {\n    this.m[5 * xy] = vec4.v[xy];\n  }\n  return this;\n};\n\nMatrix44.prototype.toScaleOpXYZ = function(x, y, z) {\n  this.toIdentity();\n  this.m[0] = x;\n  this.m[5] = y;\n  this.m[10] = z;\n  return this;\n};\n\n/**\n * Right-handed rotation clockwise as you look from the origin to positive-X.\n * @param {number} angle\n * @returns {Matrix44}\n */\nMatrix44.prototype.toRotateXOp = function(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  this.toIdentity();\n  this.setColRowVal(1, 1, cos);\n  this.setColRowVal(2, 1, -sin);\n  this.setColRowVal(1, 2, sin);\n  this.setColRowVal(2, 2, cos);\n  return this;\n};\n\n/**\n * Right-handed rotation clockwise as you look from the origin to positive-Y.\n * @param {number} angle\n * @returns {Matrix44}\n */\nMatrix44.prototype.toRotateYOp = function(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  this.toIdentity();\n  this.setColRowVal(0, 0, cos);\n  this.setColRowVal(2, 0, sin);\n  this.setColRowVal(0, 2, -sin);\n  this.setColRowVal(2, 2, cos);\n  return this;\n};\n\n/**\n * Right-handed rotation clockwise as you look from the origin to positive-Z.\n * @param {number} angle\n * @returns {Matrix44}\n */\nMatrix44.prototype.toRotateZOp = function(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  this.toIdentity();\n  this.setColRowVal(0, 0, cos);\n  this.setColRowVal(1, 0, -sin);\n  this.setColRowVal(0, 1, sin);\n  this.setColRowVal(1, 1, cos);\n  return this;\n};\n\nMatrix44.prototype.setColRowVal = function(col, row, val) {\n  this.m[col + 4 * row] = val;\n};\n\nMatrix44.prototype.getColRowVal = function(col, row) {\n  return this.m[col + 4 * row];\n};\n\n/**\n * Mutates this matrix by multiplying it by that one.\n * @param {Matrix44} that\n * @return {Matrix44} this, mutated\n */\nMatrix44.prototype.multiply = function(that) {\n  for (var y = 0; y < 4; y++) {\n    for (var x = 0; x < 4; x++) {\n      var val = 0;\n      for (var i = 0; i < 4; i++) {\n        val += this.m[i + 4*y] * that.m[x + 4*i];\n      }\n      Matrix44.tempArray[x + 4*y] = val;\n    }\n  }\n  for (var a = 0; a < 16; a++) {\n    this.m[a] = Matrix44.tempArray[a];\n  }\n  return this;\n};\n\nMatrix44.prototype.set = function(that) {\n  for (var i = 0; i < 16; i++) {\n    this.m[i] = that.m[i];\n  }\n  return this;\n};\n\nMatrix44.prototype.setToPose = function(pose) {\n  var temp = Matrix44.alloc();\n  var retval =  this.toTranslateOp(pose.pos)\n      .multiply(temp.toScaleOp(pose.scale))\n      .multiply(temp.toRotateZOp(pose.rotZ));\n  temp.free();\n  return retval;\n};\n\nMatrix44.prototype.equals = function(that, opt_slop) {\n  var slop = opt_slop || 0;\n  for (var i = 0; i < 16; i++) {\n    if (Math.abs(this.m[i] - that.m[i]) > slop) return false;\n  }\n  return true;\n};\n\nMatrix44.prototype.getInverse = function(out) {\n  out = out || new Matrix44();\n  // Calculate the matrix of cofactors, the adugate matrix.\n  // Divide by the determinant as we go.\n  var oneOverDet = 1/this.determinant();\n  var cofactor = Matrix33.alloc();\n  for (var y = 0; y < 4; y++) {\n    for (var x = 0; x < 4; x++) {\n      // Transpose as we go, by swapping x and y coords.\n      out.setColRowVal(y, x,\n          oneOverDet *\n          ((x % 2) ? -1 : 1) *\n          ((y % 2) ? -1 : 1) *\n          this.getCofactor(x, y, cofactor).determinant());\n    }\n  }\n  cofactor.free();\n  return out;\n};\n\nMatrix44.prototype.transpose = function() {\n  for (var y = 0; y < 3; y++) {\n    for (var x = y + 1; x < 4; x++) {\n      var temp = this.getColRowVal(x, y);\n      this.setColRowVal(x, y, this.getColRowVal(y, x));\n      this.setColRowVal(y, x, temp);\n    }\n  }\n  return this;\n};\n\nMatrix44.prototype.determinant = function() {\n  var total = 0;\n  var row = 0;\n  var cofactor = Matrix33.alloc();\n  for (var col = 0; col < 4; col++) {\n    this.getCofactor(col, row, cofactor);\n    total +=\n        ((col % 2) ? -1 : 1) *\n        this.getColRowVal(col, row) *\n        cofactor.determinant();\n  }\n  cofactor.free();\n  return total;\n};\n\nMatrix44.prototype.getCofactor = function(col, row, mat33) {\n  mat33 = mat33 || new Matrix33();\n  for (var y = 0; y < 3; y++) {\n    for (var x = 0; x < 3; x++) {\n      mat33.setColRowVal(x, y, this.getColRowVal(x + (x < col ? 0 : 1), y + (y < row ? 0 : 1)));\n    }\n  }\n  return mat33;\n};\n\nMatrix44.prototype.toString = function() {\n  return JSON.stringify(this.m);\n};\n\nMatrix44.prototype.toJSON = function() {\n  return this.m.concat();\n};\n\nMatrix44.fromJSON = function(json) {\n  return (new Matrix44()).set(json);\n};\n\n\n\n/**\n * Allows a publisher to call multiple subscriber functions at once.\n * Subscribers can add and remove themselves.\n * @constructor\n */\nPubSub = function() {\n  this.subs = new ArraySet();\n};\n\n/**\n * Adds a subscriber function.\n * @param {Object} func\n */\nPubSub.prototype.subscribe = function(func) {\n  this.subs.put(func);\n};\n\n/**\n * Deletes a subscriber function.\n * @param {Object} func\n */\nPubSub.prototype.unsubscribe = function(func) {\n  this.subs.remove(func);\n};\n\n/**\n * Calls all the subscribers in the order in which they were added,\n * passing all arguments along.  Calls the functions in the global context.\n */\nPubSub.prototype.publish = function(/* whatever */) {\n  for (var i = 0, n = this.subs.vals.length; i < n; ++i) {\n    this.subs.vals[i].apply(null, arguments);\n  }\n};\n\n/**\n * Clears the subscriber list.\n */\nPubSub.prototype.clear = function () {\n  this.subs.clear();\n};\n\n\n\n/**\n * @param {Array.<String>} paths\n * @constructor\n */\nfunction TextLoader(paths) {\n  this.paths = paths;\n  this.texts = {};\n}\n\n/**\n * @param {Function} callback\n */\nTextLoader.prototype.load = function(callback) {\n  this.callback = callback;\n  for (var i = 0; i < this.paths.length; i++) {\n    this.loadTextNum(i);\n  }\n};\n\nTextLoader.prototype.getTextByIndex = function(num) {\n  return this.getTextByPath(this.paths[num]);\n};\n\nTextLoader.prototype.getTextByPath = function(path) {\n  return this.texts[path];\n};\n\n\n/////////////\n// PRIVATE //\n/////////////\n\nTextLoader.prototype.loadTextNum = function(num) {\n  var path = this.paths[num];\n  if (!this.texts[path]) {\n    this.xhr(path, this.getOnTextLoadedFunc(num));\n  }\n};\n\nTextLoader.prototype.getOnTextLoadedFunc = function(num) {\n  var self = this;\n  return function(text) {\n    var path = self.paths[num];\n    self.texts[path] = text;\n    self.callback && self.callback(num);\n  };\n};\n\nTextLoader.prototype.xhr = function(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'text';\n  xhr.onload = function() {\n    callback(this.response);\n  };\n  xhr.send();\n};\n\n\n\n/**\n * An axis-aligned rectangle with a center and an x and y radius (half height and half width)\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_rx\n * @param {=number} opt_ry\n * @constructor\n */\nfunction Rect(opt_x, opt_y, opt_rx, opt_ry) {\n  this.pos = new Vec2d();\n  this.rad = new Vec2d();\n  this.reset(opt_x, opt_y, opt_rx, opt_ry);\n}\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_rx\n * @param {=number} opt_ry\n */\nRect.prototype.reset = function(opt_x, opt_y, opt_rx, opt_ry) {\n  this.pos.setXY(opt_x || 0 , opt_y || 0);\n  this.rad.setXY(opt_rx || 0, opt_ry || 0);\n  return this;\n};\n\nRect.pool = [];\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_rx\n * @param {=number} opt_ry\n */\nRect.alloc = function(opt_x, opt_y, opt_rx, opt_ry) {\n  if (Rect.pool.length) {\n    return Rect.pool.pop().reset(opt_x, opt_y, opt_rx, opt_ry);\n  }\n  return new Rect(opt_x, opt_y, opt_rx, opt_ry);\n};\n\nRect.prototype.free = function() {\n  Rect.pool.push(this);\n};\n\nRect.free = function(obj) {\n  obj.free();\n};\n\nRect.prototype.set = function(r) {\n  this.pos.set(r.pos);\n  this.rad.set(r.rad);\n  return this;\n};\n\nRect.prototype.setToCorners = function(a, b) {\n  this.pos.set(a).add(b).scale(0.5);\n  this.rad.set(a).subtract(b).scale(0.5).abs();\n  return this;\n};\n\nRect.prototype.setPos = function(v) {\n  this.pos.set(v);\n  return this;\n};\n\nRect.prototype.setRad = function(v) {\n  this.rad.set(v);\n  return this;\n};\n\nRect.prototype.setPosXY = function(x, y) {\n  this.pos.setXY(x, y);\n  return this;\n};\n\nRect.prototype.setRadXY = function(x, y) {\n  this.rad.setXY(x, y);\n  return this;\n};\n\nRect.prototype.padXY = function(x, y) {\n  this.rad.x += x;\n  this.rad.y += y;\n  return this;\n};\n\nRect.prototype.pad = function(p) {\n  this.rad.x += p;\n  this.rad.y += p;\n  return this;\n};\n\nRect.prototype.coverRect = function(that) {\n  var minX = Math.min(this.getMinX(), that.getMinX());\n  var minY = Math.min(this.getMinY(), that.getMinY());\n  var maxX = Math.max(this.getMaxX(), that.getMaxX());\n  var maxY = Math.max(this.getMaxY(), that.getMaxY());\n  this.pos.setXY((minX + maxX) / 2, (minY + maxY) / 2);\n  this.rad.setXY(Math.abs(minX - maxX) / 2, Math.abs(minY - maxY) / 2);\n  return this;\n};\n\nRect.prototype.coverVec = function(v) {\n  return this.coverXY(v.x, v.y);\n};\n\nRect.prototype.coverXY = function(x, y) {\n  var minX = Math.min(this.getMinX(), x);\n  var minY = Math.min(this.getMinY(), y);\n  var maxX = Math.max(this.getMaxX(), x);\n  var maxY = Math.max(this.getMaxY(), y);\n  this.pos.setXY((minX + maxX) / 2, (minY + maxY) / 2);\n  this.rad.setXY(Math.abs(minX - maxX) / 2, Math.abs(minY - maxY) / 2);\n  return this;\n};\n\nRect.prototype.getMinX = function() {\n  return this.pos.x - this.rad.x;\n};\n\nRect.prototype.getMinY = function() {\n  return this.pos.y - this.rad.y;\n};\n\nRect.prototype.getMaxX = function() {\n  return this.pos.x + this.rad.x;\n};\n\nRect.prototype.getMaxY = function() {\n  return this.pos.y + this.rad.y;\n};\n\nRect.prototype.getWidth = function() {\n  return this.rad.x * 2;\n};\n\nRect.prototype.getHeight = function() {\n  return this.rad.y * 2;\n};\n\nRect.prototype.overlapsRectXYXY = function(x, y, rx, ry) {\n  return Math.abs(this.pos.x - x) <= this.rad.x + rx &&\n         Math.abs(this.pos.y - y) <= this.rad.y + ry;\n};\n\n\n/**\n * A SkipQueue priority queue, ordered by time.\n * Nodes must have a \"time\" value, and a \"next\" array.\n * @constructor\n */\nfunction SkipQueue(base, maxLevel) {\n  this.base = base;\n  this.maxLevel = maxLevel;\n  this.levelUpOdds = 1 / this.base;\n\n  this.level = this.maxLevel;\n  this.next = [];\n  this.size = 0;  \n  this.prevs = [];\n}\n\nSkipQueue.getRecommendedMaxLevel = function(expectedLength, base) {\n  return Math.ceil(Math.log(expectedLength) / Math.log(base));\n};\n\nSkipQueue.prototype.randomLevel = function() {\n  var level = 0;\n  var rand = Math.random();\n  var bar = this.levelUpOdds;\n  while (rand < bar && level < this.maxLevel) {\n    level++;\n    bar *= this.levelUpOdds;\n  }\n  return level;\n};\n\n/**\n * Add a node, in the right order.\n * @param {Object} addMe\n */\nSkipQueue.prototype.add = function(addMe) {\n  var prevs = this.prevs;\n  addMe.level = this.randomLevel();\n  \n  // set up for traversal\n  var node = this;\n\n  var next;\n  for (var level = this.maxLevel; level >= 0; --level) {\n    // right\n    next = node.next[level];\n    while (next && next.time < addMe.time) {\n      node = next;\n      next = node.next[level];\n    }\n    prevs[level] = node;\n  }\n  // For the levels that this node blocks, do inserts.\n  for (level = addMe.level; level >= 0; --level) {\n    addMe.next[level] = prevs[level].next[level];\n    prevs[level].next[level] = addMe;\n  }\n  this.size++;\n};\n\n/**\n * Returns the first node, or null if empty, and also removes it.\n */\nSkipQueue.prototype.removeFirst = function() {\n  var node = this.next[0];\n  if (!node) return null;\n  for (var level = node.level; level >= 0; --level) {\n    this.next[level] = node.next[level];\n  }\n  this.size--;\n  return node;\n};\n\n/**\n * Returns the first node without removing it.\n */\nSkipQueue.prototype.getFirst = function() {\n  return this.next[0];\n};\n\nSkipQueue.prototype.toString = function() {\n  var node = this.next[0];\n  var out = [];\n  while (node != null) {\n    out.push(node.toString());\n    node = node.next[0];\n  }\n  return '[' + out.join(',\\n') + ']';\n};\n\n\n/**\n * A small set, implemented with an array.\n * It has O(n) put, remove, and contains, but it has fast iteration.\n * Good for small sets that will get iterated over a lot.\n * Chrome can optimize this, because there are no for-each loops over arbitrary keys.\n * @constructor\n */\nfunction ArraySet() {\n  this.vals = [];\n}\n\nArraySet.prototype.reset = function() {\n  this.vals.length = 0;\n  return this;\n};\n\nPoolify(ArraySet);\n\nArraySet.prototype.put = function(v) {\n  for (var i = 0; i < this.vals.length; i++) {\n    if (this.vals[i] == v) {\n      return;\n    }\n  }\n  this.vals.push(v);\n  return this;\n};\n\nArraySet.prototype.contains = function(v) {\n  for (var i = 0; i < this.vals.length; i++) {\n    if (this.vals[i] == v) {\n      return true;\n    }\n  }\n  return false;\n};\n\nArraySet.prototype.remove = function(v) {\n  for (var i = 0; i < this.vals.length; i++) {\n    if (this.vals[i] == v) {\n      this.vals[i] = this.vals[this.vals.length - 1];\n      this.vals.pop();\n    }\n  }\n  return this;\n};\n\nArraySet.prototype.clear = function(v) {\n  this.vals.length = 0;\n  return this;\n};\n\n\nArraySet.prototype.removeIndex = function(index) {\n  this.vals[index] = this.vals[this.vals.length - 1];\n  this.vals.pop();\n  return this;\n};\n\nArraySet.prototype.isEmpty = function() {\n  return this.vals.length == 0;\n};\n\nArraySet.prototype.getValues = function() {\n  return this.vals.concat();\n};\n\nArraySet.prototype.size = function() {\n  return this.vals.length;\n};\n\n\n\n/**\n * A small set, implemented with an object.\n * Has the same interface as ArraySet, for easy swapping out.\n * @constructor\n */\nfunction ObjSet() {\n  this.vals = {};\n}\n\nObjSet.prototype.reset = function() {\n  for (var key in this.vals) {\n    delete this.vals[key];\n  }\n  return this;\n};\n\nPoolify(ObjSet);\n\nObjSet.prototype.put = function(v) {\n  this.vals[v] = true;\n  return this;\n};\n\nObjSet.prototype.contains = function(v) {\n  return !!this.vals[v];\n};\n\nObjSet.prototype.remove = function(v) {\n  delete this.vals[v];\n  return this;\n};\n\nObjSet.prototype.clear = function(v) {\n  return this.reset();\n};\n\n\nObjSet.prototype.isEmpty = function() {\n  for (var key in this.vals) {\n    return false;\n  }\n  return true;\n};\n\nObjSet.prototype.getValues = function() {\n  var retval = {};\n  for (var key in this.vals) {\n    retval[key] = this.vals[key];\n  }\n  return retval;\n};\n\nObjSet.prototype.size = function() {\n  var n = 0;\n  for (var key in this.vals) {\n    n++;\n  }\n  return n;\n};\n\n\n\n/**\n * A circular buffer, backed by an array.\n * In this API, enqueuing adds to the head, and dequeing removes from the tail.\n * This might be backwards from what you're used to. But I wrote this when I was\n * thinking of a rotating log, so the \"head\" was the present, and the \"tail\" was the past,\n * ad you'd add the the head, and usually process the tail first. Sorry for any confusion.\n * \n * @param {number} maxLen  Must be one or more.\n * @constructor\n */\nfunction CircularQueue(maxLen) {\n  if (maxLen < 1) {\n    throw new Error('maxlen must be at least one, but it was ' + maxLen);\n  }\n  this.maxLen = maxLen;\n  this.a = [];\n  this.head = this.tail = -1;\n}\n\n/**\n * @return {boolean}\n */\nCircularQueue.prototype.isEmpty = function() {\n  return this.head == -1;\n};\n\n/**\n * @return {boolean}\n */\nCircularQueue.prototype.isFull = function() {\n  if (this.head == -1) return false;\n  var nextHead = this.head + 1;\n  if (nextHead >= this.maxLen) {\n    nextHead = 0;\n  }\n  return nextHead == this.tail;\n};\n\n/**\n * Adds an item to the head of the queue.\n * If the queue is full, an item is dropped from the tail.\n * @param val  Any value, to be enqueued.\n * @return the object that fell off the tail, or null if nothing fell off\n */\nCircularQueue.prototype.enqueue = function(val) {\n  var whatFellOff = null;\n  if (this.head == -1) {\n    // was empty\n    this.head = this.tail = 0;\n  } else {\n    this.head++;\n    if (this.head >= this.maxLen) {\n      this.head = 0;\n    }\n    if (this.head == this.tail) {\n      whatFellOff = this.a[this.tail];\n      // something falls off the tail\n      this.tail++;\n      if (this.tail >= this.maxLen) {\n        this.tail = 0;\n      }\n    }\n  }\n  this.a[this.head] = val;\n  return whatFellOff;\n};\n\n\n/**\n * @return Whatever was pulled off the tail of the queue, or null if the queue is empty.\n */\nCircularQueue.prototype.dequeue = function() {\n  if (this.tail == -1) {\n    // empty\n    return null;\n  }\n  var val = this.a[this.tail];\n  if (this.tail == this.head) {\n    // now it's empty\n    this.head = this.tail = -1;\n  } else {\n    // move tail fwd\n    this.tail++;\n    if (this.tail >= this.maxLen) {\n      this.tail = 0;\n    }\n  }\n  return val;\n};\n\n\n/**\n * @return {number} number of elements in the queue, between 0 and maxLength\n */\nCircularQueue.prototype.size = function() {\n  if (this.tail == -1) {\n    // empty\n    return 0;\n  }\n  var size = 1 + this.head - this.tail;\n  if (size <= 0) {\n    size += this.maxLen;\n  }\n  return size;\n};\n\n\n/**\n * @param {number} index gets the nth index from the tail.  Does not dequeue.\n */\nCircularQueue.prototype.getFromTail = function(index) {\n  if (index < 0) {\n    throw new Error(\"index \" + index + \" < 0\");\n  }\n  if (index >= this.size()) {\n    throw new Error(\"index \" + index + \" is greater than size \" + this.size());\n  }\n  var i = index + this.tail;\n  if (i >= this.maxLen) {\n    // wrap around\n    i -= this.maxLen;\n  }\n  return this.a[i];\n};\n\n/**\n * @param {number} index gets the nth index from the head.  Does not dequeue.\n */\nCircularQueue.prototype.getFromHead = function(index) {\n  if (index < 0) {\n    throw new Error(\"index \" + index + \" < 0\");\n  }\n  if (index >= this.size()) {\n    throw new Error(\"index \" + index + \" is greater than size \" + this.size());\n  }\n  var i = this.head - index;\n  if (i < 0) {\n    // wrap around\n    i += this.maxLen;\n  }\n  return this.a[i];\n};\n\n\n\n/**\n * The kind of thing you need to map from model-space and world-space.\n * 4D is kind of overkill but lets not be stingy.\n * @constructor\n */\nfunction Pose(opt_pos, opt_rotZ, opt_scale) {\n  this.pos = new Vec4();\n  this.rotZ = 0;\n  this.scale = new Vec4();\n  this.reset(opt_pos, opt_rotZ, opt_scale);\n}\n\nPose.prototype.reset = function(opt_pos, opt_rotZ, opt_scale) {\n  if (opt_pos) {\n    this.pos.set(opt_pos);\n  }\n  opt_rotZ = opt_rotZ || 0;\n  this.rotZ = opt_rotZ;\n  if (opt_scale) {\n    this.scale.set(opt_scale);\n  }\n  return this;\n};\n\nPose.pool = [];\n\nPose.alloc = function(pos, rotZ, scale) {\n  if (Pose.pool.length) {\n    return Pose.pool.pop().reset(pos, rotZ, scale);\n  }\n  return new Pose(pos, rotZ, scale);\n};\n\nPose.prototype.free = function() {\n  Pose.pool.push(this);\n};\n\nPose.SCHEMA = {\n  0: \"pos\",\n  1: \"rotZ\",\n  2: \"scale\"\n};\n\nPose.getJsoner = function() {\n  if (!Pose.jsoner) {\n    Pose.jsoner = new Jsoner(Pose.SCHEMA);\n  }\n  return Pose.jsoner;\n};\n\nPose.prototype.toJSON = function() {\n  return Pose.getJsoner().toJSON(this);\n};\n\nPose.prototype.setFromJSON = function(json) {\n  Pose.getJsoner().setFromJSON(json, this);\n};\n\nPose.prototype.set = function(that) {\n  this.pos.set(that.pos);\n  this.rotZ = that.rotZ;\n  this.scale.set(that.scale);\n};\n\nPose.prototype.setToInterpolation = function(a, b, t) {\n  this.pos.setToInterpolation(a.pos, b.pos, t);\n  this.rotZ = a.rotZ * (1-t) + b.rotZ * t;\n  this.scale.setToInterpolation(a.scale, b.scale, t);\n}; \n\n\n\n// taken from https://bitbucket.org/davidchambers/base64.js/src\n// Adds text/base64 conversion \"atob\" and \"btoa\" to browsers that don't have it, i.e. IE.\n;(function () {\n\n  var\n      object = window,\n      chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  if (!object['btoa']) {\n    object.btoa = function (input) {\n      for (\n        // initialize result and counter\n          var block, charCode, idx = 0, map = chars, output = '';\n        // if the next input index does not exist:\n        //   change the mapping table to \"=\"\n        //   check if d has no fractional digits\n          input.charAt(idx | 0) || (map = '=', idx % 1);\n        // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n          output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n          ) {\n        charCode = input.charCodeAt(idx += 3 / 4);\n        if (charCode > 0xFF) throw Error('invalid charCode:' + charCode);\n        block = block << 8 | charCode;\n      }\n      return output;\n    };\n  }\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  if (!object['atob']) {\n      object.atob = function (input) {\n        input = input.replace(/=+$/, '');\n        if (input.length % 4 == 1) throw Error('invalid input length:' + input.length);\n        for (\n          // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = '';\n          // get next character\n            buffer = input.charAt(idx++);\n          // character found in table? initialize bit storage and add its ascii value;\n            ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n              // and if not first of each 4 characters,\n              // convert the first 8 bits to one ascii character\n                bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n            ) {\n          // try to find character in table (0-63, not found => -1)\n          buffer = chars.indexOf(buffer);\n        }\n        return output;\n      };\n  }\n}());\n\n\n\nBitQueue = function() {\n  // Array of strings that we append to when writing, and that we\n  // consolidate into a single string when reading.\n  this.queue = [];\n  this.nextReadPos = 0;\n  this.length = 0;\n};\n\n/**\n * @param num\n * @param bitCount\n */\nBitQueue.prototype.enqueueNumber = function(num, bitCount) {\n  // todo: trim the read part off the 0th element, and reset nextReadPos.\n  var bitStr = Number(num).toString(2);\n  if (bitStr.length > bitCount) {\n    throw Error('number ' + num + ' has more bits than bitCount ' + bitCount);\n  }\n  this.queue.push(Strings.padLeft(bitStr, '0', bitCount));\n  this.length += bitCount;\n};\n\n/**\n * @param bitCount  the number of bits to consume to read a number.\n * @return {Number}\n */\nBitQueue.prototype.dequeueNumber = function(bitCount) {\n  // Smush the queue into one string before reading.\n  if (this.queue.length > 1) {\n    this.queue[0] = this.queue.join('');\n    this.queue.length = 1;\n  }\n  var queueStr = this.queue[0];\n  var queueLen = queueStr.length - this.nextReadPos;\n  if (bitCount > queueLen) {\n    throw Error('bitCount ' + bitCount + ' > queueLen ' + queueLen);\n  }\n  var bitStr = queueStr.substr(this.nextReadPos, bitCount);\n  var num = parseInt(bitStr, 2);\n  this.nextReadPos += bitCount;\n  this.length -= bitCount;\n  return num;\n};\n\n/**\n * Writes an array of chars representihg bytes into the BitQueue.\n * This is the opposite of dequeueToBytesAndPadZerosRight().\n * @param bytes\n */\nBitQueue.prototype.enqueueBytes = function(bytes) {\n  for (var i = 0; i < bytes.length; i++) {\n    this.enqueueNumber(bytes.charCodeAt(i), 8);\n  }\n};\n\n/**\n * Serializes the BitQueue to an array of characters representing numbers from 0-255.\n * This is the opposite of enqueueBytes().\n * @returns {string}\n */\nBitQueue.prototype.dequeueToBytesAndPadZerosRight = function() {\n  var bytesArray = [];\n  var tailLength = this.length % 8;\n  if (tailLength) {\n    this.enqueueNumber(0, 8 - tailLength);\n  }\n  while (this.length) {\n    var num = this.dequeueNumber(8);\n    bytesArray.push(String.fromCharCode(num));\n  }\n  return bytesArray.join('');\n};\n\n\n/**\n * A line segment.\n * @param {Vec2d} p1\n * @param {Vec2d} p2\n * @constructor\n */\nfunction Segment(p1, p2) {\n  this.p1 = p1;\n  this.p2 = p2;\n  this.lengthSquared = p1.distanceSquared(p2);\n}\n\nSegment.prototype.distanceToPointSquared = function(p3) {\n  if (this.lengthSquared == 0) return this.p1.distanceSquared(p3);\n  var x1 = this.p1.x;\n  var y1 = this.p1.y;\n  var x2 = this.p2.x;\n  var y2 = this.p2.y;\n\n  // u is 0 at p1 and 1 at p2.\n  // Find the value of u where p3 is closest to the segment\n  var u = ((p3.x - x1)*(x2 - x1) + (p3.y - y1)*(y2 - y1)) / this.lengthSquared;\n  var retval;\n  if (u < 0) {\n    retval = p3.distanceSquared(this.p1);\n  } else if (u > 1) {\n    retval = p3.distanceSquared(this.p2);\n  } else {\n    var p = Vec2d.alloc();\n    p.set(this.p2).subtract(this.p1).scale(u).add(this.p1);\n    retval = p3.distanceSquared(p);\n    p.free();\n  }\n  return retval;\n};\n\nSegment.prototype.distanceToPointSquaredXY = function(x, y) {\n  var v = Vec2d.alloc(x, y);\n  var dist = this.distanceToPointSquared(v);\n  v.free();\n  return dist;\n};\n\nSegment.prototype.getBoundingRect = function(rectOut) {\n  if (!rectOut) rectOut = new Rect();\n  return rectOut.setToCorners(this.p1, this.p2);\n};\n\n\n/**\n * An very big grid of pixels, optimized for memory, speed, and serialization size.\n * It has over 67 million rows and columns, each holding a 32x32 subgrid of pixels.\n * Values are 0 and 1, defaulting to 0.\n * @constructor\n */\nfunction BitGrid(pixelSize) {\n  this.bitWorldSize = pixelSize;\n  this.cellWorldSize = this.bitWorldSize * BitGrid.BITS;\n\n  // A cell can be nonexistent (value 0), or have a value of 1, or an array of 32 32-bit integers forming a\n  // 32x32 pixel subgrid.\n  this.cells = {};\n\n  // A map from touched cellIds to their old values, so callers can see which were modified.\n  this.changedCells = {};\n}\n\n/**\n * Quadtree compression assumes that this is a power of 2.\n * JavaScript bitwise operations only work on the first 32 bits of a number.\n * So 32 is a good number.\n * @type {number}\n */\nBitGrid.BITS = 32;\n\n// It's got over 67 million columns.\nBitGrid.COLUMNS = 0x4000000;\n\nBitGrid.ROW_OF_ONES = (function() {\n  var row = 0;\n  for (var i = 0; i < BitGrid.BITS; i++) {\n    row |= (1 << i);\n  }\n  return row;\n})();\n\nBitGrid.prototype.cellIdToIndexVec = function(cellId, out) {\n  if (!out) out = new Vec2d();\n  var cy = Math.floor(cellId / BitGrid.COLUMNS);\n  var cx = cellId - cy * BitGrid.COLUMNS - BitGrid.COLUMNS / 2;\n  out.setXY(cx, cy);\n  return out;\n};\n\nBitGrid.prototype.flushChangedCellIds = function() {\n  var changedIds = [];\n  for (var id in this.changedCells) {\n    if (this.changedCells[id] != this.cells[id]) {\n      changedIds.push(id);\n    }\n  }\n  this.changedCells = {};\n  return changedIds;\n};\n\nBitGrid.prototype.getRectsOfColorForCellId = function(color, cellId) {\n  var bx, by;\n  var self = this;\n  function createRect(bx0, by0, bx1, by1) {\n    var wx0 = cx * self.cellWorldSize + (bx0 - 0.5) * self.bitWorldSize;\n    var wy0 = cy * self.cellWorldSize + (by0 - 0.5) * self.bitWorldSize;\n    var wx1 = cx * self.cellWorldSize + (bx1 + 0.5) * self.bitWorldSize;\n    var wy1 = cy * self.cellWorldSize + (by1 + 0.5) * self.bitWorldSize;\n    return new Rect(\n        (wx0 + wx1)/2, (wy0 + wy1)/2, (wx1 - wx0)/2, (wy1 - wy0)/2);\n  }\n\n  var cy = Math.floor(cellId / BitGrid.COLUMNS);\n  var cx = cellId - cy * BitGrid.COLUMNS - BitGrid.COLUMNS / 2;\n  var rects = [];\n  var cell = this.cells[cellId];\n  if (this.cellEqualsColor(cell, color)) {\n    rects.push(new Rect(\n        (cx + 0.5) * this.cellWorldSize - this.bitWorldSize/2,\n        (cy + 0.5) * this.cellWorldSize - this.bitWorldSize/2,\n        this.cellWorldSize / 2,\n        this.cellWorldSize / 2));\n  } else if (Array.isArray(cell)) {\n\n    var oldRects = {};\n    for (by = 0; by < BitGrid.BITS; by++) {\n      var newRects = {};\n      var runStartX = -1;\n      // Record newRects in this row.\n      for (bx = 0; bx < BitGrid.BITS; bx++) {\n        var bit = (cell[by] >> bx) & 1;\n        if (bit == color) {\n          // Color match.\n          if (runStartX < 0) {\n            // First bit on the row.\n            runStartX = bx;\n            newRects[runStartX] = {startY: by, endX: bx};\n          } else {\n            // Continue run\n            newRects[runStartX].endX = bx;\n          }\n        } else {\n          // Not a color match.\n          runStartX = -1;\n        }\n      }\n      var isLastRow = by == BitGrid.BITS - 1;\n      for (bx = 0; bx < BitGrid.BITS; bx++) {\n        var oldRect = oldRects[bx];\n        var newRect = newRects[bx];\n        // Harvest unmatched old ones.\n        if (oldRect && newRect && oldRect.endX == newRect.endX) {\n          // This is a merge, unless we're on the last row, in which case we harvest.\n          if (isLastRow) {\n            // last row harvest\n            rects.push(createRect(bx, oldRect.startY, oldRect.endX, by));\n          }\n        } else {\n          // old and new are not equal start/end (or maybe not existent)\n          if (oldRect) {\n            // harvest and delete\n            rects.push(createRect(bx, oldRect.startY, oldRect.endX, by - 1));\n            delete oldRects[bx];\n          }\n          if (newRect) {\n            if (isLastRow) {\n              // make rect on this row\n              rects.push(createRect(bx, newRect.startY, newRect.endX, by));\n            } else {\n              // graduate\n              oldRects[bx] = newRects[bx];\n            }\n          }\n        }\n      }\n    }\n  }\n  return rects;\n};\n\n/**\n * @returns {Number} the grid cell X index that corresponds with world coord X.\n */\nBitGrid.prototype.getCellIndexX = function(x) {\n  return Math.floor(x / this.cellWorldSize);\n};\n\n/**\n * @return {Number} the grid cell Y index that corresponds with world coord Y.\n */\nBitGrid.prototype.getCellIndexY = function(y) {\n  return Math.floor(y / this.cellWorldSize);\n};\n\nBitGrid.prototype.getCellIdAtIndexXY = function(cx, cy) {\n  return BitGrid.COLUMNS * cy + cx + BitGrid.COLUMNS/2;\n};\n\nBitGrid.prototype.getCellAtIndexXY = function(cx, cy) {\n  return this.cells[this.getCellIdAtIndexXY(cx, cy)];\n};\n\nBitGrid.prototype.setCellAtIndexXY = function(cx, cy, cell) {\n  this.cells[this.getCellIdAtIndexXY(cx, cy)] = cell;\n};\n\nBitGrid.prototype.deleteCellAtIndexXY = function(cx, cy) {\n  delete this.cells[this.getCellIdAtIndexXY(cx, cy)];\n};\n\nBitGrid.prototype.cellEqualsColor = function(cell, color) {\n  return !Array.isArray(cell) && ((color == 0 && !cell) || (color == 1 && cell === 1));\n};\n\nBitGrid.prototype.drawPill = function(seg, rad, color) {\n  // bounding rect\n  var rect = seg.getBoundingRect(this.rect).pad(rad);\n  var cx0 = this.getCellIndexX(rect.getMinX());\n  var cy0 = this.getCellIndexY(rect.getMinY());\n  var cx1 = this.getCellIndexX(rect.getMaxX());\n  var cy1 = this.getCellIndexY(rect.getMaxY());\n  for (var cx = cx0; cx <= cx1; cx++) {\n    for (var cy = cy0; cy <= cy1; cy++) {\n      var cell = this.getCellAtIndexXY(cx, cy);\n      if (!this.cellEqualsColor(cell, color)) {\n        this.drawPillOnCellIndexXY(seg, rad, color, cx, cy);\n      }\n    }\n  }\n};\n\nBitGrid.prototype.drawPillOnCellIndexXY = function(seg, rad, color, cx, cy) {\n  var pixelCenter = Vec2d.alloc();\n  var cell = this.getCellAtIndexXY(cx, cy);\n\n  var cellId = this.getCellIdAtIndexXY(cx, cy);\n  var clean = !(cellId in this.changedCells);\n\n  var radSquared = rad * rad;\n  var isArray = Array.isArray(cell);\n  var startingColor = isArray ? 0.5 : (cell ? 1 : 0);\n  var zeroRows = 0;\n  var oneRows = 0;\n  for (var by = 0; by < BitGrid.BITS; by++) {\n    var oldRowVal = isArray ? cell[by] : (startingColor ? BitGrid.ROW_OF_ONES : 0);\n    var newRowVal = oldRowVal;\n    pixelCenter.y = cy * this.cellWorldSize + by * this.bitWorldSize;\n    for (var bx = 0; bx < BitGrid.BITS; bx++) {\n      pixelCenter.x = cx * this.cellWorldSize + bx * this.bitWorldSize;\n      if (seg.distanceToPointSquared(pixelCenter) <= radSquared) {\n        newRowVal = color\n            ? (newRowVal | (1 << bx))\n            : (newRowVal & (BitGrid.ROW_OF_ONES ^ (1 << bx)));\n      }\n    }\n    if (newRowVal == 0) {\n      zeroRows++;\n    } else if (newRowVal == BitGrid.ROW_OF_ONES) {\n      oneRows++;\n    }\n\n    if (newRowVal != oldRowVal) {\n      // If it was clean to start with, then preserve the clean value in changedCells.\n      if (clean) {\n        this.changedCells[cellId] = Array.isArray(cell) ? cell.concat() : cell;\n        clean = false;\n      }\n      // If it wasn't an array already, make it one now so we can adjust this row.\n      if (!isArray) {\n        cell = this.createCellArray(startingColor);\n        this.setCellAtIndexXY(cx, cy, cell);\n        isArray = true;\n      }\n      cell[by] = newRowVal;\n    }\n  }\n\n  // Simplify the grid?\n  if (zeroRows == BitGrid.BITS) {\n    this.deleteCellAtIndexXY(cx, cy);\n  } else if (oneRows == BitGrid.BITS) {\n    this.setCellAtIndexXY(cx, cy, 1);\n  }\n  pixelCenter.free();\n};\n\nBitGrid.prototype.createCellArray = function(color) {\n  var cell = new Array(BitGrid.BITS);\n  var rowVal = color ? BitGrid.ROW_OF_ONES : 0;\n  for (var i = 0; i < BitGrid.BITS; i++) {\n    cell[i] = rowVal;\n  }\n  return cell;\n};\n\nBitGrid.SOLID = 1;\nBitGrid.DETAILED = 0;\n\n/**\n * The \"cells\" field is an object where\n * each key is a cellId in base 32,\n * and each value is a base64-encoded BitQueue quadtree representation of the cell.\n * @returns {{bitWorldSize: *, cells: {}}}\n */\nBitGrid.prototype.toJSON = function() {\n  function enqueueQuad(startX, startY, size) {\n    var startColor = (cell[startY] & (1 << startX)) ? 1 : 0;\n    if (size == 1) {\n      bitQueue.enqueueNumber(startColor, 1);\n      return;\n    }\n    for (var by = startY; by < startY + size; by++) {\n      for (var bx = startX; bx < startX + size; bx++) {\n        var pixel = (cell[by] & (1 << bx)) ? 1 : 0;\n        if (pixel != startColor) {\n          // non-uniform square. Lets get quadruple recursive!\n          bitQueue.enqueueNumber(BitGrid.DETAILED, 1);\n          var half = size/2;\n          enqueueQuad(startX, startY, half);\n          enqueueQuad(startX + half, startY, half);\n          enqueueQuad(startX, startY + half, half);\n          enqueueQuad(startX + half, startY + half, half);\n          return;\n        }\n      }\n    }\n    // uniform square\n    bitQueue.enqueueNumber(BitGrid.SOLID, 1);\n    bitQueue.enqueueNumber(startColor, 1);\n  }\n\n  var json = {\n    bitWorldSize: this.bitWorldSize,\n    cells:{}\n  };\n  for (var cellId in this.cells) {\n    var cell = this.cells[cellId];\n    var bitQueue = new BitQueue();\n    if (Array.isArray(cell)) {\n      enqueueQuad(0, 0, BitGrid.BITS);\n    } else {\n      // Uniform cell\n      bitQueue.enqueueNumber(BitGrid.SOLID, 1);\n      bitQueue.enqueueNumber(cell, 1);\n    }\n    json.cells[Number(cellId).toString(32)] = btoa(bitQueue.dequeueToBytesAndPadZerosRight());\n  }\n  return json;\n};\n\nBitGrid.fromJSON = function(json) {\n  function plot(x, y, c) {\n    if (c) {\n      cell[y] |= 1 << x;\n    } else {\n      cell[y] &= BitGrid.ROW_OF_ONES ^ (1 << x);\n    }\n  }\n\n  function dequeueQuad(startX, startY, size) {\n    var color;\n    if (size == 1) {\n      color = bitQueue.dequeueNumber(1);\n      plot(startX, startY, color);\n      return;\n    }\n    var kind = bitQueue.dequeueNumber(1);\n    if (kind == BitGrid.SOLID) {\n      color = bitQueue.dequeueNumber(1);\n      for (var by = startY; by < startY + size; by++) {\n        for (var bx = startX; bx < startX + size; bx++) {\n          plot(bx, by, color);\n        }\n      }\n    } else {\n      // DETAILED\n      var half = size/2;\n      dequeueQuad(startX, startY, half);\n      dequeueQuad(startX + half, startY, half);\n      dequeueQuad(startX, startY + half, half);\n      dequeueQuad(startX + half, startY + half, half);\n    }\n  }\n\n  var bitGrid = new BitGrid(json.bitWorldSize);\n  for (var cellId32 in json.cells) {\n    var cellId = parseInt(cellId32, 32);\n    var cellBytes = atob(json.cells[cellId32]);\n    var bitQueue = new BitQueue();\n    bitQueue.enqueueBytes(cellBytes);\n    var cell = bitGrid.createCellArray(0);\n    dequeueQuad(0, 0, 32);\n    bitGrid.cells[cellId] = cell;\n\n    // Mark this cell as dirty. Its old value was 0, the default full-empty value.\n    bitGrid.changedCells[cellId] = 0;\n  }\n  return bitGrid;\n};\n\n// Old naive serializer/deserializer.\n//BitGrid.prototype.toJSON = function() {\n//  return {\n//    bitWorldSize: this.bitWorldSize,\n//    cells: this.cells\n//  };\n//};\n//\n//BitGrid.fromJSON = function(json) {\n//  var bitGrid = new BitGrid(json.bitWorldSize);\n//  bitGrid.cells = json.cells;\n//  return bitGrid;\n//};\n\n\n\n\n/**\n * Gets a WebGL context from a canvas\n * @param canvas\n * @param paramObj\n * @return {WebGLRenderingContext}\n */\nfunction getWebGlContext(canvas, paramObj) {\n  if (paramObj) {\n    return canvas.getContext('experimental-webgl', paramObj) || canvas.getContext('webgl', paramObj);\n  } else {\n    return canvas.getContext('experimental-webgl') || canvas.getContext('webgl');\n  }\n}\n\n/**\n * Creates and compiles a shader.\n * @param {!WebGLRenderingContext} gl\n * @param {string} shaderSource The GLSL source code for the shader.\n * @param {number} shaderType The type of shader, gl.VERTEX_SHADER or\n *     gl.FRAGMENT_SHADER.\n * @return {!WebGLShader} The shader.\n */\nfunction compileShader(gl, shaderSource, shaderType) {\n  var shader = gl.createShader(shaderType);\n  gl.shaderSource(shader, shaderSource);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n  }\n  return shader;\n}\n\n/**\n * Creates a program from 2 shaders.\n * @param {!WebGLRenderingContext} gl\n * @param {!WebGLShader} vertexShader\n * @param {!WebGLShader} fragmentShader\n * @return {!WebGLProgram}\n */\nfunction createProgram(gl, vertexShader, fragmentShader) {\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    throw 'program filed to link:' + gl.getProgramInfoLog(program);\n  }\n  return program;\n}\n\n/**\n * @param {!WebGLRenderingContext} gl\n * @param values\n * @returns {WebGLBuffer}\n */\nfunction createStaticGlBuff(gl, values) {\n  var buff = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buff);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(values), gl.STATIC_DRAW);\n  return buff;\n}\n\n// Make WebStorm 8 happy\nif (!'WebGLRenderingContext' in window) {\n  throw 'WebGLRenderingContext undefined!';\n  (function(){\n    var f = function(){};\n    window.WebGLRenderingContext = {\n      LINK_STATUS: 1,\n      COMPILE_STATUS: 1,\n      VERTEX_SHADER: 1,\n      FRAGMENT_SHADER: 1,\n      DEPTH_TEST: 1,\n      SRC_ALPHA: 1,\n      BLEND: 1,\n      LESS: 1,\n      ONE: 1,\n      TRUE: 1,\n      FALSE: 1,\n      COLOR_BUFFER_BIT: 1,\n      DEPTH_BUFFER_BIT: 1,\n      FLOAT: 1,\n      UNSIGNED_SHORT: 1,\n      TRIANGLES: 1,\n      TRIANGLE_STRIP: 1,\n      TRIANGLE_FAN: 1,\n      STATIC_DRAW: 1,\n      DYNAMIC_DRAW: 1,\n      STREAM_DRAW: 1,\n      ARRAY_BUFFER: 1,\n      ELEMENT_ARRAY_BUFFER: 1,\n      WebGLBuffer: {}\n    };\n    window.WebGLShader = f;\n    window.WebGLProgram = f;\n  })();\n}\n\n\n\n/**\n * @constructor\n */\nfunction Vertex() {\n  this.position = new Vec4();\n  this.color = new Vec4();\n  this.group = 0;\n}\n\nVertex.prototype.setPositionXYZ = function(x, y, z) {\n  this.position.setXYZ(x, y, z);\n  return this;\n};\n\nVertex.prototype.setPositionArray = function(xyz) {\n  this.setPositionXYZ(xyz[0], xyz[1], xyz[2]);\n  return this;\n};\n\nVertex.prototype.setColorRGB = function(r, g, b) {\n  this.color.setXYZ(r, g, b);\n  return this;\n};\n\nVertex.prototype.setColorArray = function(rgb) {\n  this.setColorRGB(rgb[0], rgb[1], rgb[2]);\n  return this;\n};\n\nVertex.prototype.setGroup = function(g) {\n  this.group = g;\n  return this;\n};\n\n/**\n * @returns {Vertex} a deep copy of this vertex\n */\nVertex.prototype.copy = function() {\n  var copy = new Vertex();\n  copy.position.set(this.position);\n  copy.color.set(this.color);\n  copy.group = this.group;\n  return copy;\n};\n\n/**\n * @param {Matrix44} matrix\n * @return {Vertex} this\n */\nVertex.prototype.transformPosition = function(matrix) {\n  this.position.transform(matrix);\n  return this;\n};\n\n/**\n * @param {Matrix44} matrix\n * @return {Vertex} this\n */\nVertex.prototype.transformColor = function(matrix) {\n  this.color.transform(matrix);\n  return this;\n};\n\n\n\n/**\n * Holds the GL values needed to prepare GL to render a model.\n * Use a RigidModel to create a ModelStamp.\n * @param glType probably gl.TRIANGLES\n * @param posBuff GL vertex position buffer, with four floats per position\n * @param colorBuff GL vertex color buffer, with four floats per position\n * @param groupBuff vertex group number buffer, with one float per position\n * @param indexBuff pointer to the element index buffer\n * @param indexCount the total number of index values. Ten triangles would be thirty.\n * @constructor\n */\nfunction ModelStamp(glType, posBuff, colorBuff, groupBuff, indexBuff, indexCount) {\n  this.glType = glType;\n  this.posBuff = posBuff;\n  this.colorBuff = colorBuff;\n  this.groupBuff = groupBuff;\n  this.indexBuff = indexBuff;\n  this.indexCount = indexCount;\n}\n\n\nModelStamp.prototype.prepareToDraw = function(gl, aVertexPosition, aVertexColor, aVertexGroup) {\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuff);\n  gl.vertexAttribPointer(aVertexPosition, 4, gl.FLOAT, false, 0, 0);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuff);\n  gl.vertexAttribPointer(aVertexColor, 4, gl.FLOAT, false, 0, 0);\n\n  if (typeof aVertexGroup != 'undefined') {\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.groupBuff);\n    gl.vertexAttribPointer(aVertexGroup, 1, gl.FLOAT, false, 0, 0);\n  }\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuff);\n};\n\nModelStamp.prototype.draw = function(gl) {\n  gl.drawElements(this.glType, this.indexCount, gl.UNSIGNED_SHORT, 0);\n};\n\nModelStamp.prototype.dispose = function(gl) {\n  gl.deleteBuffer(this.posBuff);\n  gl.deleteBuffer(this.colorBuff);\n  gl.deleteBuffer(this.groupBuff);\n  gl.deleteBuffer(this.indexBuff);\n  this.glType = null;\n  this.posBuff = null;\n  this.colorBuff = null;\n  this.groupBuff = null;\n  this.indexBuff = null;\n  this.indexCount = null;\n};\n\n\n\n/**\n * A way to create, combine, and manipulate a 3D model in JS.\n * This is not optimized for repeated real-time use. It's meant to\n * be used during setup.\n * Generates static ModelStamp objects, which are meant to be used at runtime.\n * @constructor\n */\nfunction RigidModel() {\n  this.vertexes = [];\n  this.triangles = [];\n}\n\nRigidModel.prototype.clear = function() {\n  this.vertexes.length = 0;\n  this.triangles.length = 0;\n  return this;\n};\n\n/**\n * @param {Vertex} vertex\n * @return {number} the new vertex's index\n */\nRigidModel.prototype.addVertex = function(vertex) {\n  this.vertexes.push(vertex);\n  return this.vertexes.length - 1;\n};\n\n/**\n * Add the indexes of existing vertexes so the counter-clockwise face is showing.\n * @param {number} vertIndex0\n * @param {number} vertIndex1\n * @param {number} vertIndex2\n * @return {number} the new triangle's index\n */\nRigidModel.prototype.addTriangle = function(vertIndex0, vertIndex1, vertIndex2) {\n  this.triangles.push([vertIndex0, vertIndex1, vertIndex2]);\n  return this.triangles.length - 1;\n};\n\n/**\n * Adds a deep copy of a model \"that\" to this model.\n * @param {RigidModel} that\n * @return {RigidModel} this\n */\nRigidModel.prototype.addRigidModel = function(that) {\n  // Map that's vertex indexes to their new indexes in this.\n  var i, vertexMap = {};\n  for (i = 0; i < that.vertexes.length; i++) {\n    vertexMap[i] = this.addVertex(that.vertexes[i].copy());\n  }\n  for (i = 0; i < that.triangles.length; i++) {\n    var thatTri = that.triangles[i];\n    this.addTriangle(\n        vertexMap[thatTri[0]],\n        vertexMap[thatTri[1]],\n        vertexMap[thatTri[2]]);\n  }\n  return this;\n};\n\n/**\n * @return {Rect} the bounding rect, or null if there are no vertexes\n */\nRigidModel.prototype.getBoundingRect = function() {\n  if (!this.vertexes.length) {\n    return null;\n  }\n  var vert = this.vertexes[0];\n  var rect = new Rect(vert.position.v[0], vert.position.v[1], 0, 0);\n  for (var i = 1; i < this.vertexes.length; i++) {\n    vert = this.vertexes[i];\n    rect.coverXY(vert.position.v[0], vert.position.v[1]);\n  }\n  return rect;\n};\n\n/**\n * Mutates all the vertex positions in this model.\n * @param {Matrix44} matrix\n * @return {RigidModel} this\n */\nRigidModel.prototype.transformPositions = function(matrix) {\n  for (var i = 0; i < this.vertexes.length; i++) {\n    this.vertexes[i].transformPosition(matrix);\n  }\n  return this;\n};\n\n/**\n * Sets all the vertex colors in this model.\n * @return {RigidModel} this\n */\nRigidModel.prototype.setColorRGB = function(r, g, b) {\n  for (var i = 0; i < this.vertexes.length; i++) {\n    this.vertexes[i].setColorRGB(r, g, b);\n  }\n  return this;\n};\n\n/**\n * Mutates the vertexes by moving each towards or away from a centerpoint,\n * so they're all the same radius from it.\n * @param {Vec4} center\n * @param {number} radius\n * @return {RigidModel} this\n */\nRigidModel.prototype.sphereize = function(center, radius) {\n  for (var i = 0; i < this.vertexes.length; i++) {\n    var p = this.vertexes[i].position;\n    p.subtract(center).scaleToLength(radius).add(center);\n  }\n  return this;\n};\n\n/**\n * Creates a new RigidModel just like this one, but replaces all triangles with\n * four co-planer triangles covering the same area, creating a new vertex in the\n * middle of each edge. Color values for the new vertexes are the average of the\n * original two points along the edge.\n */\nRigidModel.prototype.createQuadrupleTriangleModel = function() {\n  var m = new RigidModel();\n  function childName(index0, index1) {\n    return (index0 < index1) ? index0 + \"_\" + index1 : index1 + \"_\" + index0;\n  }\n  // Each key is a name of a vertex - either the original parent vert index,\n  // or a name created by joining two parent IDs.\n  // Each value is a new model vertex index.\n  var namedVerts = {};\n  for (var ti = 0; ti < this.triangles.length; ti++) {\n    var oldTri = this.triangles[ti];\n    // copy original verts, as needed\n    for (var i = 0; i < 3; i++) {\n      var vi = oldTri[i];\n      // map old vertex index to new one\n      if (!(vi in namedVerts)) {\n        namedVerts[vi] = m.addVertex(this.vertexes[vi].copy());\n      }\n    }\n    // create children in the middle of edges, as needed\n    for (var i = 0; i < 3; i++) {\n      var parent0Index = oldTri[i];\n      var parent1Index = oldTri[(i + 1) % 3];\n      var name = childName(parent0Index, parent1Index);\n      if (!(name in namedVerts)) {\n        var parent0 = this.vertexes[parent0Index];\n        var parent1 = this.vertexes[parent1Index];\n        var newVert = parent0.copy();\n        newVert.position.add(parent1.position).scale1(0.5);\n        // I'm assuming alpha is always 1, so if that changes, change this to average alpha, too.\n        newVert.color.add(parent1.color).scale1(0.5);\n        namedVerts[name] = m.addVertex(newVert);\n      }\n    }\n    // manually add triangles using the new vertexes\n    var a = namedVerts[oldTri[0]];\n    var b = namedVerts[oldTri[1]];\n    var c = namedVerts[oldTri[2]];\n    var ab = namedVerts[childName(oldTri[0], oldTri[1])];\n    var bc = namedVerts[childName(oldTri[1], oldTri[2])];\n    var ac = namedVerts[childName(oldTri[0], oldTri[2])];\n    m.addTriangle(a, ab, ac);\n    m.addTriangle(ab, b, bc);\n    m.addTriangle(ac, bc, c);\n    m.addTriangle(ab, bc, ac);\n  }\n  return m;\n};\n\n/**\n * Adds immutable snapshot data to GL and returns a handle to it.\n * @param gl\n * @returns {ModelStamp}\n */\nRigidModel.prototype.createModelStamp = function(gl) {\n  var i, positionArray = [], colorArray = [], groupArray = [];\n  for (i = 0; i < this.vertexes.length; i++) {\n    var vertex = this.vertexes[i];\n    for (var d = 0; d < 4; d++) {\n      positionArray.push(vertex.position.v[d]);\n      colorArray.push(vertex.color.v[d]);\n    }\n    groupArray.push(vertex.group || 0);\n  }\n  var posBuff = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, posBuff);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionArray), gl.STATIC_DRAW);\n\n  var colorBuff = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuff);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorArray), gl.STATIC_DRAW);\n\n  var groupBuff = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, groupBuff);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(groupArray), gl.STATIC_DRAW);\n\n  var elementsArray = [];\n  for (i = 0; i < this.triangles.length; i++) {\n    var triangle = this.triangles[i];\n    for (var v = 0; v < 3; v++) {\n      elementsArray.push(triangle[v]);\n    }\n  }\n  var elementBuff = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuff);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(elementsArray), gl.STATIC_DRAW);\n\n  return new ModelStamp(gl.TRIANGLES,\n      posBuff,\n      colorBuff,\n      groupBuff,\n      elementBuff, elementsArray.length\n  );\n};\n\n/**\n * Creates a unit-square, with points at 1 and -1 along each dimension X and Y, with Z=0,\n * so edge-length is 2 and area is 4.\n * @returns {RigidModel}\n */\nRigidModel.createSquare = function() {\n  var m = new RigidModel();\n  var v = [];\n  for (var y = -1; y <= 1; y+= 2) {\n    for (var x = -1; x <= 1; x+= 2) {\n      v.push(m.addVertex(new Vertex().setPositionXYZ(x, y, 0).setColorRGB(1, 1, 1)));\n    }\n  }\n  function face(nw, ne, sw, se) {\n    m.addTriangle(v[nw], v[sw], v[ne]);\n    m.addTriangle(v[se], v[ne], v[sw]);\n  }\n  // 2   3\n  //\n  // 0   1\n  face(2, 3, 0, 1);\n  return m;\n};\n\n/**\n * Creates an equalateral triangle, with one point on the positive Y axis and two with negative Y and varying X,\n * sized so it covers a unit circle. The highest Y is 2 and the lowest is -1.\n * @returns {RigidModel}\n */\nRigidModel.createTriangle = function() {\n  var m = new RigidModel();\n  var top = new Vertex().setPositionXYZ(0, 2, 0).setColorRGB(1, 1, 1);\n  var right = top.copy().transformPosition(new Matrix44().toRotateZOp(2*Math.PI/3));\n  var left = top.copy().transformPosition(new Matrix44().toRotateZOp(-2*Math.PI/3));\n  var topIndex = m.addVertex(top);\n  var leftIndex = m.addVertex(left);\n  var rightIndex = m.addVertex(right);\n  m.addTriangle(topIndex, leftIndex, rightIndex);\n  return m;\n};\n\n/**\n * Creates a unit-circle model made of a mesh of mostly equilateral triangles, except for those with vertexes which\n * have been pulled towards the center to prevent them from protruding outside the circle.\n * @param depth The number of createQuadrupleTriangleModel() calls to make on the starting triangle, resulting\n * in something like depth^4 triangles.\n * @returns {RigidModel}\n */\n\nRigidModel.createCircleMesh = function(depth) {\n  var model = RigidModel.createTriangle();\n  for (var i = 0; i < depth; i++) {\n    model = model.createQuadrupleTriangleModel();\n  }\n  // Remove triangles outside circle.\n  var outsiders = [];\n  var circleRadius = 1;\n  for (var t = 0; t < model.triangles.length;) {\n    var tri = model.triangles[t];\n    outsiders.length = 0;\n    for (var v = 0; v < 3; v++) {\n      var vert = model.vertexes[tri[v]];\n      if (vert.position.magnitude() > circleRadius) {\n        outsiders.push(vert);\n      }\n    }\n    if (outsiders.length == 3) {\n      // All verts are outside the circle. Remove the triangle.\n      model.triangles[t] = model.triangles[model.triangles.length - 1];\n      model.triangles.pop();\n    } else {\n      // Reposition outside verts to be on the circle's edge.\n      for (var o = 0; o < outsiders.length; o++) {\n        outsiders[o].position.scaleToLength(circleRadius);\n      }\n      t++;\n    }\n  }\n  return model;\n};\n\nRigidModel.createRingMesh = function(depth, innerRadius) {\n  var model = RigidModel.createCircleMesh(depth);\n\n  // Remove triangles inside inner circle.\n  var insiders = [];\n  for (var t = 0; t < model.triangles.length;) {\n    var tri = model.triangles[t];\n    insiders.length = 0;\n    for (var v = 0; v < 3; v++) {\n      var vert = model.vertexes[tri[v]];\n      if (vert.position.magnitude() <= innerRadius) {\n        insiders.push(vert);\n      }\n    }\n    if (insiders.length == 3) {\n      // All verts are inside ring. Remove the triangle.\n      model.triangles[t] = model.triangles[model.triangles.length - 1];\n      model.triangles.pop();\n    } else {\n      // Reposition inside verts to be on the circle's edge.\n      for (var i = 0; i < insiders.length; i++) {\n        insiders[i].position.scaleToLength(innerRadius);\n      }\n      t++;\n    }\n  }\n  return model;\n};\n\n/**\n * Creates a model for a white unit circle on the XY plane, where there are two vertexes at each position,\n * one in group 0 and one in group 1. Group 0 and Group 1 are opposite ends of this dimensionless tube.\n * @param corners\n * @returns {RigidModel}\n */\nRigidModel.createDoubleRing = function(corners) {\n  var m = new RigidModel(), v = [], i;\n  for (i = 0; i < corners; i++) {\n    var a = 2 * Math.PI * i / corners;\n    v.push(m.addVertex(new Vertex().setPositionXYZ(Math.sin(a), Math.cos(a), 0).setColorRGB(1, 1, 1).setGroup(0)));\n    v.push(m.addVertex(new Vertex().setPositionXYZ(Math.sin(a), Math.cos(a), 0).setColorRGB(1, 1, 1).setGroup(1)));\n  }\n  function face(nw, ne, sw, se) {\n    m.addTriangle(v[nw], v[sw], v[ne]);\n    m.addTriangle(v[se], v[ne], v[sw]);\n  }\n  for (i = 0; i < v.length; i += 2) {\n    // 0 2\n    // 1 3\n    face(i, (i + 2) % v.length, i + 1, (i + 3) % v.length);\n  }\n\n  return m;\n};\n\n/**\n * Creates a unit-cube, with points at 1 and -1 along each dimension,\n * so edge-length is 2 and volume is 8.\n * @returns {RigidModel}\n */\nRigidModel.createCube = function() {\n  var m = new RigidModel();\n  var v = [];\n  for (var z = -1; z <= 1; z+= 2) {\n    for (var y = -1; y <= 1; y+= 2) {\n      for (var x = -1; x <= 1; x+= 2) {\n        v.push(m.addVertex(new Vertex().setPositionXYZ(x, y, z).setColorRGB(1, 1, 1)));\n      }\n    }\n  }\n  function face(nw, ne, sw, se) {\n    m.addTriangle(v[nw], v[sw], v[ne]);\n    m.addTriangle(v[se], v[ne], v[sw]);\n  }\n  // 2   3\n  //  6   7\n  //\n  // 0   1\n  //  4   5\n  face(4, 5, 0, 1); // bottom\n  face(2, 3, 6, 7); // top\n  face(6, 7, 4, 5); // front\n  face(3, 2, 1, 0); // back\n  face(2, 6, 0, 4); // left\n  face(7, 3, 5, 1); // right\n  return m;\n};\n\n/**\n * Creates a four-faced triangular pyramid, with one edge parallel to the Y axis,\n * and one edge parallel to the X axis. Edges have a length of 2.\n * @returns {RigidModel}\n */\nRigidModel.createTetrahedron = function() {\n  var m = new RigidModel();\n  var dz = Math.sqrt(2) / 2;\n  var a = m.addVertex(new Vertex().setPositionXYZ(0, 1, -dz).setColorRGB(1, 1, 1));\n  var b = m.addVertex(new Vertex().setPositionXYZ(0, -1, -dz).setColorRGB(1, 1, 1));\n  var c = m.addVertex(new Vertex().setPositionXYZ(1, 0, dz).setColorRGB(1, 1, 1));\n  var d = m.addVertex(new Vertex().setPositionXYZ(-1, 0, dz).setColorRGB(1, 1, 1));\n  m.addTriangle(a, d, c);\n  m.addTriangle(a, b, d);\n  m.addTriangle(a, c, b);\n  m.addTriangle(b, c, d);\n  return m;\n};\n\n/**\n * Creates an eight-faced shape with a vertex at 1 and -1 on every axis.\n * @returns {RigidModel}\n */\nRigidModel.createOctahedron = function() {\n  var m = new RigidModel();\n  function v(x, y, z) {\n    return m.addVertex(new Vertex().setPositionXYZ(x, y, z).setColorRGB(1, 1, 1));\n  }\n  var a = v(1, 0, 0);\n  var b = v(-1, 0, 0);\n  var c = v(0, 1, 0);\n  var d = v(0, -1, 0);\n  var e = v(0, 0, 1);\n  var f = v(0, 0, -1);\n  m.addTriangle(c, e, a);\n  m.addTriangle(c, a, f);\n  m.addTriangle(c, f, b);\n  m.addTriangle(c, b, e);\n  m.addTriangle(d, e, b);\n  m.addTriangle(d, a, e);\n  m.addTriangle(d, f, a);\n  m.addTriangle(d, b, f);\n  return m;\n};\n\n\n\n/**\n * The renderer has the viewport state,\n * manages uniforms and attributes,\n * and can draw a ModelStamp.\n * @param canvas\n * @param gl\n * @param program\n * @constructor\n */\nfunction Renderer(canvas, gl, program) {\n  this.canvas = canvas;\n  this.gl = gl;\n  this.program = program;\n  this.initAttributesAndUniforms();\n}\n\nRenderer.prototype.initAttributesAndUniforms = function() {\n  this.createVertexAttribute('aVertexPosition');\n  this.createVertexAttribute('aVertexColor');\n  this.createVertexAttribute('aVertexGroup');\n  this.createUniform('uViewMatrix');\n  this.createUniform('uModelMatrix');\n  this.createUniform('uModelMatrix2');\n  this.createUniform('uModelColor');\n};\n\nRenderer.prototype.createVertexAttribute = function(name) {\n  this[name] = this.gl.getAttribLocation(this.program, name);\n  this.gl.enableVertexAttribArray(this[name]);\n};\n\nRenderer.prototype.createUniform = function(name) {\n  this[name] = this.gl.getUniformLocation(this.program, name);\n};\n\n/**\n * @return {Renderer}\n */\nRenderer.prototype.resize = function() {\n  if (this.canvas.width != this.canvas.clientWidth ||\n      this.canvas.height != this.canvas.clientHeight) {\n    this.canvas.width = this.canvas.clientWidth;\n    this.canvas.height = this.canvas.clientHeight;\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n  }\n  return this;\n};\n\n/**\n * @return {Renderer}\n */\nRenderer.prototype.clear = function() {\n  this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n  return this;\n};\n\n/**\n * @return {Renderer}\n */\nRenderer.prototype.setBlendingEnabled = function(blend) {\n  if (blend) {\n    this.gl.enable(this.gl.BLEND);\n    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE)\n  } else {\n    this.gl.disable(this.gl.BLEND);\n  }\n  return this;\n};\n\n/**\n * @return {Renderer}\n */\nRenderer.prototype.clearColor = function(r, g, b, a) {\n  this.gl.clearColor(r, g, b, a);\n  return this;\n};\n\n/**\n * @param {Matrix44} viewMatrix\n * @return {Renderer}\n */\nRenderer.prototype.setViewMatrix = function(viewMatrix) {\n  this.viewMatrix = viewMatrix;\n  this.gl.uniformMatrix4fv(this.uViewMatrix, this.gl.FALSE, viewMatrix.m);\n  return this;\n};\n\n/**\n * @return {Matrix44} A reference to the inner viewMatrix, which may change.\n */\nRenderer.prototype.getViewMatrix = function() {\n  return this.viewMatrix;\n};\n\n/**\n * Sets the shader's model matrix uniform.\n * @param {Matrix44} modelMatrix\n * @return {Renderer}\n */\nRenderer.prototype.setModelMatrix = function(modelMatrix) {\n  this.gl.uniformMatrix4fv(this.uModelMatrix, this.gl.FALSE, modelMatrix.m);\n  return this;\n};\n\n/**\n * Sets the shader's second model matrix uniform.\n * @param {Matrix44} modelMatrix2\n * @return {Renderer}\n */\nRenderer.prototype.setModelMatrix2 = function(modelMatrix2) {\n  this.gl.uniformMatrix4fv(this.uModelMatrix2, this.gl.FALSE, modelMatrix2.m);\n  return this;\n};\n\n/**\n * Sets the shader's color vector uniform.\n * @param {Vec4} colorVector\n * @return {Renderer}\n */\nRenderer.prototype.setColorVector = function(colorVector) {\n  this.gl.uniform4fv(this.uModelColor, colorVector.v);\n  return this;\n};\n\n/**\n * Prepares for stamp() calls.\n * @param {ModelStamp} stamp\n * @return {Renderer}\n */\nRenderer.prototype.setStamp = function(stamp) {\n  this.modelStamp = stamp;\n  stamp.prepareToDraw(this.gl, this.aVertexPosition, this.aVertexColor, this.aVertexGroup);\n  return this;\n};\n\n/**\n * Draws the ModelStamp set by setStamp(), with the current\n * modelMatrix, colorVector, and view uniforms.\n * @return {Renderer}\n */\nRenderer.prototype.drawStamp = function() {\n  this.modelStamp.draw(this.gl);\n  return this;\n};\n\n\n\n/**\n * Asynchronously creates a Renderer by loading and compiling shaders.\n * @param canvas\n * @param {String} vertexShaderPath\n * @param {String} fragmentShaderPath\n * @constructor\n */\nfunction RendererLoader(canvas, vertexShaderPath, fragmentShaderPath) {\n  this.canvas = canvas;\n  this.textLoader = new TextLoader([vertexShaderPath, fragmentShaderPath]);\n  this.renderer = null;\n}\n\n/**\n * @param callback called with the renderer as a parameter, when the renderer is loaded\n */\nRendererLoader.prototype.load = function(callback) {\n  this.callback = callback;\n  var self = this;\n  this.textLoader.load(function() {\n    self.invalidate();\n  });\n};\n\nRendererLoader.prototype.invalidate = function() {\n  var vsText = this.textLoader.getTextByIndex(0);\n  var fsText = this.textLoader.getTextByIndex(1);\n  if (!this.renderer && vsText && fsText) {\n    var gl = getWebGlContext(this.canvas, {\n      alpha: false,\n      antialias: true\n    });\n    var vs = compileShader(gl, vsText, gl.VERTEX_SHADER);\n    var fs = compileShader(gl, fsText, gl.FRAGMENT_SHADER);\n    var program = createProgram(gl, vs, fs);\n    gl.enable(gl.DEPTH_TEST);\n    gl.useProgram(program);\n    this.renderer = new Renderer(this.canvas, gl, program);\n    this.callback(this.renderer);\n  }\n};\n\n\n\n/**\n * Helps build glyph (printable character) RigidModel objects.\n * @param lineWidth\n * @param glyphDepth\n * @constructor\n */\nfunction GlyphMaker(lineWidth, glyphDepth) {\n  this.lineWidth = lineWidth;\n  this.glyphDepth = glyphDepth;\n\n  this.rigidModel = new RigidModel();\n  this.mat = new Matrix44();\n  this.vec = new Vec4();\n}\n\nGlyphMaker.prototype.clear = function() {\n  this.rigidModel.clear();\n};\n\nGlyphMaker.prototype.addStick = function(x0, y0, x1, y1) {\n  var len = Vec2d.distance(x0, y0, x1, y1) + this.lineWidth;\n  var fat = this.lineWidth/2;\n  var cuboid = RigidModel.createCube();\n\n  // scale to the final size\n  cuboid.transformPositions(this.mat.toScaleOp(this.vec.setXYZ(len/2, fat, this.glyphDepth/2)));\n\n  // translate so x0, y0 is at the origin\n  cuboid.transformPositions(this.mat.toTranslateOp(this.vec.setXYZ(len/2 - fat, 0, 0)));\n\n  // rotate to final angle\n  cuboid.transformPositions(this.mat.toRotateZOp(Math.atan2(y1 - y0, x1 - x0)));\n\n  // move to final position\n  cuboid.transformPositions(this.mat.toTranslateOp(this.vec.setXYZ(x0, y0, 0)));\n\n  this.rigidModel.addRigidModel(cuboid);\n};\n\nGlyphMaker.prototype.addToRigidModel = function(target) {\n  target.addRigidModel(this.rigidModel);\n  return target;\n};\n\n\n\n/**\n * A collection of printable characters, as ModelStamp objects in the \"stamps\" map.\n * @param glyphMaker\n * @constructor\n */\nfunction Glyphs(glyphMaker) {\n  this.glyphMaker = glyphMaker;\n  this.models = null;\n  this.stamps = null;\n}\n\nGlyphs.prototype.initModels = function() {\n  this.models = {};\n  var r = this.glyphMaker.lineWidth / 2;\n  var h = 1.5;\n  var w = 1;\n  var self = this;\n  function g() {\n    self.glyphMaker.clear();\n    for (var i = 1; i < arguments.length; i+=4) {\n      self.glyphMaker.addStick(arguments[i], arguments[i + 1], arguments[i + 2], arguments[i + 3]);\n    }\n    self.models[arguments[0]] = self.glyphMaker.addToRigidModel(new RigidModel());\n  }\n  g('A',\n      -w, -h,  -r/5, h,\n      w, -h,  r/5, h,\n      -w/2, -h * 0.33, w/2, -h * 0.33);\n  g('B',\n      -w, h, -w, -h,\n      -w, h, w * 0.33, h,\n      w * 0.33, h, w * 0.33, 0,\n      -w, 0, w, 0,\n      w, 0, w, -h,\n      w, -h, -w, -h);\n  g('C',\n      -w + r, h, w/2, h,\n      -w, h - r, -w, -h + r,\n      -w + r, -h, w - r, -h);\n  g('D',\n      -w, h - r, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, 0,\n      w - r/2, r, -w, h);\n  g('E',\n      w * 0.5, h, -w, h,\n      -w, h, -w, -h,\n      -w, -h, w, -h,\n      -w, 0, w * 0.5, 0);\n  g('F',\n      w, h, -w, h,\n      -w, h, -w, -h,\n      -w, 0, w * 0.33, 0);\n  g('G',\n      w * 0.5, h, -w, h,\n      -w, h, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, 0,\n      w * 0.2, 0, w * 1.2, 0);\n  g('H',\n      -w, h, -w, -h,\n      w, h, w, -h,\n      w, 0, -w, 0);\n  g('I',\n      0, h, 0, -h,\n      -w, h, w, h,\n      -w, -h, w, -h);\n  g('J',\n      -w, -h * 0.33, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, h);\n  g('K',\n      -w, h, -w, -h,\n      -w * (1 - r), -h * 0.2, w * 0.6, h * 0.6,\n      -w * 0.2, 0, w, -h);\n  g('L',\n      -w, h, -w, -h,\n      -w, -h, w, -h);\n  g('M',\n      -w, -h, -w, h,\n      -w + r*0.6, h - r/2, -r*0.2, h * 0.33,\n      -r*0.2, h * 0.33, w - r*0.6, h - r/2,\n      w, h, w, -h);\n  g('N',\n      -w, -h, -w, h,\n      -w + r/2, h - r/2, w - r/2, -h + r/2,\n      w, -h, w, h);\n  g('O',\n      -w, h - r, -w, -h + r,\n      -w + r, h, w - r, h,\n      w, h - r, w, -h + r,\n      -w + r, -h, w - r, -h);\n  g('P',\n      -w, h, -w, -h,\n      -w, h, w, h,\n      w, h, w, 0,\n      w, 0, -w, 0);\n  g('Q',\n      -w, h - r, -w, -h + r,\n      -w + r, h, w - r, h,\n      w, h - r, w, -h + r,\n      -w + r, -h, w - r, -h,\n      w * 0.4, -h * 0.4, w * 1.4, -h);\n  g('R',\n      -w, h, -w, -h,\n      -w, h, w, h,\n      w, h, w, 0,\n      w, 0, -w, 0,\n      0, -r, w, -h);\n  g('S',\n      w, h, -w/2 + r, h,\n      -w/2, h - r/2, -w, h/2,\n      -w, h/2, w, -h/2,\n      w, -h/2, w/2, -h + r/2,\n      w/2 - r, -h, -w, -h);\n  g('T',\n      w, h, -w, h,\n      0, h, 0, -h);\n  g('U',\n      -w, h, -w, -h + r,\n      w, h, w, -h + r,\n      -w + r, -h, w - r, -h);\n  g('V',\n      -w, h,  -r/5, -h,\n      w, h,  r/5, -h);\n  g('W',\n      -w, h, -w, -h,\n      -w + r*0.6, -h + r/3, -r*0.2, -h * 0.5,\n      -r*0.2, -h * 0.5, w - r*0.6, -h + r/3,\n      w, -h, w, h);\n  g('X',\n      -w, h, w, -h,\n      w, h, -w, -h);\n  g('Y',\n      -w, h, -r/2, 0,\n      w, h, r/2, 0,\n      0, 0, 0, -h);\n  g('Z',\n      -w, h, w, h,\n      w, h - r/2, -w, -h + r/2,\n      -w, -h, w, -h);\n\n  g('0',\n      -w, h, -w, -h,\n      -w, h, w, h,\n      w, h, w, -h,\n      -w, -h, w, -h,\n      w - r, h - r, -w + r, -h + r);\n  g('1',\n      -w, h, 0 - r, h,\n      0, h, 0, -h,\n      -w, -h, w, -h);\n  g('2',\n      -w * 2/3, h, w, h,\n      w, h, w, 0,\n      w, 0, -w, 0,\n      -w, 0, -w, -h,\n      -w, -h, w, -h);\n  g('3',\n      -w, h, w, h,\n      w, h, w, -h,\n      -w, -h, w, -h,\n          -w/2, 0, w, 0);\n  g('4',\n      -w, h * 2/3, -w, 0,\n      -w, 0, w, 0,\n      w, h, w, -h);\n  g('5',\n      -w, h, w, h,\n      -w, h, -w, 0,\n      w, 0, -w, 0,\n      w, 0, w, -h,\n      -w, -h, w, -h);\n  g('6',\n      w * 2/3, h, -w, h,\n      -w, h, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, 0,\n      w, 0, -w, 0);\n  g('7',\n      -w, h, w, h,\n      w, h - r, 0, -h);\n  g('8',\n      w, h, -w, h,\n      -w, h, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, h,\n      w, 0, -w, 0);\n  g('9',\n      w, 0, -w, 0,\n      -w, 0, -w, h,\n      -w, h, w, h,\n      w, h, w, -h);\n\n  g(' ');\n  g('.',\n      0, -h, 0, -h);\n  g(',',\n      0, -h, -w/3, -h * 4/3);\n  g('\\'',\n      0, h, 0, h * 4/3);\n  g('\"',\n      r*2, h, r*2, h * 4/3,\n      -r*2, h, -r*2, h * 4/3);\n  g('?',\n      0, -h, 0, -h,\n      0, -h/3, 0, 0,\n      0, 0, w, 0,\n      w, 0, w, h,\n      w, h, -w, h,\n      -w, h, -w, h * 2/3);\n  g('!',\n      0, -h, 0, -h,\n      0, -h/3, 0, h);\n  g(':',\n      0, -h, 0, -h,\n      0, h/3, 0, h/3);\n  g(';',\n      0, -h, -w/3, -h * 4/3,\n      0, h/3, 0, h/3);\n  g('-',\n      -w, 0, w, 0);\n  g('+',\n      -w, 0, w, 0,\n      0, -w, 0, w);\n};\n\nGlyphs.prototype.initStamps = function(gl) {\n  if (this.stamps) return;\n\n  if (!this.models) {\n    this.initModels();\n  }\n  this.stamps = {};\n  for (var key in this.models) {\n    this.stamps[key] = this.models[key].createModelStamp(gl);\n  }\n  return this.stamps;\n};\n\n\n\n/**\n * @constructor\n */\nfunction LabelMaker(glyphs) {\n  this.glyphs = glyphs;\n}\n\nLabelMaker.prototype.createLabelModel = function(startMatrix, nextCharMatrix, text) {\n  this.glyphs.initModels();\n  var labelModel = new RigidModel();\n  var mutableGlyph = new RigidModel();\n  var matrix = new Matrix44();\n  matrix.set(startMatrix);\n  for (var i = 0; i < text.length; i++) {\n    var originalGlyph = this.glyphs.models[text.charAt(i)];\n    if (originalGlyph) {\n      mutableGlyph.clear().addRigidModel(originalGlyph);\n      mutableGlyph.transformPositions(matrix);\n      labelModel.addRigidModel(mutableGlyph);\n    }\n    matrix.multiply(nextCharMatrix);\n  }\n  return labelModel;\n};\n\n\n\n/**\n * Adds clickable buttons to the world and the GL.\n * @param labelMaker\n * @param world\n * @param multiPointer\n * @param renderer\n * @constructor\n */\nfunction ButtonMaker(labelMaker, world, multiPointer, renderer) {\n  this.labelMaker = labelMaker;\n  this.world = world;\n  this.multiPointer = multiPointer;\n  this.renderer = renderer;\n\n  this.startMatrix = new Matrix44();\n  this.nextCharMatrix = new Matrix44().toTranslateOpXYZ(3, 0, 0);\n  this.letterColor = [1, 1, 1];\n  this.blockColor = [0.5, 0.5, 0.5];\n  this.padding = new Vec2d(0.5, 0.5);\n\n  this.scale = 1;\n}\n\n/**\n * @param {Matrix44} m\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setStartMatrix = function(m) {\n  this.startMatrix = m;\n  return this;\n};\n\n/**\n * @param {Matrix44} m\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setNextCharMatrix = function(m) {\n  this.nextCharMatrix = m;\n  return this;\n};\n\n/**\n * @param {Array.<number>} c\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setLetterColor = function(c) {\n  this.letterColor = c;\n  return this;\n};\n\n/**\n * @param {Array.<number>} c\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setBlockColor = function(c) {\n  this.blockColor = c;\n  return this;\n};\n\n/**\n * @param {number} x\n * @param {number} y\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setPaddingXY = function(x, y) {\n  this.padding.setXY(x, y);\n  return this;\n};\n\n/**\n * @param {number} s\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setScale = function(s) {\n  this.scale = s;\n  return this;\n};\n\n/**\n * Adds a button body and spirit to the world, and a button model to GL.\n * @param {number} x\n * @param {number} y\n * @param {string} text\n * @param {function} func or null for no callback\n * @return {number} The ID of the spirit added to the world.\n */\nButtonMaker.prototype.addButton = function(x, y, text, func) {\n  var labelModel = this.labelMaker.createLabelModel(this.startMatrix, this.nextCharMatrix, text);\n  labelModel.transformPositions(new Matrix44().toScaleOpXYZ(this.scale, this.scale, this.scale));\n  var brect = labelModel.getBoundingRect();\n  if (this.padding) {\n    brect.padXY(this.padding.x, this.padding.y);\n  }\n  labelModel.transformPositions(new Matrix44().toTranslateOpXYZ(-brect.pos.x, -brect.pos.y, 0));\n  for (var i = 0; i < labelModel.vertexes.length; i++) {\n    labelModel.vertexes[i].setColorArray(this.letterColor);\n  }\n\n  if (this.blockColor) {\n    var cuboid = RigidModel.createCube();\n    cuboid.transformPositions(new Matrix44().toScaleOpXYZ(brect.rad.x, brect.rad.y, 1));\n    cuboid.transformPositions(new Matrix44().toTranslateOpXYZ(0, 0, 1));\n    for (var i = 0; i < cuboid.vertexes.length; i++) {\n      cuboid.vertexes[i].setColorArray(this.blockColor);\n    }\n    labelModel.addRigidModel(cuboid);\n    labelModel.transformPositions(new Matrix44().toTranslateOpXYZ(0, 0, -1));\n  }\n  var stamp = labelModel.createModelStamp(this.renderer.gl);\n\n  var b = Body.alloc();\n  b.shape = Body.Shape.RECT;\n  var pos = new Vec2d(x, y);\n  b.setPosAtTime(pos, this.world.now);\n  b.rectRad.set(brect.rad);\n  b.group = 0;\n  b.mass = Infinity;\n  b.pathDurationMax = Infinity;\n  var spirit = new ButtonSpirit();\n  spirit.bodyId = this.world.addBody(b);\n  if (this.multiPointer) {\n    // TODO: remove multipointer from buttons completely?\n    spirit.setMultiPointer(this.multiPointer);\n  }\n  spirit.setModelStamp(stamp);\n  spirit.setOnClick(func);\n  return this.world.addSpirit(spirit);\n};\n\n\n\n/**\n * Abstract base class for an object that can listen for events, and draw to the canvas.\n * The details of canvas and renderer initilization and setting are up to the subclasses.\n * @constructor\n */\nfunction Screen() {\n}\n\n/**\n * @param {boolean} listening Whether to listen for events or not.\n */\nScreen.prototype.setScreenListening = function(listening) {\n};\n\n/**\n * Do physics and drawing, optionally lazily initializing first.\n * @param {number} visibility from 0 to 1\n */\nScreen.prototype.drawScreen = function(visibility) {\n};\n\n/**\n * Unload resources that cannot garbage-collect themselves, like WebGL data.\n */\nScreen.prototype.destroyScreen = function() {\n};\n\n\n\nfunction Camera(minDistFraction, maxDistFraction, viewDist) {\n  this.cameraPos = new Vec2d();\n  this.minDistFraction = minDistFraction;\n  this.maxDistFraction = maxDistFraction;\n  this.viewDist = viewDist;\n}\n\nCamera.prototype.follow = function(followPos) {\n  var cameraDist = followPos.distance(this.cameraPos);\n  var minCameraDist = this.viewDist * this.minDistFraction;\n  var maxCameraDist = this.viewDist * this.maxDistFraction;\n\n  // Move towards min dist\n  if (cameraDist > minCameraDist) {\n    var temp = Vec2d.alloc();\n    temp.set(followPos)\n        .subtract(this.cameraPos)\n        .scaleToLength((cameraDist-minCameraDist) * 0.1)\n        .add(this.cameraPos);\n    this.cameraPos.set(temp);\n    cameraDist = followPos.distance(this.cameraPos);\n\n    // Clip to max dist\n    if (cameraDist > maxCameraDist) {\n      temp.set(followPos)\n          .subtract(this.cameraPos)\n          .scaleToLength(cameraDist - maxCameraDist)\n          .add(this.cameraPos);\n      this.cameraPos.set(temp);\n    }\n    temp.free();\n  }\n};\n\nCamera.prototype.add = function(vec) {\n  this.cameraPos.add(vec);\n};\n\nCamera.prototype.setXY = function(x, y) {\n  this.cameraPos.setXY(x, y);\n};\n\nCamera.prototype.getX = function() {\n  return this.cameraPos.x;\n};\n\nCamera.prototype.getY = function() {\n  return this.cameraPos.y;\n};\n\nCamera.prototype.getViewDist = function() {\n  return this.viewDist;\n};\n\nCamera.prototype.setViewDist = function(d) {\n  this.viewDist = d;\n  return this;\n};\n\n\n\n\n/**\n * @constructor\n */\nfunction Splash(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration) {\n  this.type = 0;\n  this.stamp = null;\n  this.startPose = new Pose();\n  this.endPose = new Pose();\n  this.startPose2 = new Pose();\n  this.endPose2 = new Pose();\n  this.startColor = new Vec4();\n  this.endColor = new Vec4();\n  this.startTime = 0;\n  this.duration = 0;\n  this.reset(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration);\n}\n\nSplash.prototype.reset = function(\n    type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration) {\n  this.type = type || -1;\n  this.stamp = stamp || null;\n  startPose ? this.startPose.set(startPose) : this.startPose.reset();\n  endPose ? this.endPose.set(endPose) : this.endPose.reset();\n  startPose2 ? this.startPose2.set(startPose2) : this.startPose2.reset();\n  endPose2 ? this.endPose2.set(endPose2) : this.endPose2.reset();\n  startColor ? this.startColor.set(startColor) : this.startColor.reset();\n  endColor ? this.endColor.set(endColor) : this.endColor.reset();\n  this.startTime = startTime || 0;\n  this.duration = duration || 0;\n  return this;\n};\n\nSplash.pool = [];\n\nSplash.alloc = function(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration) {\n  if (Splash.pool.length) {\n    return Splash.pool.pop().reset(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration);\n  }\n  return new Splash(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration);\n};\n\nSplash.prototype.free = function() {\n  Splash.pool.push(this);\n};\n\nSplash.SCHEMA = {\n  0: \"type\",\n  1: \"startPose\",\n  2: \"endPose\",\n  3: \"startPose2\",\n  4: \"endPose2\",\n  5: \"startColor\",\n  6: \"endColor\",\n  7: \"startTime\",\n  8: \"duration\"\n};\n\nSplash.getJsoner = function() {\n  if (!Splash.jsoner) {\n    Splash.jsoner = new Jsoner(Splash.SCHEMA);\n  }\n  return Splash.jsoner;\n};\n\nSplash.prototype.toJSON = function() {\n  return Splash.getJsoner().toJSON(this);\n};\n\nSplash.prototype.setFromJSON = function(json) {\n  Splash.getJsoner().setFromJSON(json, this);\n};\n\nSplash.prototype.set = function(that) {\n  this.type = that.type;\n  this.stamp = that.stamp;\n  this.startPose.set(that.startPose);\n  this.endPose.set(that.endPose);\n  this.startPose2.set(that.startPose2);\n  this.endPose2.set(that.endPose2);\n  this.startColor.set(that.startColor);\n  this.endColor.set(that.endColor);\n  this.startTime = that.startTime;\n  this.duration = that.duration;\n  return this;\n};\n\nSplash.prototype.isVisible = function(time) {\n  return this.startTime <= time && time <= this.startTime + this.duration;\n};\n\nSplash.prototype.isExpired = function(time) {\n  return this.startTime + this.duration < time;\n};\n\nSplash.tempPose = new Pose();\n\nSplash.prototype.getModelMatrix = function(time, out) {\n  Splash.tempPose.setToInterpolation(this.startPose, this.endPose, (time - this.startTime) / this.duration);\n  return out.setToPose(Splash.tempPose);\n};\n\nSplash.prototype.getModelMatrix2 = function(time, out) {\n  Splash.tempPose.setToInterpolation(this.startPose2, this.endPose2, (time - this.startTime) / this.duration);\n  return out.setToPose(Splash.tempPose);\n};\n\nSplash.prototype.getColor = function(time, out) {\n  return out.setToInterpolation(this.startColor, this.endColor, (time - this.startTime) / this.duration);\n};\n\n\n\n/**\n * @constructor\n */\nfunction Splasher() {\n  this.splashes = [];\n  this.matrix44 = new Matrix44();\n  this.vec4 = new Vec4();\n}\n\nSplasher.prototype.addCopy = function(copyMe) {\n  this.splashes.push(Splash.alloc().set(copyMe));\n};\n\nSplasher.prototype.draw = function(renderer, now) {\n  for (var i = 0; i < this.splashes.length;) {\n    var splash = this.splashes[i];\n    if (splash.isExpired(now)) {\n      // remove\n      splash.free();\n      this.splashes[i] = this.splashes[this.splashes.length - 1];\n      this.splashes.pop();\n    } else {\n      if (splash.isVisible(now)) {\n        renderer\n            .setStamp(splash.stamp)\n            .setColorVector(splash.getColor(now, this.vec4))\n            .setModelMatrix(splash.getModelMatrix(now, this.matrix44))\n            .setModelMatrix2(splash.getModelMatrix2(now, this.matrix44))\n            .drawStamp();\n      }\n      i++;\n    }\n  }\n};\n\n\n\n\n/**\n * A world grid cell, holding pathIds by hitGroup.\n * It is a compact array of groups, indexed by hitGroup number.\n * Each group is a set of pathIds.\n * @constructor\n */\nfunction Cell(groupCount) {\n  this.groups = [];\n  this.reset(groupCount);\n}\n\nCell.prototype.reset = function(groupCount) {\n  for (var i = 0; i < groupCount; i++) {\n    if (!this.groups[i]) {\n      this.groups[i] = ArraySet.alloc();\n    } else {\n      this.groups[i].reset();\n    }\n  }\n  while (this.groups.length > groupCount) {\n    this.groups.pop().free();\n  }\n};\n\nPoolify(Cell);\n\nCell.prototype.addPathIdToGroup = function(pathId, groupId) {\n  this.groups[groupId].put(pathId);\n};\n\nCell.prototype.removePathIdFromGroup = function(pathId, groupId) {\n  this.groups[groupId].remove(pathId);\n};\n\n/**\n * Returns the internal ArraySet.\n * @param groupId\n * @returns {ArraySet}\n */\nCell.prototype.getPathIdsForGroup = function(groupId) {\n  return this.groups[groupId];\n};\n\nCell.prototype.isEmpty = function() {\n  for (var i = 0; i < this.groups.length; i++) {\n    if (!this.groups[i].isEmpty()) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n\n/**\n * This has all the information about a physical body that the collision detector needs,\n * and enough of an API for a Spirit to manipulate a body.\n *\n * @constructor\n */\nfunction Body() {\n  this.pathStartPos = new Vec2d();\n  this.vel = new Vec2d();\n\n  // The pathStartTime is guaranteed to get updated in this amount of time,\n  // so do not add events for this path beyond pathStartTime + pathDurationMax.\n  // Most spirits will accelerate their bodies at a fixed frequency, so this value\n  // will not usually change during a body's lifetime unless its spirit changes.\n  this.pathDurationMax = Infinity;\n\n  this.rectRad = new Vec2d();\n\n  this.freezePathStartPos = new Vec2d();\n  this.freezeVel = new Vec2d();\n\n  this.reset();\n}\n\nBody.Shape = {\n  CIRCLE: 1,\n  RECT: 2\n};\n\nBody.pool = [];\n\nBody.alloc = function() {\n  if (Body.pool.length) {\n    return Body.pool.pop().reset();\n  }\n  return new Body();\n};\n\nBody.prototype.free = function() {\n  Body.pool.push(this);\n};\n\nBody.prototype.reset = function() {\n  this.id = 0;\n  this.spiritId = 0;\n  this.pathId = 0;\n\n  // The time at which the body was at pathStartPos\n  this.pathStartTime = 0;\n  this.pathStartPos.reset();\n  this.vel.reset();\n\n  // The World's map of Body objects that need to have their paths validated.\n  this.invalidBodyIds = null;\n\n  this.shape = Body.Shape.CIRCLE;\n\n  // circle radius\n  this.rad = 1;\n\n  // half-width and half-height, for rects\n  this.rectRad.reset(1, 1);\n\n  // This controls which other bodies and rayscans should be tested for collisions.\n  this.hitGroup = 0;\n\n  // data for the basic \"bounce\" collision response\n  this.mass = 1;\n  this.elasticity = 1;\n\n  // cache for rayscan freeze-unfreeze\n  this.freezePathStartPos.reset();\n  this.freezeVel.reset();\n  this.freezePathStartTime = 0;\n  this.freezePathDurationMax = 0;\n\n  return this;\n};\n\nBody.SCHEMA = {\n  0: 'id',\n  1: 'spiritId',\n  2: 'pathStartTime',\n  3: 'pathStartPos',\n  4: 'vel',\n  5: 'pathDurationMax',\n  6: 'shape',\n  7: 'rad',\n  8: 'rectRad',\n  9: 'hitGroup',\n  10: 'mass',\n  11: 'elasticity'\n};\n\nBody.getJsoner = function() {\n  if (!Body.jsoner) {\n    Body.jsoner = new Jsoner(Body.SCHEMA);\n  }\n  return Body.jsoner;\n};\n\nBody.prototype.toJSON = function() {\n  return Body.getJsoner().toJSON(this);\n};\n\nBody.prototype.setFromJSON = function(json) {\n  Body.getJsoner().setFromJSON(json, this);\n};\n\n/**\n * @param {number} t\n * @param {Vec2d} out\n * @returns {Vec2d}\n */\nBody.prototype.getPosAtTime = function(t, out) {\n  return out.set(this.vel).scale(t - this.pathStartTime).add(this.pathStartPos);\n};\n\n/**\n * @param {number} t\n * @param {=Rect} opt_out\n * @returns {Rect}\n */\nBody.prototype.getBoundingRectAtTime = function(t, opt_out) {\n  var out = opt_out || new Rect();\n  this.getPosAtTime(t, out.pos);\n  if (this.shape == Body.Shape.CIRCLE) {\n    out.setRadXY(this.rad, this.rad);\n  } else if (this.shape == Body.Shape.RECT) {\n    out.setRad(this.rectRad);\n  }\n  return out;\n};\n\n/**\n * @returns {Number}\n */\nBody.prototype.getArea = function() {\n  if (this.shape == Body.Shape.CIRCLE) {\n    return Math.PI * this.rad * this.rad;\n  } else {\n    return this.rectRad.x * this.rectRad.y;\n  }\n};\n\nBody.prototype.invalidatePath = function() {\n  if (this.invalidBodyIds && this.id) {\n    this.invalidBodyIds[this.id] = true;\n  }\n};\n\n/**\n * Shifts the path so it intersects the new position at the new time,\n * without changing the velocity. Teleportation, basically.\n * @param pos\n * @param t\n */\nBody.prototype.setPosAtTime = function(pos, t) {\n  this.invalidatePath();\n  this.pathStartTime = t;\n  this.pathStartPos.set(pos);\n};\n\n/**\n * Shifts the path so it intersects the new position at the new time,\n * without changing the velocity. Teleportation, basically.\n * @param x\n * @param y\n * @param t\n */\nBody.prototype.setPosXYAtTime = function(x, y, t) {\n  this.invalidatePath();\n  this.pathStartTime = t;\n  this.pathStartPos.setXY(x, y);\n};\n\n/**\n * Shifts the path so that it intersects the same position at time t that it used to,\n * but it arrives with a new velocity (and therefore is coming from and going to new places.)\n * @param vel\n * @param t\n */\nBody.prototype.setVelAtTime = function(vel, t) {\n  this.invalidatePath();\n  this.moveToTime(t);\n  this.vel.set(vel);\n};\n\n/**\n * Shifts the path so that it intersects the same position at time t that it used to,\n * but it arrives with a new velocity (and therefore is coming from and going to new places.)\n * @param x\n * @param y\n * @param t\n */\nBody.prototype.setVelXYAtTime = function(x, y, t) {\n  this.invalidatePath();\n  this.moveToTime(t);\n  this.vel.setXY(x, y);\n};\n\n/**\n * Without invalidating the path, this sets the pathStartTime to t, and adjusts the pathStartPos.\n * @param {number} t\n */\nBody.prototype.moveToTime = function(t) {\n  if (this.pathStartTime === t) return;\n  var temp = this.getPosAtTime(t, Vec2d.alloc());\n  this.pathStartPos.set(temp);\n  this.pathStartTime = t;\n  temp.free();\n};\n\nBody.prototype.getPathEndTime = function() {\n  return this.pathStartTime + this.pathDurationMax;\n};\n\n/**\n * Freezes a body at a certain time, so it can be rayscanned.\n * @param time\n */\nBody.prototype.freezeAtTime = function(time) {\n  this.freezePathStartPos.set(this.pathStartPos);\n  this.freezeVel.set(this.vel);\n  this.freezePathStartTime = this.pathStartTime;\n  this.freezePathDurationMax = this.pathDurationMax;\n\n  // update pathStartTime and pathStartPos\n  this.moveToTime(time);\n  // stop in place\n  this.vel.setXY(0, 0);\n  // rayscans have a pathDurationMax of 1, so this doesn't need anything higher.\n  this.pathDurationMax = 1;\n};\n\nBody.prototype.unfreeze = function() {\n  this.pathStartPos.set(this.freezePathStartPos);\n  this.vel.set(this.freezeVel);\n  this.pathStartTime = this.freezePathStartTime;\n  this.pathDurationMax = this.freezePathDurationMax;\n};\n\n\n\n\n/**\n * A rectangular range of cells in a grid.\n * @constructor\n */\nfunction CellRange() {\n  this.p0 = new Vec2d();\n  this.p1 = new Vec2d();\n  this.reset();\n}\n\nCellRange.prototype.reset = function() {\n  this.p0.setXY(0, 0);\n  this.p1.setXY(-1, -1);\n};\n\n/**\n * @param {CellRange} that\n */\nCellRange.prototype.set = function(that) {\n  this.p0.set(that.p0);\n  this.p1.set(that.p1);\n};\n\nPoolify(CellRange);\n\n\n\n/**\n * Creates WorldEvents for collisions between bodies.\n * @constructor\n */\nfunction HitDetector() {\n  this.xOverlap = [0, 0];\n  this.yOverlap = [0, 0];\n  this.overlap = [0, 0, null]; // start, end, axis if any\n}\n\nHitDetector.prototype.calcHit = function(now, b0, b1, eventOut) {\n  if (b0.vel.equals(b1.vel)) {\n    return null;\n  }\n  var hit = null;\n  if (b0.shape == Body.Shape.RECT) {\n    if (b1.shape == Body.Shape.RECT) {\n      hit = this.calcHitRectRect(now, b0, b1, eventOut);\n    } else {\n      hit = this.calcHitRectCircle(now, b0, b1, eventOut);\n    }\n  } else if (b1.shape == Body.Shape.RECT) {\n    hit = this.calcHitRectCircle(now, b1, b0, eventOut);\n  } else {\n    hit = this.calcHitCircleCircle(now, b0, b1, eventOut);\n  }\n  return hit;\n};\n\n/**\n * @param {number} now\n * @param {Body} b0 Rectangluar body\n * @param {Body} b1 Rectangluar body\n * @param {WorldEvent} eventOut Pre-allocated output param.\n * @returns {?WorldEvent} Event if hit, or null.\n */\nHitDetector.prototype.calcHitCircleCircle = function(now, b0, b1, eventOut) {\n  var p0 = b0.getPosAtTime(now, Vec2d.alloc());\n  var p1 = b1.getPosAtTime(now, Vec2d.alloc());\n\n  // For most of the computations, we shift times left so \"now\" is zero.\n  var maxDuration = Math.min(b0.getPathEndTime(), b1.getPathEndTime()) - now;\n\n  // Normalize as if b0 is holding still at 0, 0.\n  var overlap = this.circleOriginOverlapTime(\n      p1.x - p0.x,\n      p1.y - p0.y,\n      b1.vel.x - b0.vel.x,\n      b1.vel.y - b0.vel.y,\n      b0.rad + b1.rad);\n  p0.free();\n  p1.free();\n  var e = null;\n  if (overlap && 0 < overlap[0] && overlap[0] <= maxDuration) {\n    e = eventOut;\n    e.type = WorldEvent.TYPE_HIT;\n    e.time = now + overlap[0];\n    e.pathId0 = b0.pathId;\n    e.pathId1 = b1.pathId;\n    e.collisionVec.set(b1.getPosAtTime(e.time, p1)).subtract(b0.getPosAtTime(e.time, p0));\n  }\n  return e;\n};\n\n/**\n * @param {number} now\n * @param {Body} rect Rectangluar body\n * @param {Body} circ Circular body\n * @param {WorldEvent} eventOut Pre-allocated output param.\n * @returns {?WorldEvent} Event if hit, or null.\n */\nHitDetector.prototype.calcHitRectCircle = function(now, rect, circ, eventOut) {\n  var e = null;\n  var posRect = rect.getPosAtTime(now, Vec2d.alloc());\n  var posCirc = circ.getPosAtTime(now, Vec2d.alloc());\n  var maxDuration = Math.min(rect.getPathEndTime(), circ.getPathEndTime()) - now;\n\n  // bounding rect check\n  var brectOverlap = this.rectOverlapTime(\n      posRect, rect.vel, rect.rectRad.x, rect.rectRad.y,\n      posCirc, circ.vel, circ.rad, circ.rad);\n  // If the brects don't overlap, or *finish* before 0, or start after max, then there's no legal hit.\n  if (!brectOverlap || brectOverlap[1] <= 0 || maxDuration < brectOverlap[0]) {\n    posRect.free();\n    posCirc.free();\n    return null;\n  }\n\n  // Put the circle at 0, 0, holding still. x, y, dx, and dy are for the rect.\n  // Tricky - re-use the allocated vecs. Free pos and vel before returning.\n  var pos = posRect.subtract(posCirc);\n  var vel = posCirc.set(rect.vel).subtract(circ.vel);\n  var vSign = Vec2d.alloc().set(vel).sign();\n\n  // Check leading edges. If a hit is found, return immediately,\n  // because an edge hit is always earlier than a corner hit.\n  // TODO more efficient special-purpose point vs aa-segment code.\n  var edgePos = Vec2d.alloc();\n  var edgeRad = Vec2d.alloc();\n  var compassPos = Vec2d.alloc();\n  for (var i = 0; i < 2 && !e; i++) {\n    var axis = Vec2d.AXES[i];\n    if (vSign[axis]) {\n      edgePos.set(pos);\n      edgePos[axis] += rect.rectRad[axis] * vSign[axis];\n      edgeRad.set(rect.rectRad);\n      edgeRad[axis] = 0;\n\n      compassPos[axis] = -vSign[axis] * circ.rad;\n      var edgeOverlapTime = this.rectOverlapTime(\n          edgePos, vel, edgeRad.x, edgeRad.y,\n          compassPos, Vec2d.ZERO, 0, 0);\n      compassPos[axis] = 0;\n      if (edgeOverlapTime && 0 < edgeOverlapTime[0] && edgeOverlapTime[0] <= maxDuration) {\n        e = eventOut;\n        e.type = WorldEvent.TYPE_HIT;\n        e.time = now + edgeOverlapTime[0];\n        e.pathId0 = rect.pathId;\n        e.pathId1 = circ.pathId;\n        e.collisionVec.setXY(0, 0)[axis] = 1; // I guess?\n      }\n    }\n  }\n  edgePos.free();\n  edgeRad.free();\n  compassPos.free();\n  if (e) {\n    // There was an edge hit.\n    pos.free();\n    vel.free();\n    vSign.free();\n    return e;\n  }\n\n  // Now find the earliest hit time, even if it's outside the legal range, because it will be\n  // the actual shape-to-shape hit time. Save the range check for last.\n\n  // Check rect's leading corners, as point-circles, against the circle at 0, 0.\n  // The bounding rects hit, so the rect is definitely approaching the circle.\n  var t = maxDuration + 1;\n  var cornerPos = Vec2d.alloc();\n  var hitCorner = Vec2d.alloc();\n  var overlap;\n  if (vSign.x && vSign.y) {\n    // Diagonal motion. Check leading corner and two trailing corners.\n    // A trailing corner might hit before a lead corner, so check them all.\n    // TODO: Don't check a trailing corner if it starts in 1D overlap with circle.\n\n    // lead corner\n    cornerPos.set(rect.rectRad).multiply(vSign).add(pos);\n    overlap = this.circleOriginOverlapTime(\n        cornerPos.x, cornerPos.y, vel.x, vel.y, circ.rad);\n    if (overlap) {\n      t = overlap[0];\n      hitCorner.set(cornerPos);\n    }\n    // corner above/below lead\n    overlap = this.circleOriginOverlapTime(\n        cornerPos.x, pos.y - vSign.y * rect.rectRad.y,\n        vel.x, vel.y, circ.rad);\n    if (overlap && overlap[0] < t) {\n      t = overlap[0];\n      hitCorner.setXY(cornerPos.x, pos.y - vSign.y * rect.rectRad.y);\n    }\n    // corner right/left of lead\n    overlap = this.circleOriginOverlapTime(\n        pos.x - vSign.x * rect.rectRad.x, cornerPos.y,\n        vel.x, vel.y, circ.rad);\n    if (overlap && overlap[0] < t) {\n      t = overlap[0];\n      hitCorner.setXY(pos.x - vSign.x * rect.rectRad.x, cornerPos.y);\n    }\n  } else {\n    // Axis-aligned motion.\n    // Check the two leading corners.\n    // CornerPos starts in the middle of the lead edge,\n    // then we shift it to the corners.\n    var shift = Vec2d.alloc().set(vSign).rot90Right().multiply(rect.rectRad);\n    var edgeCenter = Vec2d.alloc().set(rect.rectRad).multiply(vSign).add(pos);\n    for (var i = 0; i < 2; i++) {\n      cornerPos.set(edgeCenter).add(shift);\n      overlap = this.circleOriginOverlapTime(\n          cornerPos.x, cornerPos.y, vel.x, vel.y, circ.rad);\n      if (overlap && overlap[0] < t) {\n        t = overlap[0];\n        hitCorner.set(cornerPos);\n      }\n      shift.scale(-1);\n    }\n    shift.free();\n    edgeCenter.free();\n  }\n  if (0 < t && t <= maxDuration) {\n    e = eventOut;\n    e.type = WorldEvent.TYPE_HIT;\n    e.time = now + t;\n    e.pathId0 = rect.pathId;\n    e.pathId1 = circ.pathId;\n\n    // Slide the hit corner to the edge of the circle.\n    e.collisionVec.set(vel).scale(t).add(hitCorner);\n  }\n  hitCorner.free();\n  cornerPos.free();\n  vSign.free();\n  vel.free();\n  pos.free();\n  return e;\n};\n\n/**\n * @param {number} now\n * @param {Body} b0 Rectangluar body\n * @param {Body} b1 Rectangluar body\n * @param {WorldEvent} eventOut Pre-allocated output param.\n * @returns {?WorldEvent} Event if hit, or null.\n */\nHitDetector.prototype.calcHitRectRect = function(now, b0, b1, eventOut) {\n  var pos0 = b0.getPosAtTime(now, Vec2d.alloc());\n  var pos1 = b1.getPosAtTime(now, Vec2d.alloc());\n\n  // For most of the computations, we shift times left so \"now\" is zero.\n  var maxDuration = Math.min(b0.getPathEndTime(), b1.getPathEndTime()) - now;\n  var overlap = this.rectOverlapTime(\n      pos0, b0.vel, b0.rectRad.x, b0.rectRad.y,\n      pos1, b1.vel, b1.rectRad.x, b1.rectRad.y);\n\n  pos0.free();\n  pos1.free();\n  var e = null;\n  if (overlap && 0 < overlap[0] && overlap[0] <= maxDuration) {\n    e = eventOut;\n    e.type = WorldEvent.TYPE_HIT;\n    e.time = now + overlap[0];\n    e.pathId0 = b0.pathId;\n    e.pathId1 = b1.pathId;\n    e.collisionVec.setXY(0, 0)[overlap[2]] = 1;\n  }\n  return e;\n};\n\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} dx\n * @param {number} dy\n * @param {number} rad\n * @returns {?Array} null for no overlap, or a two element array [start time, end time]\n */\nHitDetector.prototype.circleOriginOverlapTime = function(x, y, dx, dy, rad) {\n  // quadratic equation\n  var a = dx * dx + dy * dy; // not zero, because vels are not equal\n  if (a == 0) return null;\n  var b = 2 * (x * dx + y * dy);\n  var c = x * x + y * y - rad * rad;\n  var b2_4ac = b * b - 4 * a * c;\n  if (b2_4ac < 0) return null;\n  var sqrtb2_4ac = Math.sqrt(b2_4ac);\n\n  var t = (-b + sqrtb2_4ac) / (2 * a);\n  var t2 = (-b - sqrtb2_4ac) / (2 * a);\n  this.overlap[0] = Math.min(t, t2);\n  this.overlap[1] = Math.max(t, t2);\n  return this.overlap;\n};\n\n\n/**\n * @param {Vec2d} pos0\n * @param {Vec2d} vel0\n * @param {number} rad0x\n * @param {number} rad0y\n * @param {Vec2d} pos1\n * @param {Vec2d} vel1\n * @param {number} rad1x\n * @param {number} rad1y\n * @returns {?Array} null for no overlap, or a two element array [start time, end time]\n */\nHitDetector.prototype.rectOverlapTime = function(\n    pos0, vel0, rad0x, rad0y,\n    pos1, vel1, rad1x, rad1y) {\n  var count;\n  count = this.overlapTime1D(\n      pos0.x, vel0.x, rad0x,\n      pos1.x, vel1.x, rad1x,\n      this.xOverlap);\n  if (count == 0) return null;\n  count = this.overlapTime1D(\n      pos0.y, vel0.y, rad0y,\n      pos1.y, vel1.y, rad1y,\n      this.yOverlap);\n  if (count == 0) return null;\n\n  var overlapStart; // max of overlap starts\n  if (this.xOverlap[0] < this.yOverlap[0]) {\n    overlapStart = this.yOverlap[0];\n    this.overlap[2] = Vec2d.Y;\n  } else {\n    overlapStart = this.xOverlap[0];\n    this.overlap[2] = Vec2d.X;\n  }\n  var overlapEnd = Math.min(this.xOverlap[1], this.yOverlap[1]);\n  if (overlapEnd < overlapStart) return null;\n  this.overlap[0] = overlapStart;\n  this.overlap[1] = overlapEnd;\n  return this.overlap;\n};\n\n/**\n * One-dimensional overlap timespan.\n * @param p0 position\n * @param v0 velocity\n * @param r0 radius\n * @param p1 position\n * @param v1 velocity\n * @param r1 radius\n * @param out output array. Zero, one, or two time values may be returned.\n * @returns {number} number of collisions returned on the output array\n */\nHitDetector.prototype.overlapTime1D = function(p0, v0, r0, p1, v1, r1, out) {\n  var v = v1 - v0;\n  var p = p1 - p0;\n  var r = r0 + r1;\n  if (!v) {\n    // forever, or never?\n    if (Math.abs(p) < r) {\n      // forever\n      out[0] = -Infinity;\n      out[1] = Infinity;\n      return 2;\n    } else {\n      // never\n      return 0;\n    }\n  }\n  out[0] = (-p - r) / v;\n  out[1] = (-p + r) / v;\n  if (out[0] > out[1]) {\n    var tmp = out[0];\n    out[0] = out[1];\n    out[1] = tmp;\n  }\n  return 2;\n};\n\n\n\n/**\n * Accelerates colliding bodies.\n * @constructor\n */\nfunction HitResolver() {\n  this.defaultElasticity = 0.99;\n}\n\n/**\n * @param {number} time\n * @param {Vec2d} collisionVec\n * @param {Body} b0\n * @param {Body} b1\n */\nHitResolver.prototype.resolveHit = function(time, collisionVec, b0, b1) {\n  if (b0.mass == Infinity && b1.mass == Infinity) return;\n  var pos0 = b0.getPosAtTime(time, Vec2d.alloc());\n  var pos1 = b1.getPosAtTime(time, Vec2d.alloc());\n\n  // Shift b0 to the origin, holding still.\n  var vel = Vec2d.alloc().set(b1.vel).subtract(b0.vel);\n\n  // Calculate accel needed for inelastic resolution.\n  // Calc accel along the collision vector by enough to cancel velocity along that direction.\n  var accel = Vec2d.alloc().set(vel).projectOnto(collisionVec);\n  // Add onto that for elastic collision.\n  accel.scale(-1 - this.defaultElasticity);\n  if (accel.equals(Vec2d.ZERO)) {\n    accel.free();\n    pos0.free();\n    pos1.free();\n    return;\n  }\n//  if (accel.magnitudeSquared() < 0.1 * 0.1) {\n//    accel.scaleToLength(0.1);\n//  }\n\n  // Use masses to decide which body gets accelerated by how much.\n  if (b0.mass == Infinity) {\n    b1.setVelAtTime(accel.add(b1.vel), time);\n  } else if (b1.mass == Infinity) {\n    b0.setVelAtTime(accel.scale(-1).add(b0.vel), time);\n  } else {\n    var work = Vec2d.alloc();\n    var massTotal = b0.mass + b1.mass;\n\n    var frac0 = b1.mass / massTotal;\n    work.set(accel).scale(-frac0).add(b0.vel);\n    b0.setVelAtTime(work, time);\n\n    var frac1 = b0.mass / massTotal;\n    work.set(accel).scale(frac1).add(b1.vel);\n    b1.setVelAtTime(work, time);\n    work.free();\n  }\n  accel.free();\n  pos0.free();\n  pos1.free();\n};\n\n\n/**\n * This only has static methods, but the constructor gives it a namespace. Meh.\n * @constructor\n */\nfunction OverlapDetector() {\n}\n\nOverlapDetector.isBodyOverlappingBodyAtTime = function(b0, b1, t) {\n  var overlap;\n  var p0 = b0.getPosAtTime(t, Vec2d.alloc());\n  var p1 = b1.getPosAtTime(t, Vec2d.alloc());\n  if (b0.shape == Body.Shape.CIRCLE && b1.shape == Body.Shape.CIRCLE) {\n    overlap = OverlapDetector.isCircleOverlappingCircle(p0, b0.rad, p1, b1.rad);\n  } else if (b0.shape == Body.Shape.RECT && b1.shape == Body.Shape.RECT) {\n    overlap = OverlapDetector.isRectOverlappingRect(p0, b0.rectRad, p1, b1.rectRad);\n  } else if (b0.shape == Body.Shape.RECT) {\n    overlap = OverlapDetector.isRectOverlappingCircle(p0, b0.rectRad, p1, b1.rad);\n  } else {\n    overlap = OverlapDetector.isRectOverlappingCircle(p1, b1.rectRad, p0, b0.rad);\n  }\n  p0.free();\n  p1.free();\n  return overlap;\n};\n\nOverlapDetector.isCircleOverlappingCircle = function(v0, r0, v1, r1) {\n  var r = r0 + r1;\n  return v0.distanceSquared(v1) <= r * r;\n};\n\nOverlapDetector.isRectOverlappingRect = function(p0, rectRad0, p1, rectRad1) {\n  var rx = rectRad0.x + rectRad1.x;\n  var ry = rectRad0.y + rectRad1.y;\n  var dx = Math.abs(p0.x - p1.x);\n  var dy = Math.abs(p0.y - p1.y);\n  return dx <= rx && dy <= ry;\n};\n\nOverlapDetector.isRectOverlappingCircle = function(rectPos, rectRad, circPos, radius) {\n  var nearCorner = Vec2d.alloc(rectPos.x, rectPos.y).subtract(circPos).abs().subtract(rectRad);\n  var overlap =\n      // rect covers origin?\n      (nearCorner.x <= 0 && nearCorner.y <= 0) ||\n      // rect overlaps vertical axis of circle?\n      (nearCorner.x <= 0 && nearCorner.y <= radius) ||\n      // rect overlaps horizontal axis of circle?\n      (nearCorner.y <= 0 && nearCorner.x <= radius) ||\n      // rect corner inside circle?\n      nearCorner.magnitudeSquared() <= radius * radius;\n  nearCorner.free();\n  return overlap;\n};\n\n\n\n/**\n * Base class for an entity in the world that does stuff, like manipulating bodies.\n * @param id\n * @constructor\n */\nfunction Spirit(id) {\n  this.id = id;\n}\n\n/**\n * Every spirit has this called when that spirit enters the world, or when the world first starts up.\n * At this point, a spirit ought to set up an onTimeout, to get its event loop started.\n * @param {World} world\n */\nSpirit.prototype.onStart = function(world) {\n};\n\n/**\n * Called when the Clock advances to the time of the Timeout.\n * @param {World} world\n * @param {Timeout} timeout  the timeout that the spirit sent to the world.\n */\nSpirit.prototype.onTimeout = function(world, timeout) {\n};\n\n/**\n * When a Body is hit, the world informs its Spirit, if any.\n * @param {World} world\n * @param {Body} thisBody\n * @param {Body} thatBody\n * @param {WorldEvent} hit\n */\nSpirit.prototype.onHit = function(world, thisBody, thatBody, hit) {\n};\n\n/**\n * Optional function called on every frame draw.\n * @param {World} world\n * @param {Renderer} renderer\n */\nSpirit.prototype.onDraw = function(world, renderer) {\n};\n\n\n\n/**\n * Handles spirits and bodies.\n *\n * @param {=number} opt_cellSize The world-space size of each cell in the collision-detection grid.\n * If it's too small, time is wasted as things enter and exit cells. If it's too big,\n * we suffer from O(n^2) collision detection speed within each cell.\n * If falsey, this defaults to 15.\n *\n * @param {=number} opt_groupCount The number of collision groups in each cell.\n * If falsey, this defaults to 1.\n *\n * @param {=Array} opt_groupPairs An array of 2-element arrays, defining all the group pairs\n * that can collide with each other. The two IDs in a pair may be the same, to make\n * a group's members collide with each other.\n * If falsey, this defaults to one group, \"0\", which collides with itself.\n *\n * @constructor\n */\nfunction World(opt_cellSize, opt_groupCount, opt_groupPairs) {\n  this.cellSize = opt_cellSize || World.DEFAULT_CELL_SIZE;\n  this.groupCount = opt_groupCount || 1;\n  this.groupPairs = opt_groupPairs || [[0, 0]];\n  this.groupHitsGroups = [];\n  for (var i = 0; i < this.groupPairs.length; i++) {\n    var pair = this.groupPairs[i];\n    for (var a = 0; a < 2; a++) {\n      var b = (a + 1) % 2;\n      var list = this.groupHitsGroups[pair[a]];\n      if (!list) {\n        list = this.groupHitsGroups[pair[a]] = [];\n      }\n      if (list.indexOf(pair[b]) < 0) {\n        list.push(pair[b]);\n      }\n    }\n  }\n\n  // spiritId to Spirit\n  this.spirits = {};\n\n  // bodyId to Body\n  this.bodies = {};\n\n  // pathId to Body. Obsolete pathIds might still point to their old Bodies, so check the body's pathId.\n  this.paths = {};\n\n  // bodyId to \"true\". Holds IDs of body objects that need to have their paths processed by the collider\n  // before time can move forward. This includes newly-added bodies.\n  // Bodies can be invalid for a time, so that they can be manipulated while time is standing still,\n  // without having to recompute collisions every time.\n  this.invalidBodyIds = {};\n\n  this.nextId = 10;\n\n  this.grid = {};\n\n  this.queue = new SkipQueue(World.SKIP_QUEUE_BASE,\n      SkipQueue.getRecommendedMaxLevel(100, World.SKIP_QUEUE_BASE));\n\n  this.now = 1;\n\n  this.hitDetector = new HitDetector();\n  this.hitTimePadding = 0.01;\n\n  // cache for rayscans and overlap scans.\n  this.scannedBodyIds = new ObjSet();\n}\n\nWorld.SKIP_QUEUE_BASE = 2;\n\n// 5% fudge factor when deciding what cells an object is in.\nWorld.BRECT_FUDGE_FACTOR = 0.05;\n\nWorld.GRID_HUGENESS = 10000;\n\n/**\n * The width and height of grid cells.\n * The cell at index 0, 0 has its center at 0, 0.\n * The cell at index -1, 1 has its center at -CELL_SIZE, CELL_SIZE.\n */\nWorld.DEFAULT_CELL_SIZE = 15;\n\nWorld.prototype.cellCoord = function(worldCoord) {\n  return Math.round(worldCoord / this.cellSize);\n};\n\nWorld.prototype.gridIndexForCellCoords = function(ix, iy) {\n  return World.GRID_HUGENESS * ix + iy;\n};\n\nWorld.prototype.getCell = function(ix, iy) {\n  return this.grid[this.gridIndexForCellCoords(ix, iy)];\n};\n\nWorld.prototype.setCell = function(cell, ix, iy) {\n  this.grid[this.gridIndexForCellCoords(ix, iy)] = cell;\n  return cell;\n};\n\nWorld.prototype.removeCell = function(ix, iy) {\n  var index = this.gridIndexForCellCoords(ix, iy);\n  var cell = this.grid[index];\n  if (cell) {\n    delete this.grid[index];\n    cell.free();\n  }\n};\n\n/**\n * @returns {number}\n */\nWorld.prototype.newId = function() {\n  return this.nextId++;\n};\n\n/**\n * Assigns an ID and adds the spirit.\n * @return {number} the new spirit ID.\n */\nWorld.prototype.addSpirit = function(spirit) {\n  spirit.id = this.newId();\n  // If spirit loading gets more complicated, then call loadSpirit instead of inlining.\n  this.spirits[spirit.id] = spirit;\n  return spirit.id;\n};\n\n/**\n * Adds the spirit using the ID it already has.\n */\nWorld.prototype.loadSpirit = function(spirit) {\n  if (this.spirits[spirit.id]) throw Error(\"Spirit with id '\" + spirit.id + \"' already exists!\");\n  this.spirits[spirit.id] = spirit;\n  this.nextId = Math.max(this.nextId, spirit.id + 1);\n};\n\nWorld.prototype.removeSpiritId = function(id) {\n  var spirit = this.spirits[id];\n  if (spirit) {\n    delete this.spirits[id];\n    if (spirit.free) {\n      spirit.free();\n    }\n  }\n};\n\n/**\n * Assigns an ID and adds the body.\n * @returns {number} the new body ID\n */\nWorld.prototype.addBody = function(body) {\n  body.id = this.newId();\n  this.loadBody(body);\n  return body.id;\n};\n\n/**\n * Adds the body using the ID it already has.\n */\nWorld.prototype.loadBody = function(body) {\n  if (this.bodies[body.id]) throw Error(\"Body with id '\" + body.id + \"' already exists!\");\n  // Add it to the bodies index and to the invalid bodies index.\n  // The next time the clock moves forward, the invalid body will be addressed.\n  this.bodies[body.id] = body;\n  this.nextId = Math.max(this.nextId, body.id + 1);\n\n  // Hook the path invalidator into the body. A wee bit hacky.\n  body.invalidBodyIds = this.invalidBodyIds;\n  body.invalidatePath();\n};\n\n/**\n * Removes the body and frees the body from the class pool.\n * @param bodyId\n */\nWorld.prototype.removeBodyId = function(bodyId) {\n  var body = this.bodies[bodyId];\n  if (body) {\n    var rect = Rect.alloc();\n    this.getPaddedBodyBoundingRect(body, this.now, rect);\n    var range = CellRange.alloc();\n    this.getCellRangeForRect(rect, range);\n    this.removeBodyFromCellRange(body, range);\n    range.free();\n    rect.free();\n    delete this.bodies[body.id];\n    delete this.paths[body.pathId];\n    delete this.invalidBodyIds[body.id];\n    body.free();\n  } else {\n    console.log(\"couldn't find or remove bodyId \" + bodyId);\n  }\n};\n\nWorld.prototype.removeBodyFromCellRange = function(body, cellRange) {\n  for (var iy = cellRange.p0.y; iy <= cellRange.p1.y; iy++) {\n    for (var ix = cellRange.p0.x; ix <= cellRange.p1.x; ix++) {\n      var cell = this.getCell(ix, iy);\n      if (cell) {\n        cell.removePathIdFromGroup(body.pathId, body.hitGroup);\n        if (cell.isEmpty()) {\n          this.removeCell(ix, iy);\n        }\n      }\n    }\n  }\n};\n\nWorld.prototype.getBody = function(bodyId) {\n  this.validateBodies();\n  return this.bodies[bodyId];\n};\n\n/**\n * Also purges obsolete pathIds from the index.\n * @param pathId\n * @returns {*}\n */\nWorld.prototype.getBodyByPathId = function(pathId) {\n  this.validateBodies();\n  var body = this.paths[pathId];\n  if (body && body.pathId != pathId) {\n    delete this.paths[pathId];\n    body = null;\n  }\n  if (body && !this.bodies[body.id]) {\n    console.warn(\"getBodyByPathId is writing checks that bodies cannot cash. pathId\", pathId, \"body.id:\", body.id);\n  }\n  return body;\n};\n\nWorld.prototype.validateBodies = function() {\n  for (var bodyId in this.invalidBodyIds) {\n    delete this.invalidBodyIds[bodyId];\n    var body = this.bodies[bodyId];\n    if (!body) continue;\n    if (body.pathId) {\n      delete this.paths[body.pathId];\n    }\n\n    // Update path\n    body.moveToTime(this.now);\n    body.pathId = this.newId();\n    this.paths[body.pathId] = body;\n\n    // Add initial set of events.\n    this.addPathToGrid(body);\n    this.addFirstGridEvent(body, WorldEvent.TYPE_GRID_ENTER, Vec2d.X);\n    this.addFirstGridEvent(body, WorldEvent.TYPE_GRID_ENTER, Vec2d.Y);\n    this.addFirstGridEvent(body, WorldEvent.TYPE_GRID_EXIT, Vec2d.X);\n    this.addFirstGridEvent(body, WorldEvent.TYPE_GRID_EXIT, Vec2d.Y);\n  }\n};\n\nWorld.prototype.getCellRangeForRect = function(rect, range) {\n  range.p0.setXY(\n      this.cellCoord(rect.pos.x - rect.rad.x),\n      this.cellCoord(rect.pos.y - rect.rad.y));\n  range.p1.setXY(\n      this.cellCoord(rect.pos.x + rect.rad.x),\n      this.cellCoord(rect.pos.y + rect.rad.y));\n  return range;\n};\n\nWorld.prototype.addPathToGrid = function(body) {\n  var brect = this.getPaddedBodyBoundingRect(body, this.now, Rect.alloc());\n  var range = this.getCellRangeForRect(brect, CellRange.alloc());\n  for (var iy = range.p0.y; iy <= range.p1.y; iy++) {\n    for (var ix = range.p0.x; ix <= range.p1.x; ix++) {\n      var cell = this.getCell(ix, iy);\n      if (!cell) {\n        cell = this.setCell(Cell.alloc(this.getGroupCount()), ix, iy);\n      }\n      this.addPathToCell(body, cell);\n    }\n  }\n  range.free();\n  brect.free();\n};\n\nWorld.prototype.getGroupCount = function() {\n  return this.groupCount;\n};\n\nWorld.prototype.addPathToCell = function(body, cell) {\n  var nextEvent = WorldEvent.alloc();\n  var group = body.hitGroup;\n\n  var hitGroups = this.groupHitsGroups[group];\n  for (var gi = 0; gi < hitGroups.length; gi++) {\n    var otherGroup = hitGroups[gi];\n    var pathIdSet = cell.getPathIdsForGroup(otherGroup);\n    var pathIdArray = pathIdSet.vals;\n    for (var pi = 0; pi < pathIdArray.length;) {\n      var pathId = pathIdArray[pi];\n      var otherBody = this.paths[pathId];\n      if (otherBody && otherBody.pathId == pathId) {\n        var hitEvent = this.hitDetector.calcHit(this.now, body, otherBody, nextEvent);\n        if (hitEvent && hitEvent.time < Infinity) {\n          // Pad the collision time to prevent numerical-challenge interpenetration.\n          hitEvent.time = Math.max(hitEvent.time - this.hitTimePadding, this.now);\n          // Add the existing event and allocate the next one.\n          this.queue.add(hitEvent);\n          nextEvent = WorldEvent.alloc();\n        }\n        pi++;\n      } else {\n        pathIdSet.removeIndex(pi);\n      }\n    }\n  }\n  cell.addPathIdToGroup(body.pathId, group);\n  nextEvent.free();\n};\n\n/**\n * Checks to see if the body's path will enter/exit a CellRange\n * before the path expires, and allocates and adds the event if so.\n * @param {Body} body\n * @param {String} eventType WorldEvent TYPE const.\n * @param {String} axis The axis along which the object travels (not the axis it crosses)\n * @param {WorldEvent} eventOut\n * @return {?WorldEvent} if there is an event, or null otherwise.\n */\nWorld.prototype.getFirstGridEvent = function(body, eventType, axis, eventOut) {\n  var v = body.vel;\n  if (!v[axis]) return null;\n  var perp = Vec2d.otherAxis(axis);\n\n  // Calculate the leading/trailing point \"p\" on the moving bounding rect.\n  var rect = body.getBoundingRectAtTime(this.now, Rect.alloc());\n  var vSign = Vec2d.alloc().set(body.vel).sign();\n\n  var p = Vec2d.alloc().set(rect.rad).multiply(vSign);\n  if (eventType === WorldEvent.TYPE_GRID_EXIT) {\n    p.scale(-1);\n  }\n  p.add(rect.pos);\n\n  // c is the center of the cell that p is in.\n  var c = Vec2d.alloc().set(p).roundToGrid(this.cellSize);\n\n  // Calculate crossing times\n  var e = null;\n  var t = this.now + (c[axis] + 0.5 * vSign[axis] * this.cellSize - p[axis]) / v[axis];\n  if (t < this.now) {\n    console.error(\"oh crap, grid event time < now:\", t, this.now);\n  } else if (t <= body.getPathEndTime()) {\n    e = eventOut;\n    e.type = eventType;\n    e.axis = axis;\n    e.time = t;\n    e.pathId = body.pathId;\n\n    // Is the event about entering the next set of cells, or leaving the current one?\n    e.cellRange.p0[axis] = e.cellRange.p1[axis] = this.cellCoord(c[axis]) +\n        (eventType === WorldEvent.TYPE_GRID_ENTER ? vSign[axis] : 0);\n    // The length of the crossing, in cells, depends on the position of the bounding rect at that time.\n    this.getPaddedBodyBoundingRect(body, t, rect);\n    e.cellRange.p0[perp] = this.cellCoord(rect.pos[perp] - rect.rad[perp]);\n    e.cellRange.p1[perp] = this.cellCoord(rect.pos[perp] + rect.rad[perp]);\n  }\n  c.free();\n  p.free();\n  vSign.free();\n  rect.free();\n  return e;\n};\n\n/**\n * Checks to see if the body's path will enter/exit a CellRange\n * before the path expires, and allocates and adds the event if so.\n * @param {Body} body\n * @param {String} eventType WorldEvent TYPE const.\n * @param {String} axis The axis along which the object travels (not the axis it crosses)\n */\nWorld.prototype.addFirstGridEvent = function(body, eventType, axis) {\n  var event = WorldEvent.alloc();\n  if (this.getFirstGridEvent(body, eventType, axis, event)) {\n    this.queue.add(event);\n  } else {\n    event.free();\n  }\n};\n\n/**\n * Checks to see if the body's path will enter/exit a CellRange\n * before the path expires, and allocates and adds the event if so.\n * @param {Body} body\n * @param {WorldEvent} prevEvent The grid event before this one.\n * @param {WorldEvent} eventOut\n * @return {?WorldEvent} if there is an event, or null otherwise.\n */\nWorld.prototype.getSubsequentGridEvent = function(body, prevEvent, eventOut) {\n  var axis = prevEvent.axis;\n  var eventType = prevEvent.type;\n  var v = body.vel;\n  if (!v[axis]) return null;\n  var perp = Vec2d.otherAxis(axis);\n\n  var vSign = Vec2d.alloc().set(v).sign();\n  var nextCellIndex = prevEvent.cellRange.p0[axis] + vSign[axis];\n  // What time will the point reach that cell index?\n  var rad = vSign[axis] * (body.shape == Body.Shape.CIRCLE ? body.rad : body.rectRad[axis]);\n  var dest;\n  if (eventType == WorldEvent.TYPE_GRID_ENTER) {\n    dest = (nextCellIndex - 0.5 * vSign[axis]) * this.cellSize - rad;\n  } else {\n    dest = (nextCellIndex + 0.5 * vSign[axis]) * this.cellSize + rad;\n  }\n  var t = body.pathStartTime + (dest - body.pathStartPos[axis]) / v[axis];\n  var e = null;\n  if (t < this.now) {\n    console.error(\"oh crap\", t, this.now);\n  } else if (t <= body.getPathEndTime()) {\n    e = eventOut;\n    e.type = eventType;\n    e.axis = axis;\n    e.time = t;\n    e.pathId = body.pathId;\n\n    // Is the event about entering the next set of cells, or leaving the current one?\n    e.cellRange.p0[axis] = e.cellRange.p1[axis] = nextCellIndex;\n    // The length of the crossing, in cells, depends on the position of the bounding rect at that time.\n    var rect = Rect.alloc();\n    this.getPaddedBodyBoundingRect(body, t, rect);\n    e.cellRange.p0[perp] = this.cellCoord(rect.pos[perp] - rect.rad[perp]);\n    e.cellRange.p1[perp] = this.cellCoord(rect.pos[perp] + rect.rad[perp]);\n    rect.free();\n  }\n  vSign.free();\n  return e;\n};\n\nWorld.prototype.addSubsequentGridEvent = function(body, prevEvent) {\n  var event = WorldEvent.alloc();\n  if (this.getSubsequentGridEvent(body, prevEvent, event)) {\n    this.queue.add(event);\n  } else {\n    event.free();\n  }\n};\n\n/**\n * Returns the next event in the queue, without dequeueing it.\n */\nWorld.prototype.getNextEvent = function() {\n  this.validateBodies();\n  return this.queue.getFirst();\n};\n\n/**\n * Removes the next event from the queue, and advances the world time to the event time,\n * optionally doing some internal processing.\n */\nWorld.prototype.processNextEvent = function() {\n  this.validateBodies();\n  var e = this.queue.removeFirst();\n  this.now = e.time;\n\n  if (e.type === WorldEvent.TYPE_GRID_ENTER) {\n    var body = this.paths[e.pathId];\n    if (body && body.pathId == e.pathId) {\n      this.addSubsequentGridEvent(body, e);\n      for (var iy = e.cellRange.p0.y; iy <= e.cellRange.p1.y; iy++) {\n        for (var ix = e.cellRange.p0.x; ix <= e.cellRange.p1.x; ix++) {\n          var cell = this.getCell(ix, iy);\n          if (!cell) {\n            cell = this.setCell(Cell.alloc(this.getGroupCount()), ix, iy);\n          }\n          this.addPathToCell(body, cell);\n        }\n      }\n    }\n\n  } else if (e.type === WorldEvent.TYPE_GRID_EXIT) {\n    var body = this.paths[e.pathId];\n    if (body && body.pathId == e.pathId) {\n      this.addSubsequentGridEvent(body, e);\n      this.removeBodyFromCellRange(body, e.cellRange);\n    }\n\n  } else if (e.type === WorldEvent.TYPE_HIT) {\n    // Let the game handle it.\n\n  } else if (e.type === WorldEvent.TYPE_TIMEOUT) {\n    var spirit = this.spirits[e.spiritId];\n    if (spirit) {\n      spirit.onTimeout(this, e);\n    }\n  }\n  e.free();\n};\n\nWorld.prototype.addTimeout = function(time, spiritId, val) {\n  var e = WorldEvent.alloc();\n  e.type = WorldEvent.TYPE_TIMEOUT;\n  e.time = time;\n  e.spiritId = spiritId;\n  e.timeoutVal = val;\n  this.queue.add(e);\n};\n\n/**\n * Adds the timeout to the event queue.\n */\nWorld.prototype.loadTimeout = function(e) {\n  this.addTimeout(e.time, e.spiritId, e.timeoutVal);\n};\n\n// TODO World.prototype.removeTimeout\n\n/**\n * Performs an immediate rayscan. If there's a hit, this will return true,\n * and the response will be populated. Otherwise it will be untouched.\n * @param {ScanRequest} req Input param\n * @param {ScanResponse} resp Output param.\n * @return {boolean} true if there's a hit, false if not.\n */\nWorld.prototype.rayscan = function(req, resp) {\n  this.validateBodies();\n  this.scannedBodyIds.reset();\n  var foundHit = false;\n\n  // Create a Body based on the ScanRequest.\n  var b = Body.alloc();\n  b.hitGroup = req.hitGroup;\n  b.setPosAtTime(req.pos, this.now);\n  b.vel.set(req.vel);\n  b.shape = req.shape;\n  b.rad = req.rad;\n  b.rectRad.set(req.rectRad);\n  b.pathDurationMax = 1;\n\n  // allocs\n  var rect = Rect.alloc();\n  var range = CellRange.alloc();\n  var hitEvent = WorldEvent.alloc();\n  var xEvent = WorldEvent.alloc();\n  var yEvent = WorldEvent.alloc();\n\n  // The hitEvent will always be the earliest hit, because every time a hit is found,\n  // the body's pathDurationMax is ratcheted down to the hit time. So only\n  // earlier hits will be discovered afterwards.\n  hitEvent.time = this.now + b.pathDurationMax + 1; // effective infinity\n\n  // Examine the body's starting cells.\n  b.getBoundingRectAtTime(this.now, rect);\n  this.getCellRangeForRect(rect, range);\n  if (this.getRayscanHit(b, range, hitEvent)) {\n    foundHit = true;\n  }\n\n  // Calc the initial grid-enter events\n  xEvent.time = yEvent.time = this.now + b.pathDurationMax + 1; // effective infinity\n\n  this.getFirstGridEvent(b, WorldEvent.TYPE_GRID_ENTER, Vec2d.X, xEvent);\n  this.getFirstGridEvent(b, WorldEvent.TYPE_GRID_ENTER, Vec2d.Y, yEvent);\n\n  // Process the earliest grid-enter event and generate the next one,\n  // until they're later than the max time.\n  var maxTime = this.now + b.pathDurationMax;\n  var eventOut = WorldEvent.alloc();\n  var tmp;\n  while (xEvent.time <  maxTime || yEvent.time < maxTime) {\n    if (xEvent.time < yEvent.time) {\n      if (this.getRayscanHit(b, xEvent.cellRange, hitEvent)) {\n        foundHit = true;\n      }\n      if (this.getSubsequentGridEvent(b, xEvent, eventOut)) {\n        tmp = xEvent;\n        xEvent = eventOut;\n        eventOut = tmp;\n      } else {\n        // Push event out of range.\n        xEvent.time = maxTime + 1;\n      }\n    } else {\n      if (this.getRayscanHit(b, yEvent.cellRange, hitEvent)) {\n        foundHit = true;\n      }\n      if (this.getSubsequentGridEvent(b, yEvent, eventOut)) {\n        tmp = yEvent;\n        yEvent = eventOut;\n        eventOut = tmp;\n      } else {\n        // Push event out of range.\n        yEvent.time = maxTime + 1;\n      }\n    }\n    // lower maxTime\n    maxTime = this.now + b.pathDurationMax;\n  }\n\n  if (foundHit) {\n    // The request body's pathId is 0, so take the non-zero one.\n    resp.pathId = hitEvent.pathId0 || hitEvent.pathId1;\n    resp.timeOffset = hitEvent.time - this.now;\n    resp.collisionVec.set(hitEvent.collisionVec);\n  }\n  rect.free();\n  range.free();\n  hitEvent.free();\n  xEvent.free();\n  yEvent.free();\n  return foundHit;\n};\n\n/**\n * Gets the earliest hit between a Body and all the bodies in a CellRange.\n * Side effect: The input body's pathDurationMax will shrink to the hit time.\n * @param {Body} body\n * @param {CellRange} range\n * @param {WorldEvent} eventOut\n * @returns {?WorldEvent} eventOut if there was a hit, or null otherwise.\n */\nWorld.prototype.getRayscanHit = function(body, range, eventOut) {\n  var retval = null;\n  for (var iy = range.p0.y; iy <= range.p1.y; iy++) {\n    for (var ix = range.p0.x; ix <= range.p1.x; ix++) {\n      var cell = this.getCell(ix, iy);\n      if (cell) {\n        var hitGroups = this.groupHitsGroups[body.hitGroup];\n        for (var gi = 0; gi < hitGroups.length; gi++) {\n          var otherGroup = hitGroups[gi];\n          var pathIdSet = cell.getPathIdsForGroup(otherGroup);\n          var pathIdArray = pathIdSet.vals;\n          for (var i = 0; i < pathIdArray.length;) {\n            var pathId = pathIdArray[i];\n            var otherBody = this.paths[pathId];\n            if (otherBody && otherBody.pathId == pathId) {\n              if (!this.scannedBodyIds.contains(otherBody.id)) {\n                this.scannedBodyIds.put(otherBody.id);\n                otherBody.freezeAtTime(this.now);\n                if (this.hitDetector.calcHit(this.now, body, otherBody, eventOut)) {\n                  retval = eventOut;\n                  // Tighten the duration max. There's no point in looking for later hits, just earlier ones.\n                  // (This is OK for rayscans, but never do it for other bodies.)\n                  body.pathDurationMax = eventOut.time - this.now;\n                }\n                otherBody.unfreeze();\n              }\n              i++;\n            } else {\n              pathIdSet.removeIndex(i);\n            }\n          }\n        }\n      }\n    }\n  }\n  return retval;\n};\n\n/**\n * Gets the instantaneous overlaps of a body with the objects in the world, at world.now.\n * Takes the body's hitGtoup into account, but not its path duration.\n * @param {Body} body  the query, as a Body.\n * @return {Array.<String>} body IDs\n */\nWorld.prototype.getOverlaps = function(body) {\n  var retval = [];\n  this.validateBodies();\n  this.scannedBodyIds.reset();\n  var brect = this.getPaddedBodyBoundingRect(body, this.now, Rect.alloc());\n  var range = this.getCellRangeForRect(brect, CellRange.alloc());\n  for (var iy = range.p0.y; iy <= range.p1.y; iy++) {\n    for (var ix = range.p0.x; ix <= range.p1.x; ix++) {\n      var cell = this.getCell(ix, iy);\n      if (cell) {\n        var hitGroups = this.groupHitsGroups[body.hitGroup];\n        for (var gi = 0; gi < hitGroups.length; gi++) {\n          var otherGroup = hitGroups[gi];\n          var pathIdSet = cell.getPathIdsForGroup(otherGroup);\n          var pathIdArray = pathIdSet.vals;\n          for (var pi = 0; pi < pathIdArray.length;) {\n            var pathId = pathIdArray[pi];\n            var otherBody = this.paths[pathId];\n            if (otherBody && otherBody.pathId == pathId) {\n              if (!this.scannedBodyIds.contains(otherBody.id)) {\n                this.scannedBodyIds.put(otherBody.id);\n                if (OverlapDetector.isBodyOverlappingBodyAtTime(body, otherBody, this.now)) {\n                  retval.push(otherBody.id);\n                }\n              }\n              pi++;\n            } else {\n              // opportunistically erase obsolete path from cell\n              pathIdSet.removeIndex(pi);\n            }\n          }\n        }\n      }\n    }\n  }\n  brect.free();\n  range.free();\n  return retval;\n};\n\nWorld.prototype.getPaddedBodyBoundingRect = function(body, time, rectOut) {\n  return body.getBoundingRectAtTime(time, rectOut).pad(this.cellSize * World.BRECT_FUDGE_FACTOR)\n}\n\n\n/**\n * A union of all the world event types and their fields, as a SkipList node.\n * @constructor\n */\nfunction WorldEvent() {\n  this.next = [];\n  this.cellRange = new CellRange(0, 0, -1, -1);\n\n  // This is a vector along which collision acceleration should be applied,\n  // for default elastic collision resolution.\n  this.collisionVec = new Vec2d();\n  this.reset();\n}\n\n// Only for TYPE_TIMEOUT events so far.\nWorldEvent.SCHEMA = {\n  0: 'time',\n  1: 'type',\n  2: 'spiritId',\n  3: 'timeoutVal'\n};\n\nWorldEvent.getJsoner = function() {\n  if (!WorldEvent.jsoner) {\n    WorldEvent.jsoner = new Jsoner(WorldEvent.SCHEMA);\n  }\n  return WorldEvent.jsoner;\n};\n\nWorldEvent.prototype.toJSON = function() {\n  return WorldEvent.getJsoner().toJSON(this);\n};\n\nWorldEvent.prototype.setFromJSON = function(json) {\n  WorldEvent.getJsoner().setFromJSON(json, this);\n};\n\nWorldEvent.TYPE_TIMEOUT = 'timeout';\nWorldEvent.TYPE_GRID_ENTER = 'enter';\nWorldEvent.TYPE_GRID_EXIT = 'exit';\nWorldEvent.TYPE_HIT = 'hit';\n\nWorldEvent.prototype.reset = function() {\n  // SkipQueue node stuff\n  this.time = 0;\n  this.next.length = 0;\n\n  // Which kind of event is it? One of the TYPE constants.\n  this.type = 0;\n\n  // timeout fields\n  this.spiritId = 0;\n  this.timeoutVal = null;\n\n  // grid enter/exit cell range\n  this.axis = null; // one of Vec2d.X or Vec2d.Y\n  this.pathId = 0;\n  this.cellRange.reset();\n\n  // hit fields\n  this.pathId0 = 0;\n  this.pathId1 = 0;\n  this.collisionVec.reset();\n  // this.axis, if set, means there was a hit on a side of a rectangle. X means it was east or west, Y is N or S.\n\n  return this;\n};\n\nWorldEvent.pool = [];\n\nWorldEvent.alloc = function() {\n  if (WorldEvent.pool.length) {\n    return WorldEvent.pool.pop().reset();\n  }\n  return new WorldEvent();\n};\n\nWorldEvent.prototype.free = function() {\n  WorldEvent.pool.push(this);\n};\n\nWorldEvent.prototype.toString = function() {\n  var s = [];\n  s.push('{time: ', this.time, ', type: ', this.type);\n  if (this.type === WorldEvent.TYPE_TIMEOUT) {\n    s.push(', spiritId: ', this.spiritId, ', timeoutVal: ', this.timeoutVal);\n  } else if (this.type === WorldEvent.TYPE_GRID_ENTER || this.type === WorldEvent.TYPE_GRID_EXIT) {\n    s.push(', pathId: ', this.pathId, ', axis: ' + this.axis, ', cellRange: ' + JSON.stringify(this.cellRange));\n  } else if (this.type === WorldEvent.TYPE_HIT) {\n    s.push(', pathId0: ', this.pathId0, ', pathId1: ', this.pathId1);\n  }\n  s.push('}');\n  return s.join('');\n};\n\n\n\n/**\n * Rayscan Request.\n * A rayscan is like a body that travels from pos to pos+vel, instantly,\n * reporting back on the first thing it hits.\n * @constructor\n */\nfunction ScanRequest() {\n  this.pos = new Vec2d();\n  this.vel = new Vec2d();\n  this.rectRad = new Vec2d();\n  this.reset();\n}\n\nScanRequest.prototype.reset = function() {\n  this.hitGroup = -1;\n  this.pos.reset();\n  this.vel.reset();\n  this.shape = Body.Shape.CIRCLE;\n  this.rad = 1;\n  this.rectRad.reset();\n};\n\nPoolify(ScanRequest);\n\n\n\n/**\n * A ScanResponse holds the result of a World.rayscan.\n * @constructor\n */\nfunction ScanResponse() {\n  this.collisionVec = new Vec2d();\n  this.reset();\n}\n\nScanResponse.prototype.reset = function() {\n  this.timeOffset = 0; // zero to one\n  this.pathId = 0;\n  this.collisionVec.reset();\n};\n\nPoolify(ScanResponse);\n\n\n\n/**\n * Utils for producing sound effects positioned in 3D.\n * @param {=AudioContext} opt_audioContext\n * @constructor\n */\nfunction SoundFx(opt_audioContext) {\n  this.ctx = opt_audioContext || SoundFx.getAudioContext();\n  if (this.ctx) {\n    if (!(this.ctx.createGain || this.ctx.createGainNode) || !this.ctx.createOscillator) {\n      this.ctx = null;\n    }\n  }\n  if (this.ctx) {\n    this.masterGain = this.createGain();\n    this.masterGain.connect(this.ctx.destination);\n  }\n}\n\nSoundFx.audioContext = null;\n\nSoundFx.getAudioContext = function() {\n  if (SoundFx.audioContext != null) {\n    return SoundFx.audioContext;\n  } else if (typeof AudioContext !== 'undefined') {\n    SoundFx.audioContext = new AudioContext();\n  } else if (typeof webkitAudioContext !== 'undefined') {\n    SoundFx.audioContext = new webkitAudioContext();\n  }\n  return SoundFx.audioContext;\n};\n\nSoundFx.prototype.createGain = function() {\n  if (this.ctx.createGain) {\n    return this.ctx.createGain();\n  }\n  if (this.ctx.createGainNode) {\n    return this.ctx.createGainNode();\n  }\n  return null;\n};\n\nSoundFx.prototype.setListenerXYZ = function(x, y, z) {\n  if (!this.ctx) return;\n  this.ctx.listener.setPosition(x, y, z);\n};\n\nSoundFx.prototype.getMasterGain = function() {\n  return this.masterGain;\n};\n\n/**\n * Make a simple one-shot sound.\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @param {number} vol\n * @param {number} attack\n * @param {number} sustain\n * @param {number} decay\n * @param {number} freq1\n * @param {number} freq2\n * @param {String} type Wave type string (square, sine, etc)\n */\nSoundFx.prototype.sound = function(x, y, z, vol, attack, sustain, decay, freq1, freq2, type, opt_delay) {\n  if (!this.ctx) return;\n  var delay = opt_delay || 0;\n  var c = this.ctx;\n  var t0 = c.currentTime + delay;\n  var t1 = t0 + attack + sustain + decay;\n  var gain = this.createGain();\n  if (attack) {\n    gain.gain.setValueAtTime(0.001, t0);\n    gain.gain.exponentialRampToValueAtTime(vol, t0 + attack);\n  }\n  gain.gain.setValueAtTime(vol, t0 + attack);\n  if (sustain) {\n    gain.gain.setValueAtTime(vol, t0 + attack + sustain);\n  }\n  if (decay) {\n    gain.gain.exponentialRampToValueAtTime(0.01, t0 + attack + sustain + decay);\n  }\n\n  var osc = c.createOscillator();\n  osc.frequency.setValueAtTime(freq1, t0);\n  osc.frequency.exponentialRampToValueAtTime(freq2, t0 + attack + sustain + decay);\n  osc.type = type;\n  if (osc.start) {\n    osc.start(t0);\n  } else if (osc.noteOn) {\n    osc.noteOn(t0);\n  }\n  if (osc.stop) {\n    osc.stop(t1);\n  } else if (osc.noteOff) {\n    osc.noteOff(t1);\n  }\n\n  var panner = c.createPanner();\n  panner.setPosition(x, y, z);\n\n  osc.connect(gain);\n  gain.connect(panner);\n  panner.connect(this.masterGain);\n};\n\n/**\n * Makes a sound with no attack, decay, or frequency changes.\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @param {number} vol\n * @param {number} sustain\n * @param {number} freq\n * @param {String} opt_type Wave type string (square, sine, etc). Default is sine\n */\nSoundFx.prototype.note = function(x, y, z, vol, sustain, freq, opt_type) {\n  var type = opt_type || 'sine';\n  this.sound(x, y, z, vol, 0, sustain, 0, freq, freq, type);\n}\n\nSoundFx.prototype.disconnect = function() {\n  if (this.masterGain) {\n    this.masterGain.gain = 0;\n    this.masterGain.disconnect();\n    this.masterGain = null;\n  }\n};\n\n\n\n\n/**\n * @param {string} name\n * @param {number} keyCode\n * @constructor\n */\nfunction Key(name, keyCode) {\n  this.name = name;\n  this.keyCode = keyCode;\n}\n\n/**\n * Names of keys that don't always have a\n * readable single character representation.\n * @enum {string}\n */\nKey.Name = {\n  UP: 'up',\n  DOWN: 'down',\n  LEFT: 'left',\n  RIGHT: 'right',\n  BACKSPACE: 'backspace',\n  DELETE: 'delete',\n  SPACE: 'space',\n  SEMICOLON: ';',\n  BACKSLASH: '\\\\',\n  ESC: 'esc'\n};\n\n\n\n/**\n * Associates numeric keycodes with programmer-friendly names.\n * @constructor\n */\nfunction Keys() {\n  // Index the keys by both fields.\n  this.byKeyCode = {};\n  this.byName = {};\n  this.initialized = false;\n}\n\nKeys.prototype.getKeyCodeForName = function(name) {\n  if (!this.initialized) this.initKeys();\n  var key = this.byName[name];\n  return key ? key.keyCode : null;\n};\n\nKeys.prototype.getNameForKeyCode = function(keyCode) {\n  if (!this.initialized) this.initKeys();\n  var key = this.byKeyCode[keyCode];\n  return key ? key.name : null;\n};\n\n/**\n *  Add all letters, numbers, and Key.Name values to byKeyCode and byName indexes.\n */\nKeys.prototype.initKeys = function() {\n  var self = this;\n\n  function addKey(name, keyCode) {\n    var key = new Key(name, keyCode);\n    self.byName[name] = key;\n    self.byKeyCode[keyCode] = key;\n  }\n\n  function addKeySequence(firstChar, firstKeyCode, lastChar) {\n    var firstCharCode = firstChar.charCodeAt(0);\n    var lastCharCode = lastChar.charCodeAt(0);\n    if (firstCharCode > lastCharCode) throw Error(firstChar + ' > ' + lastChar);\n    var keyCode = firstKeyCode;\n    for (var charCode = firstCharCode; charCode <= lastCharCode; charCode++) {\n      addKey(String.fromCharCode(charCode), keyCode);\n      keyCode++;\n    }\n  }\n  addKeySequence('a', 65, 'z');\n  addKeySequence('0', 48, '9');\n\n  addKey(Key.Name.LEFT, 37);\n  addKey(Key.Name.UP, 38);\n  addKey(Key.Name.RIGHT, 39);\n  addKey(Key.Name.DOWN, 40);\n\n  addKey(Key.Name.BACKSPACE, 8);\n  addKey(Key.Name.DELETE, 46);\n  addKey(Key.Name.SPACE, 32);\n\n  addKey(Key.Name.SEMICOLON, 186);\n  addKey(Key.Name.BACKSLASH, 220);\n\n  addKey(Key.Name.ESC, 27);\n\n  this.initialized = true;\n};\n\n\n/**\n * @constructor\n */\nfunction PointerEvent() {\n  this.pos = new Vec2d();\n  this.reset();\n}\n\n/** touch start, and mouse down */\nPointerEvent.TYPE_DOWN = 1;\n\n/** touch move and mouse move */\nPointerEvent.TYPE_MOVE = 2;\n\n/** touch end+cancel+leave, and mouse up */\nPointerEvent.TYPE_UP = 3;\n\nPointerEvent.prototype.reset = function() {\n  this.type = null;\n  this.pointerId = null;\n  this.time = 0;\n  this.pos.reset();\n  return this;\n};\n\nPointerEvent.pool = [];\n\nPointerEvent.alloc = function() {\n  if (PointerEvent.pool.length) {\n    return PointerEvent.pool.pop().reset();\n  }\n  return new PointerEvent();\n};\n\nPointerEvent.prototype.free = function() {\n  PointerEvent.pool.push(this);\n};\n\n\n\n/**\n * Control trackball base class\n * @constructor\n */\nfunction Trackball() {\n  this.val = new Vec2d();\n  this.friction = 0.05;\n  this.touched = false;\n}\n\nTrackball.prototype.setFriction = function(f) {\n  this.friction = f;\n  return this;\n};\n\n/**\n * @param {Vec2d} out\n * @return {Vec2d} out\n */\nTrackball.prototype.getVal = function(out) {\n  return out.set(this.val);\n};\n\n/**\n * Resets the delta between the old position and the new. Use in the event loop\n * after everyone's had a chance to read the trackball val, to prepare\n * to accumulate delta events before the next iteration.\n */\nTrackball.prototype.reset = function() {console.log(\"reset unimplimented\")};\n\nTrackball.prototype.isTouched = function() {\n  return this.touched;\n};\n\nTrackball.prototype.startListening = function() {console.log(\"startListening unimplimented\")};\nTrackball.prototype.stopListening = function() {console.log(\"stopListening unimplimented\")};\n\n\n\n/**\n * Control stick base class\n * @constructor\n */\nfunction Stick() {\n  this.val = new Vec2d();\n}\n\n/**\n * @param {Vec2d} out\n * @return {Vec2d} out\n */\nStick.prototype.getVal = function(out) {\n  return out.set(this.val);\n};\n\n/**\n * If the stick value is greater than one, scale it down to one.\n * @return {Vec2d}\n */\nStick.prototype.clip = function() {\n  return this.val.clipToMaxLength(1);\n};\n\n\n\n/**\n * A control stick based on a keyboard.\n * @constructor\n * @extends {Stick}\n */\nfunction KeyStick() {\n  Stick.call(this);\n  this.codeToDir = {};\n  this.codeToState = {};\n  this.keys = new Keys();\n\n  var self = this;\n  this.downListener = function(e) {\n    if (!e) e = window.event;\n    if (self.codeToDir[e.keyCode]) {\n      self.codeToState[e.keyCode] = true;\n    }\n  };\n  this.upListener = function(e) {\n    if (!e) e = window.event;\n    if (self.codeToDir[e.keyCode]) {\n      self.codeToState[e.keyCode] = false;\n    }\n  };\n}\n\nKeyStick.prototype = new Stick();\nKeyStick.prototype.constructor = KeyStick;\n\nKeyStick.UP = new Vec2d(0, 1);\nKeyStick.RIGHT = new Vec2d(1, 0);\nKeyStick.DOWN = new Vec2d(0, -1);\nKeyStick.LEFT = new Vec2d(-1, 0);\n\nKeyStick.prototype.setByKeyCode = function(keyCode, vec) {\n  this.codeToDir[keyCode] = vec;\n  return this;\n};\n\nKeyStick.prototype.setByName = function(name, vec) {\n  var keyCode = this.keys.getKeyCodeForName(name);\n  this.setByKeyCode(keyCode, vec);\n  return this;\n};\n\nKeyStick.prototype.setUpRightDownLeftByName = function(up, right, down, left) {\n  this.setByName(up, KeyStick.UP);\n  this.setByName(right, KeyStick.RIGHT);\n  this.setByName(down, KeyStick.DOWN);\n  this.setByName(left, KeyStick.LEFT);\n  return this;\n};\n\nKeyStick.prototype.startListening = function() {\n  document.addEventListener('keydown', this.downListener);\n  document.addEventListener('keyup', this.upListener);\n  return this;\n};\n\nKeyStick.prototype.stopListening = function() {\n  document.removeEventListener('keydown', this.downListener);\n  document.removeEventListener('keyup', this.upListener);\n  return this;\n};\n\nKeyStick.prototype.getVal = function(out) {\n  this.val.reset();\n  for (var code in this.codeToState) {\n    if (this.codeToState[code]) {\n      this.val.add(this.codeToDir[code]);\n    }\n  }\n  this.clip();\n  return out.set(this.val);\n};\n\nKeyStick.prototype.isAnyKeyPressed = function() {\n  for (var code in this.codeToState) {\n    if (this.codeToState[code]) {\n      return true;;\n    }\n  }\n  return false;\n};\n\n\n\n/**\n * A control trackball using up/down/left/right keys.\n * @constructor\n * @extends {Trackball}\n */\nfunction KeyTrackball(keyStick) {\n  Trackball.call(this);\n  this.keyStick = keyStick;\n  this.needsValChange = true;\n  this.accel = 0.3;\n  this.wasTouched = false;\n}\nKeyTrackball.prototype = new Trackball();\nKeyTrackball.prototype.constructor = KeyTrackball;\n\n\nKeyTrackball.prototype.setAccel = function(a) {\n  this.accel = a;\n  return this;\n};\n\n/**\n * @param {Vec2d} out\n * @return {Vec2d} out\n */\nKeyTrackball.prototype.getVal = function(out) {\n  if (!this.wasTouched) {\n    this.val.reset();\n  } else if (this.needsValChange) {\n    this.needsValChange = false;\n    this.keyStick.getVal(out);\n    if (out.isZero() && this.isTouched()) {\n      // Opposite keys are touched. Slam the brakes.\n      this.val.scale(0.5);\n    } else {\n      this.val.scale(0.95).add(out.scale(this.accel));\n    }\n  }\n  this.wasTouched = this.isTouched();\n  return out.set(this.val);\n};\n\nKeyTrackball.prototype.reset = function() {\n  if (!this.isTouched()) {\n    this.val.scale(1 - this.friction);\n  }\n  this.needsValChange = true;\n};\n\nKeyTrackball.prototype.isTouched = function() {\n  var touched = this.keyStick.isAnyKeyPressed();\n  if (!touched) this.wasTouched = false;\n  return touched;\n};\n\nKeyTrackball.prototype.startListening = function() {\n  this.keyStick.startListening();\n};\n\nKeyTrackball.prototype.stopListening = function() {\n  this.keyStick.stopListening();\n};\n\n\n\n/**\n * A control trackball for a mouse or trackpad.\n * This is intended for use with pointerlock, but it does not handle pointer lock itself.\n * @constructor\n * @extends {Trackball}\n */\nfunction MouseTrackball(opt_elem) {\n  Trackball.call(this);\n\n  this.elem = opt_elem || document.body;\n  var self = this;\n  this.listening = false;\n  this.mouseMotion = new Vec2d();\n  this.touched = false;\n  this.speed = 0.05;\n  this.mouseMoveListener = function(e) {\n    self.onMouseMove(e);\n  };\n  this.mouseDownListener = function(e) {\n    self.onMouseDown(e);\n  };\n}\n\nMouseTrackball.prototype = new Trackball();\nMouseTrackball.prototype.constructor = MouseTrackball;\n\nMouseTrackball.prototype.startListening = function() {\n  this.elem.addEventListener('mousemove', this.mouseMoveListener);\n  this.elem.addEventListener('mousedown', this.mouseDownListener);\n  this.listening = true;\n  return this;\n};\n\nMouseTrackball.prototype.stopListening = function() {\n  this.elem.removeEventListener('mousemove', this.mouseMoveListener);\n  this.elem.removeEventListener('mousedown', this.mouseDownListener);\n  this.listening = false;\n  return this;\n};\n\nMouseTrackball.prototype.reset = function() {\n  if (!this.touched) {\n    this.val.scale(1 - this.friction);\n  }\n  this.mouseMotion.reset();\n  this.touched = false;\n};\n\nMouseTrackball.prototype.onMouseMove = function(e) {\n  var dx = e.movementX || e.mozMovementX || e.webkitMovementX || 0;\n  var dy = e.movementY || e.mozMovementY || e.webkitMovementY || 0;\n  this.mouseMotion.addXY(dx * this.speed, dy * this.speed);\n  this.val.set(this.mouseMotion);\n  this.touched = true;\n};\n\nMouseTrackball.prototype.onMouseDown = function(e) {\n  this.val.reset();\n  this.touched = true;\n};\n\n\n\n/**\n * A control trackball using a touchscreen.\n * @constructor\n * @extends {Trackball}\n */\nfunction TouchTrackball(opt_elem) {\n  Trackball.call(this);\n  this.elem = opt_elem || document.body;\n  this.oldPagePos = new Vec2d();\n  this.touched = false;\n\n  this.pixelMultiplier = 0.2;\n\n  this.dirtyVal = false;\n  this.startZoneFn = function(x, y) {\n    return true;\n  };\n\n  var self = this;\n\n  // When this is null, we're not tracking a touch.\n  this.touchId = null;\n\n  this.touchStartListener = function(e) {\n    self.onTouchStart(e);\n  };\n  this.touchMoveListener = function(e) {\n    self.onTouchMove(e);\n  };\n  this.touchEndListener = function(e) {\n    self.onTouchEnd(e);\n  };\n}\n\nTouchTrackball.prototype = new Trackball();\nTouchTrackball.prototype.constructor = TouchTrackball;\n\nTouchTrackball.prototype.setStartZoneFunction = function(fn) {\n  this.startZoneFn = fn;\n  return this;\n};\n\nTouchTrackball.prototype.startListening = function() {\n  this.elem.addEventListener('touchstart', this.touchStartListener);\n  this.elem.addEventListener('touchmove', this.touchMoveListener);\n  this.elem.addEventListener('touchend', this.touchEndListener);\n  this.elem.addEventListener('touchcancel', this.touchEndListener);\n  return this;\n};\n\nTouchTrackball.prototype.stopListening = function() {\n  this.elem.removeEventListener('touchstart', this.touchStartListener);\n  this.elem.removeEventListener('touchmove', this.touchMoveListener);\n  this.elem.removeEventListener('touchend', this.touchEndListener);\n  this.elem.removeEventListener('touchcancel', this.touchEndListener);\n  this.touchId = null;\n  return this;\n};\n\nTouchTrackball.prototype.onTouchStart = function(e) {\n  if (this.touchId !== null) return;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (this.startZoneFn(touch.pageX, touch.pageY)) {\n      // Start tracking this one.\n      this.touchId = touch.identifier;\n      this.val.reset();\n      this.oldPagePos.setXY(touch.pageX, touch.pageY);\n      this.touched = true;\n      break;\n    }\n  }\n};\n\nTouchTrackball.prototype.onTouchMove = function(e) {\n  if (this.touchId === null) return;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (touch.identifier == this.touchId) {\n      // Keep tracking this one.\n      if (this.dirtyVal) {\n        this.val.reset();\n        this.dirtyVal = false;\n      }\n      var velocity = Vec2d.alloc(touch.pageX - this.oldPagePos.x, touch.pageY - this.oldPagePos.y)\n          .scale(this.pixelMultiplier);\n      this.val.add(velocity);\n      this.oldPagePos.setXY(touch.pageX, touch.pageY);\n      break;\n    }\n  }\n};\n\nTouchTrackball.prototype.onTouchEnd = function(e) {\n  if (this.touchId === null) return;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (touch.identifier == this.touchId) {\n      this.touchId = null;\n      this.touched = false;\n      break;\n    }\n  }\n};\n\nTouchTrackball.prototype.reset = function() {\n  if (!this.touched) {\n    this.val.scale(1 - this.friction);\n  } else {\n    if (this.dirtyVal) {\n      // Touched, but there were no events in the last iteration.\n      // Tap the brakes.\n      this.val.scale(0.5);\n    }\n  }\n  this.dirtyVal = true;\n};\n\n\n\n/**\n * A control trackball that combines other trackball inputs into one.\n * @constructor\n * @extends {Trackball}\n */\nfunction MultiTrackball() {\n  Trackball.call(this);\n  this.trackballs = [];\n  this.temp = new Vec2d();\n}\nMultiTrackball.prototype = new Trackball();\nMultiTrackball.prototype.constructor = MultiTrackball;\n\nMultiTrackball.prototype.addTrackball = function(t) {\n  this.trackballs.push(t);\n  return this;\n};\n\nMultiTrackball.prototype.startListening = function() {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].startListening();\n  }\n};\n\nMultiTrackball.prototype.stopListening = function() {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].stopListening();\n  }\n};\n\nMultiTrackball.prototype.setFriction = function(f) {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].setFriction(f);\n  }\n  return this;\n};\n\nMultiTrackball.prototype.getVal = function(out) {\n  this.val.reset();\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].getVal(this.temp);\n    this.val.add(this.temp);\n  }\n  return out.set(this.val);\n};\n\nMultiTrackball.prototype.reset = function() {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].reset();\n  }\n};\n\nMultiTrackball.prototype.isTouched = function() {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    if (this.trackballs[i].isTouched()) return true;\n  }\n  return false;\n};\n\n\n\n/**\n * Control trigger base class\n * @constructor\n */\nfunction Trigger() {\n  this.val = false;\n  this.downPubSub = new PubSub();\n  this.upPubSub = new PubSub();\n}\n\n/**\n * @return {boolean}\n */\nTrigger.prototype.getVal = function() {\n  return this.val;\n};\n\nTrigger.prototype.startListening = function() {console.log(\"startListening unimplimented\")};\nTrigger.prototype.stopListening = function() {console.log(\"stopListening unimplimented\")};\n\n\nTrigger.prototype.addTriggerDownListener = function(fn) {\n  this.downPubSub.subscribe(fn);\n};\n\nTrigger.prototype.removeTriggerDownListener = function(fn) {\n  this.downPubSub.unsubscribe(fn);\n};\n\n\nTrigger.prototype.addTriggerUpListener = function(fn) {\n  this.upPubSub.subscribe(fn);\n};\nTrigger.prototype.removeTriggerUpListener = function(fn) {\n  this.upPubSub.unsubscribe(fn);\n};\n\n\nTrigger.prototype.publishTriggerDown = function(e) {\n  this.downPubSub.publish(e);\n};\n\nTrigger.prototype.publishTriggerUp = function(e) {\n  this.upPubSub.publish(e);\n};\n\n\n\n/**\n * A single control Trigger, using keyboard keys.\n * @constructor\n * @extends {Trigger}\n */\nfunction KeyTrigger() {\n  Trigger.call(this);\n\n  this.keys = new Keys();\n  this.triggerKeyCodes = {};\n  this.codeToState = {};\n\n  var self = this;\n  this.downListener = function(e) {\n    if (!e) e = window.event;\n    if (self.triggerKeyCodes[e.keyCode]) {\n      var oldVal = self.getVal();\n      self.codeToState[e.keyCode] = true;\n      if (!oldVal) self.publishTriggerDown(e);\n    }\n  };\n  this.upListener = function(e) {\n    if (!e) e = window.event;\n    if (self.triggerKeyCodes[e.keyCode]) {\n      var oldVal = self.getVal();\n      self.codeToState[e.keyCode] = false;\n      if (oldVal && !self.getVal()) self.publishTriggerUp(e);\n    }\n  };\n}\n\nKeyTrigger.prototype = new Trigger();\nKeyTrigger.prototype.constructor = KeyTrigger;\n\nKeyTrigger.prototype.addTriggerKeyByCode = function(keyCode) {\n  this.triggerKeyCodes[keyCode] = true;\n  return this;\n};\n\nKeyTrigger.prototype.addTriggerKeyByName = function(name) {\n  var keyCode = this.keys.getKeyCodeForName(name);\n  return this.addTriggerKeyByCode(keyCode);\n};\n\nKeyTrigger.prototype.startListening = function() {\n  document.addEventListener('keydown', this.downListener);\n  document.addEventListener('keyup', this.upListener);\n  return this;\n};\n\nKeyTrigger.prototype.stopListening = function() {\n  document.removeEventListener('keydown', this.downListener);\n  document.removeEventListener('keyup', this.upListener);\n  for (var code in this.codeToState) {\n    this.codeToState[code] = false;\n  }\n  return this;\n};\n\nKeyTrigger.prototype.getVal = function() {\n  for (var code in this.codeToState) {\n    if (this.codeToState[code]) return true;\n  }\n};\n\n\n/**\n * A single control Trigger, using the left mouse button.\n * @constructor\n * @extends {Trigger}\n */\nfunction MouseButtonTrigger(elem) {\n  Trigger.call(this);\n  this.elem = elem || document;\n  var self = this;\n  this.downListener = function(e) {\n    if (!e) e = window.event;\n    if (MouseButtonTrigger.isLeftButton(e)) {\n      self.val = true;\n      self.publishTriggerDown(e);\n\n      // For LayeredEventDistributor\n      return false;\n    }\n  };\n  this.upListener = function(e) {\n    if (!e) e = window.event;\n    if (MouseButtonTrigger.isLeftButton(e)) {\n      self.val = false;\n      self.publishTriggerUp(e);\n\n      // For LayeredEventDistributor\n      return false;\n    }\n  };\n}\n\nMouseButtonTrigger.prototype = new Trigger();\nMouseButtonTrigger.prototype.constructor = MouseButtonTrigger;\n\nMouseButtonTrigger.isLeftButton = function(e) {\n  if (e.buttons) {\n    return !!(e.buttons & 1);\n  } else if ((typeof e.button) != 'undefined') {\n    return e.button == 0;\n  } else {\n    return e.which == 1;\n  }\n};\n\nMouseButtonTrigger.prototype.startListening = function() {\n  this.elem.addEventListener('mousedown', this.downListener);\n  this.elem.addEventListener('mouseup', this.upListener);\n  return this;\n};\n\nMouseButtonTrigger.prototype.stopListening = function() {\n  this.elem.removeEventListener('mousedown', this.downListener);\n  this.elem.removeEventListener('mouseup', this.upListener);\n  this.val = false;\n  return this;\n};\n\nMouseButtonTrigger.prototype.getVal = function() {\n  return this.val;\n};\n\n\n/**\n * A control Trigger using a touchscreen.\n * @constructor\n * @extends {Trigger}\n */\nfunction TouchTrigger(opt_elem) {\n  Trigger.call(this);\n  this.listening = false;\n  this.elem = opt_elem || document.body;\n\n  this.startZoneFn = function(x, y) {\n    return true;\n  };\n  this.touchId = null;\n\n  var self = this;\n  this.touchStartListener = function(e) {\n    return self.onTouchStart(e);\n  };\n  this.touchEndListener = function(e) {\n    return self.onTouchEnd(e);\n  };\n}\n\nTouchTrigger.prototype = new Trigger();\nTouchTrigger.prototype.constructor = TouchTrigger;\n\n/**\n * @param {function} fn  A function that takes screen coords (x, y) and returns true if the coords are\n * within the touch trigger start zone.\n * @returns {TouchTrigger}\n */\nTouchTrigger.prototype.setStartZoneFunction = function(fn) {\n  this.startZoneFn = fn;\n  return this;\n};\n\nTouchTrigger.prototype.startListening = function() {\n  this.elem.addEventListener('touchstart', this.touchStartListener);\n  this.elem.addEventListener('touchend', this.touchEndListener);\n  this.elem.addEventListener('touchcancel', this.touchEndListener);\n  return this;\n};\n\nTouchTrigger.prototype.stopListening = function() {\n  this.elem.removeEventListener('touchstart', this.touchStartListener);\n  this.elem.removeEventListener('touchend', this.touchEndListener);\n  this.elem.removeEventListener('touchcancel', this.touchEndListener);\n  this.touchId = null;\n  this.val = false;\n  return this;\n};\n\nTouchTrigger.prototype.onTouchStart = function(e) {\n  if (this.touchId !== null) return;\n  e = e || window.event;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (this.startZoneFn(touch.pageX, touch.pageY)) {\n      // Start tracking this one.\n      this.touchId = touch.identifier;\n      this.val = true;\n      this.publishTriggerDown(e);\n\n      // For LayeredEventDistributor\n      return false;\n    }\n  }\n};\n\nTouchTrigger.prototype.onTouchEnd = function(e) {\n  if (this.touchId === null) return;\n  e = e || window.event;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (touch.identifier == this.touchId) {\n      this.touchId = null;\n      this.val = false;\n      this.publishTriggerUp(e);\n\n      // Never claim to have handled a touchEnd, because touch events contain multiple\n      // touches, and if a trigger touch and a world touch end at the same time, then\n      // the LayeredEventDistributor will refuse to tell the world touch about the end.\n      return true;\n    }\n  }\n};\n\n\n\n/**\n * A control trigger that combines other trigger inputs into one.\n * @constructor\n * @extends {Trigger}\n */\nfunction MultiTrigger() {\n  Trigger.call(this);\n  this.triggers = [];\n  this.oldVal = false;\n\n  var self = this;\n  this.downListener = function(e) {\n    if (!self.oldVal && self.getVal()) {\n      self.publishTriggerDown(e);\n      self.oldVal = true;\n    }\n  };\n  this.upListener = function(e) {\n    if (self.oldVal && !self.getVal()) {\n      self.publishTriggerUp(e);\n      self.oldVal = false;\n    }\n  };\n}\nMultiTrigger.prototype = new Trigger();\nMultiTrigger.prototype.constructor = MultiTrigger;\n\nMultiTrigger.prototype.addTrigger = function(t) {\n  this.triggers.push(t);\n  t.addTriggerDownListener(this.downListener);\n  t.addTriggerUpListener(this.upListener);\n  return this;\n};\n\nMultiTrigger.prototype.startListening = function() {\n  for (var i = 0; i < this.triggers.length; i++) {\n    this.triggers[i].startListening();\n  }\n};\n\nMultiTrigger.prototype.stopListening = function() {\n  for (var i = 0; i < this.triggers.length; i++) {\n    this.triggers[i].stopListening();\n  }\n};\n\nMultiTrigger.prototype.getVal = function() {\n  for (var i = 0; i < this.triggers.length; i++) {\n    if (this.triggers[i].getVal()) return true;\n  }\n  return false;\n};\n\nMultiTrigger.prototype.addTriggerDownListener = function(fn) {\n  this.downPubSub.subscribe(fn);\n};\n\nMultiTrigger.prototype.removeTriggerDownListener = function(fn) {\n  this.downPubSub.unsubscribe(fn);\n};\n\n\nMultiTrigger.prototype.addTriggerUpListener = function(fn) {\n  this.upPubSub.subscribe(fn);\n};\nMultiTrigger.prototype.removeTriggerUpListener = function(fn) {\n  this.upPubSub.unsubscribe(fn);\n};\n\n\nMultiTrigger.prototype.publishTriggerDown = function(e) {\n  this.downPubSub.publish(e);\n};\n\nMultiTrigger.prototype.publishTriggerUp = function(e) {\n  this.upPubSub.publish(e);\n};\n\n\n\n/**\n * Detects that the user is using touch (vs keys/mouse), so we can decide to show touch UI, or not.\n * @constructor\n */\nfunction TouchDetector() {\n  this.listening = false;\n  this.score = 0;\n\n  var self = this;\n  this.touchListener = function() {\n    self.score = Math.min(5, self.score + 0.1);\n  };\n}\n\nTouchDetector.prototype = new Trigger();\nTouchDetector.prototype.constructor = TouchDetector;\n\nTouchDetector.prototype.startListening = function() {\n  document.body.addEventListener('touchstart', this.touchListener);\n  document.body.addEventListener('touchmove', this.touchListener);\n  document.body.addEventListener('touchend', this.touchListener);\n  document.body.addEventListener('touchcancel', this.touchListener);\n  return this;\n};\n\nTouchDetector.prototype.stopListening = function() {\n  document.body.removeEventListener('touchstart', this.touchListener);\n  document.body.removeEventListener('touchmove', this.touchListener);\n  document.body.removeEventListener('touchend', this.touchListener);\n  document.body.removeEventListener('touchcancel', this.touchListener);\n  this.val = 0;\n  return this;\n};\n\n\nTouchDetector.prototype.decrease = function() {\n  this.score = Math.max(0, this.score - 0.01);\n};\n\nTouchDetector.prototype.getVal = function() {\n  return Math.max(0, Math.min(1, this.score));\n};\n\n\n\n\n/**\n * @constructor\n * @extends {Spirit}\n */\nfunction BallSpirit(playScreen) {\n  Spirit.call(this);\n  this.playScreen = playScreen;\n  this.bodyId = -1;\n  this.id = -1;\n  this.modelStamp = null;\n  this.color = new Vec4();\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.modelMatrix = new Matrix44();\n}\nBallSpirit.prototype = new Spirit();\nBallSpirit.prototype.constructor = BallSpirit;\n\nBallSpirit.prototype.setModelStamp = function(modelStamp) {\n  this.modelStamp = modelStamp;\n};\n\nBallSpirit.prototype.setColorRGB = function(r, g, b) {\n  this.color.setXYZ(r, g, b);\n};\n\nBallSpirit.prototype.onDraw = function(world, renderer) {\n  var body = this.getBody(world);\n  var bodyPos = body.getPosAtTime(world.now, this.vec2d);\n  renderer\n      .setStamp(this.modelStamp)\n      .setColorVector(this.color);\n  this.modelMatrix.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(bodyPos.x, bodyPos.y, 0))\n      .multiply(this.mat44.toScaleOpXYZ(body.rad, body.rad, 1));\n\n  renderer.setModelMatrix(this.modelMatrix);\n  renderer.drawStamp();\n};\n\nBallSpirit.prototype.onTimeout = function(world, timeout) {\n  world.removeBodyId(this.bodyId);\n  world.removeSpiritId(this.id);\n};\n\nBallSpirit.prototype.getBody = function(world) {\n  return world.bodies[this.bodyId];\n};\n\n\n\n/**\n * @constructor\n * @extends {Spirit}\n */\nfunction EnemySpirit(playScreen) {\n  Spirit.call(this);\n  this.playScreen = playScreen;\n  this.bodyId = -1;\n  this.id = -1;\n  this.modelStamp = null;\n  this.color = new Vec4();\n  this.tempBodyPos = new Vec2d();\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.modelMatrix = new Matrix44();\n  this.turn = 0;\n}\nEnemySpirit.prototype = new Spirit();\nEnemySpirit.prototype.constructor = EnemySpirit;\n\nEnemySpirit.FIRE_TIMEOUT = 64;\nEnemySpirit.MOVE_TIMEOUT = 32;\nEnemySpirit.MISSILE_SPEED = 5;\n\nEnemySpirit.prototype.setModelStamp = function(modelStamp) {\n  this.modelStamp = modelStamp;\n};\n\nEnemySpirit.prototype.setColorRGB = function(r, g, b) {\n  this.color.setXYZ(r, g, b);\n};\n\nEnemySpirit.prototype.onTimeout = function(world) {\n  var body = this.getBody(world);\n  var friction = Vec2d.alloc().set(body.vel).scale(-0.04);\n  // turn, but gradually correct to straight-ahead\n  this.turn += (Math.random() - 0.5) * 0.2;\n  this.turn *= 0.99;\n  // do the turn and also jiggle a bit\n  var thrust = Vec2d.alloc()\n      .set(body.vel).scaleToLength(0.07).rot(this.turn)\n      .addXY((Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2);\n  body.setVelAtTime(this.vec2d.set(body.vel)\n      .add(friction.scale(EnemySpirit.MOVE_TIMEOUT))\n      .add(thrust.scale(EnemySpirit.MOVE_TIMEOUT)),\n      world.now);\n  friction.free();\n  thrust.free();\n\n  if (!this.fireTime) {\n    this.fireTime = world.now + EnemySpirit.FIRE_TIMEOUT;\n  }\n  if (world.now >= this.fireTime) {\n    body.getPosAtTime(world.now, this.tempBodyPos);\n    var vecToPlayer = this.playScreen.scanForPlayer(this.tempBodyPos, this.vec2d);\n    if (vecToPlayer) {\n      this.playScreen.enemyFire(this.tempBodyPos, vecToPlayer.scaleToLength(EnemySpirit.MISSILE_SPEED));\n    }\n    this.fireTime = world.now + EnemySpirit.FIRE_TIMEOUT;\n  }\n\n  var wait = EnemySpirit.MOVE_TIMEOUT;\n  world.addTimeout(world.now + wait, this.id);\n};\n\nEnemySpirit.prototype.onDraw = function(world, renderer) {\n  var body = this.getBody(world);\n  body.getPosAtTime(world.now, this.tempBodyPos);\n  renderer\n      .setStamp(this.modelStamp)\n      .setColorVector(this.color);\n  this.modelMatrix.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(this.tempBodyPos.x, this.tempBodyPos.y, 0))\n      .multiply(this.mat44.toScaleOpXYZ(body.rad, body.rad, 1));\n  renderer.setModelMatrix(this.modelMatrix);\n  renderer.drawStamp();\n};\n\nEnemySpirit.prototype.getBody = function(world) {\n  return world.bodies[this.bodyId];\n};\n\n\n\n/**\n * @constructor\n * @extends {Spirit}\n */\nfunction ButtonSpirit() {\n  Spirit.call(this);\n  this.bodyId = -1;\n  this.id = -1;\n  this.modelStamp = null;\n\n  this.color = new Vec4();\n  this.lastSoundMs = 0;\n  this.soundLength = 1;\n  this.onClick = null;\n\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.modelMatrix = new Matrix44();\n}\nButtonSpirit.prototype = new Spirit();\nButtonSpirit.prototype.constructor = ButtonSpirit;\n\nButtonSpirit.POINTER_RADIUS = 0.0;\n\nButtonSpirit.prototype.setModelStamp = function(modelStamp) {\n  this.modelStamp = modelStamp;\n};\n\n/**\n * @param {function} func  A function of (e)\n */\nButtonSpirit.prototype.setOnClick = function(func) {\n  this.onClick = func;\n};\n\nButtonSpirit.prototype.onDraw = function(world, renderer) {\n  var life = 0;\n  if (Date.now() - this.lastSoundMs < this.soundLength) {\n    life = 1 - (Date.now() - this.lastSoundMs) / this.soundLength;\n    var t = Date.now() / 300;\n    this.color.setXYZ(\n            1 + life * Math.sin(t + 0),\n            1 + life * Math.sin(t + 2*Math.PI/3),\n            1 + life * Math.sin(t + 2*2*Math.PI/3));\n  } else {\n    this.color.setXYZ(1, 1, 1);\n  }\n  var body = this.getBody(world);\n  var bodyPos = body.getPosAtTime(world.now, this.vec2d);\n  renderer\n      .setStamp(this.modelStamp)\n      .setColorVector(this.color);\n  this.modelMatrix.toTranslateOpXYZ(bodyPos.x, bodyPos.y, 0);\n  renderer.setModelMatrix(this.modelMatrix);\n  renderer.drawStamp();\n  this.animating = !!life;\n};\n\nButtonSpirit.prototype.getBody = function(world) {\n  return world.bodies[this.bodyId];\n};\n\nButtonSpirit.prototype.isOverlapping = function(world, pointerPos) {\n  var body = this.getBody(world);\n  var bodyPos = body.getPosAtTime(world.now, this.vec2d);\n  return OverlapDetector.isRectOverlappingCircle(\n      bodyPos, body.rectRad, pointerPos, ButtonSpirit.POINTER_RADIUS);\n};\n\n\n\n\n/**\n * @constructor\n * @extends {Screen}\n */\nfunction BaseScreen(controller, canvas, renderer, glyphs, stamps, sound) {\n  Screen.call(this);\n  this.controller = controller;\n  this.canvas = canvas;\n  this.renderer = renderer;\n  this.glyphs = glyphs;\n  this.stamps = stamps;\n  this.sfx = sound;\n\n  this.viewMatrix = new Matrix44();\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat4 = new Matrix44();\n  this.nextButtonNum = 0;\n  this.worldBoundingRect = new Rect();\n\n  this.lastPathRefreshTime = -Infinity;\n  this.visibility = 0;\n  this.listening = false;\n\n  this.spacebarFn = this.getSpacebarFn();\n  this.mouseDownFn = this.getMouseDownFn();\n  this.touchStartFn = this.getTouchStartFn();\n  this.resizeFn = this.getResizeFn();\n\n  this.clipToWorldMatrix = new Matrix44();\n  this.clipToWorldMatrixDirty = true;\n  this.canvasToClipMatrix = new Matrix44();\n  this.canvasToClipMatrixDirty = true;\n}\nBaseScreen.prototype = new Screen();\nBaseScreen.prototype.constructor = BaseScreen;\n\nBaseScreen.prototype.onSpaceDown = null;\nBaseScreen.prototype.onPointerDown = null;\n\nBaseScreen.prototype.getSpacebarFn = function() {\n  var self = this;\n  return function(e) {\n    // space is keyCode 32\n    if (e.keyCode == 32 && self.onSpaceDown) {\n      self.onSpaceDown();\n    }\n  };\n};\n\nBaseScreen.prototype.getMouseDownFn = function() {\n  var self = this;\n  return function(e) {\n    if (self.onPointerDown) {\n      self.onPointerDown(e.pageX, e.pageY);\n    }\n  };\n};\n\nBaseScreen.prototype.getTouchStartFn = function() {\n  var self = this;\n  return function(e) {\n    if (self.onPointerDown) {\n      var touches = e.changedTouches;\n      for (var i = 0; i < touches.length; i++) {\n        var touch = touches[i];\n        self.onPointerDown(touch.pageX, touch.pageY);\n      }\n    }\n  };\n};\n\nBaseScreen.prototype.getResizeFn = function() {\n  var self = this;\n  return function() {\n    self.controller.requestAnimation();\n  }\n};\n\nBaseScreen.prototype.setScreenListening = function(listen) {\n  if (listen == this.listening) return;\n  if (listen) {\n    document.body.addEventListener('mousedown', this.mouseDownFn);\n    document.body.addEventListener('touchstart', this.touchStartFn);\n    document.body.addEventListener('keydown', this.spacebarFn);\n    window.addEventListener('resize', this.resizeFn);\n  } else {\n    document.body.removeEventListener('mousedown', this.mouseDownFn);\n    document.body.removeEventListener('touchstart', this.touchStartFn);\n    document.body.removeEventListener('keydown', this.spacebarFn);\n    window.removeEventListener('resize', this.resizeFn);\n  }\n  this.listening = listen;\n};\n\nBaseScreen.prototype.drawScreen = function(visibility) {\n  this.visibility = visibility;\n  this.lazyInit();\n  if (this.visibility == 1) {\n    this.clock();\n  }\n  this.updateViewMatrix(Date.now());\n  this.drawScene();\n  this.canvasToClipMatrixDirty = true;\n  this.clipToWorldMatrixDirty = true;\n};\n\nBaseScreen.prototype.getClipToWorldMatrix = function() {\n  if (this.clipToWorldMatrixDirty) {\n    this.viewMatrix.getInverse(this.clipToWorldMatrix);\n    this.clipToWorldMatrixDirty = false;\n  }\n  return this.clipToWorldMatrix;\n};\n\nBaseScreen.prototype.getCanvasToClipMatrix = function() {\n  if (this.canvasToClipMatrixDirty) {\n    this.canvasToClipMatrix.toScaleOpXYZ(2 / this.canvas.width, -2 / this.canvas.height, 1);\n    this.canvasToClipMatrix.multiply(this.mat4.toTranslateOpXYZ(-this.canvas.width / 2, -this.canvas.height / 2, 0));\n    this.canvasToClipMatrixDirty = false;\n  }\n  return this.canvasToClipMatrix;\n};\n\n/**\n * Transforms a vec2d in place.\n * @param {Vec2d} vec2d\n * @returns {Vec2d}\n */\nBaseScreen.prototype.transformCanvasToWorld = function(vec2d) {\n  this.vec4\n      .setXYZ(vec2d.x, vec2d.y, 0)\n      .transform(this.getCanvasToClipMatrix())\n      .transform(this.getClipToWorldMatrix());\n  return vec2d.setXY(this.vec4.v[0], this.vec4.v[1]);\n};\n\nBaseScreen.prototype.drawScene = function() {\n  var animationRequested = false;\n  for (var id in this.world.spirits) {\n    var spirit = this.world.spirits[id];\n    spirit.onDraw(this.world, this.renderer);\n    if (!animationRequested && spirit.animating) {\n      this.controller.requestAnimation();\n      animationRequested = true;\n    }\n  }\n};\n\nBaseScreen.prototype.destroyScreen = function() {\n  // Unload button models? Need a nice utility for loading, remembering, and unloading models.\n};\n\nBaseScreen.prototype.clock = function() {\n  var endTimeMs = Date.now() + MS_PER_FRAME;\n  var endClock = this.world.now + CLOCKS_PER_FRAME;\n\n  if (this.handleInput) {\n    this.handleInput();\n  }\n\n  if (this.lastPathRefreshTime + PATH_DURATION <= endClock) {\n    this.lastPathRefreshTime = this.world.now;\n    for (var id in this.world.bodies) {\n      var b = this.world.bodies[id];\n      if (b && b.pathDurationMax > PATH_DURATION && b.pathDurationMax != Infinity) {\n        b.invalidatePath();\n        b.moveToTime(this.world.now);\n      }\n    }\n  }\n\n  var e = this.world.getNextEvent();\n  // Stop if there are no more events to process, or we've moved the game clock far enough ahead\n  // to match the amount of wall-time elapsed since the last frame,\n  // or (worst case) we're out of time for this frame.\n\n  while (e && e.time <= endClock && Date.now() <= endTimeMs) {\n    this.world.processNextEvent();\n    if (e.type == WorldEvent.TYPE_HIT) {\n      this.onHitEvent(e);\n    }\n    e = this.world.getNextEvent();\n  }\n  if (!e || e.time > endClock) {\n    this.world.now = endClock;\n  }\n};\n\nBaseScreen.prototype.onHitEvent = function(e) {};\n\n\n\n/**\n * @constructor\n * @extends {BaseScreen}\n */\nfunction TitleScreen(controller, canvas, renderer, glyphs, stamps, sound) {\n  BaseScreen.call(this, controller, canvas, renderer, glyphs, stamps, sound);\n}\nTitleScreen.prototype = new BaseScreen();\nTitleScreen.prototype.constructor = TitleScreen;\n\nTitleScreen.prototype.lazyInit = function() {\n  if (!this.world) {\n    this.initWorld();\n  }\n};\n\nTitleScreen.prototype.initWorld = function() {\n  this.world = new World(World.DEFAULT_CELL_SIZE, 2, [[0, 0], [1, 1]]);\n  this.resolver = new HitResolver();\n  this.resolver.defaultElasticity = 0.9;\n  var labelMaker = new LabelMaker(this.glyphs);\n  var controller = this.controller;\n  var sfx = this.sfx;\n  var world = this.world;\n\n  var buttonMaker = new ButtonMaker(labelMaker, this.world, null, this.renderer);\n  buttonMaker\n      .setNextCharMatrix(new Matrix44().toTranslateOpXYZ(3, 0, 0))\n      .setPaddingXY(1.5, 0.5);\n\n  // TITLE\n  buttonMaker.setLetterColor([0.25*0.7, 0.75*0.7, 1*0.7]).setBlockColor(null).setScale(1.5);\n  var spiritId = buttonMaker.addButton(0, 0, \"GAME 1\", null);\n  buttonMaker.setScale(1);\n\n  // PLAY\n  buttonMaker.setLetterColor([0.25, 0.75, 1]).setBlockColor([0.25*0.5, 0.75*0.5, 1*0.5]);\n  spiritId = buttonMaker.addButton(0, -8, \"PLAY\", function(e) {\n    var freq0 = 100;\n    var freq1 = 5000;\n    var delay = 0;\n    var attack = 0.01;\n    var sustain = 0.1;\n    var decay = 0.04;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.gotoScreen(Game1.SCREEN_PLAY);\n    controller.requestPointerLock();\n  });\n  this.playSpirit = this.world.spirits[spiritId];\n\n  // FULL SCREEN\n  buttonMaker.setScale(0.75);\n  var spiritId = buttonMaker.addButton(0, -8 -6, \"FULL SCREEN\", function(e) {\n    var freq0 = 200;\n    var freq1 = 2200;\n    var delay = 0;\n    var attack = 0.05;\n    var sustain = 0.1;\n    var decay = 0.2;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.requestFullScreen();\n  });\n  this.fullScreenSpirit = world.spirits[spiritId];\n\n  for (var spiritId in this.world.spirits) {\n    var s = this.world.spirits[spiritId];\n    var b = this.world.bodies[s.bodyId];\n    this.worldBoundingRect.coverRect(b.getBoundingRectAtTime(this.world.now));\n  }\n};\n\nTitleScreen.prototype.onSpaceDown = function() {\n  this.playSpirit.onClick();\n};\n\nTitleScreen.prototype.onPointerDown = function(pageX, pageY) {\n  this.vec2d.setXY(pageX, pageY);\n  this.transformCanvasToWorld(this.vec2d);\n  if (this.playSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.playSpirit.onClick();\n  }\n  if (this.fullScreenSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.fullScreenSpirit.onClick();\n  }\n};\n\nTitleScreen.prototype.updateViewMatrix = function() {\n  var br = this.worldBoundingRect;\n  this.viewMatrix.toIdentity();\n  var ratio = Math.min(this.canvas.height, this.canvas.width) / Math.max(br.rad.x, br.rad.y);\n  this.viewMatrix\n      .multiply(this.mat4.toScaleOpXYZ(\n              ratio / this.canvas.width,\n              ratio / this.canvas.height,\n              0.2));\n\n  // scale\n  var v = this.visibility;\n  this.viewMatrix.multiply(this.mat4.toScaleOpXYZ(3 - v*2, v * v, 1));\n\n  // center\n  this.viewMatrix.multiply(this.mat4.toTranslateOpXYZ(\n      -br.pos.x,\n      -br.pos.y,\n      0));\n\n  this.renderer.setViewMatrix(this.viewMatrix);\n};\n\n\n\n/**\n * @constructor\n * @extends {BaseScreen}\n */\nfunction PlayScreen(controller, canvas, renderer, glyphs, stamps, sound) {\n  BaseScreen.call(this, controller, canvas, renderer, glyphs, stamps, sound);\n\n  // temp\n  this.splash = new Splash();\n\n  this.trackball = new MultiTrackball()\n      .addTrackball(new MouseTrackball())\n      .addTrackball(new TouchTrackball().setStartZoneFunction(function(x, y) {\n        return Vec2d.distance(x, y, self.triggerPixelX, self.triggerPixelY) > self.triggerPixelRad;\n      }))\n      .addTrackball(new KeyTrackball(new KeyStick().setUpRightDownLeftByName(\n          Key.Name.DOWN, Key.Name.RIGHT, Key.Name.UP, Key.Name.LEFT)));\n  this.trackball.setFriction(0.02);\n  this.movement = new Vec2d();\n\n  this.touchDetector = new TouchDetector();\n  this.setTouchTriggerArea();\n  var self = this;\n  this.trigger = new MultiTrigger()\n      .addTrigger((new KeyTrigger()).addTriggerKeyByName('z'))\n      .addTrigger(new MouseButtonTrigger())\n      .addTrigger(new TouchTrigger().setStartZoneFunction(function(x, y) {\n        return Vec2d.distance(x, y, self.triggerPixelX, self.triggerPixelY) <= self.triggerPixelRad;\n      }));\n\n  // for sound throttling\n  this.hitsThisFrame = 0;\n\n  this.world = null;\n  this.tiles = null;\n  this.tempPlayerPos = new Vec2d();\n  this.lastPlayerFireTime = 0;\n  this.aim = new Vec2d();\n\n  this.camera = new Camera(0.06, 0.2, 500);\n  this.pixelSize = 4;\n  this.levelModelMatrix = new Matrix44();\n  this.levelColorVector = new Vec4(1, 1, 1);\n\n  this.colorVector = new Vec4();\n  this.modelMatrix = new Matrix44();\n  this.mat44 = new Matrix44();\n  this.hudViewMatrix = new Matrix44();\n\n  this.playerThrustSum = 0;\n}\n\n\nPlayScreen.prototype = new BaseScreen();\nPlayScreen.prototype.constructor = PlayScreen;\n\nPlayScreen.WORLD_CELL_SIZE = 4 * 32;\n\nPlayScreen.ENEMY_RAD = 8;\nPlayScreen.ENEMY_MISSILE_RAD = 5;\n\nPlayScreen.PLAYER_RAD = 8;\nPlayScreen.PLAYER_MISSILE_RAD = 5;\nPlayScreen.PLAYER_FIRE_DELAY = 7;\nPlayScreen.PLAYER_MIN_SPEED_TO_FIRE = 0.01;\nPlayScreen.PLAYER_MISSILE_SPEED = 15;\nPlayScreen.PLAYER_MISSILE_DURATION = 10;\n\n\nPlayScreen.Group = {\n  EMPTY: 0,\n  WALL: 1,\n  ROCK: 2,\n  PLAYER: 3,\n  PLAYER_MISSILE: 4,\n  ENEMY: 5,\n  ENEMY_MISSILE: 6\n};\n\nPlayScreen.Terrain = {\n  WALL: 0,\n  FLOOR: 1,\n  MIXED: 2\n};\n\nPlayScreen.SplashType = {\n  PLAYER_TRAIL: 1,\n  EXPLOSION: 2,\n  TERRAIN_DUST: 3\n};\n\n\nPlayScreen.prototype.setTouchTriggerArea = function() {\n  this.triggerPixelRad = 0.5 * (this.canvas.width + this.canvas.height) * 0.17;\n  this.visibleTriggerScale = 2/3 * this.touchDetector.getVal();\n  this.triggerPixelX = this.triggerPixelRad * 0.6;\n  this.triggerPixelY = this.canvas.height - this.triggerPixelRad * 0.6;\n};\n\nPlayScreen.prototype.onPointerDown = function(pageX, pageY) {\n  if (Vec2d.distance(pageX, pageY, this.canvas.width/2, 0) < Math.min(this.canvas.height, this.canvas.width)/4) {\n    this.pauseGame();\n  } else {\n    this.controller.requestPointerLock();\n  }\n};\n\nPlayScreen.prototype.onSpaceDown = function() {\n  this.pauseGame();\n};\n\nPlayScreen.prototype.setScreenListening = function(listen) {\n  if (listen == this.listening) return;\n  BaseScreen.prototype.setScreenListening.call(this, listen);\n  if (listen) {\n    this.trackball.startListening();\n    this.trigger.startListening();\n    this.touchDetector.startListening();\n  } else {\n    this.trackball.stopListening();\n    this.trigger.stopListening();\n    this.touchDetector.stopListening();\n  }\n  this.listening = listen;\n};\n\nPlayScreen.prototype.pauseGame = function() {\n  var freq0 = 3000;\n  var freq1 = 30;\n  var delay = 0;\n  var attack = 0.05;\n  var sustain = 0.15;\n  var decay = 0.01;\n  this.sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n  this.controller.exitPointerLock();\n  this.controller.gotoScreen(Game1.SCREEN_PAUSE);\n};\n\nPlayScreen.prototype.lazyInit = function() {\n  if (!this.levelStamps) {\n    this.initPermStamps();\n  }\n  if (!this.world) {\n    this.initWorld();\n  }\n  if (!this.splasher) {\n    this.splasher = new Splasher();\n  }\n};\n\nPlayScreen.prototype.initPermStamps = function() {\n  this.levelStamps = [];\n\n  this.cubeStamp = RigidModel.createCube().createModelStamp(this.renderer.gl);\n  this.levelStamps.push(this.cubeStamp);\n\n  var circleModel = RigidModel.createCircleMesh(5);\n  this.circleStamp = circleModel.createModelStamp(this.renderer.gl);\n  this.levelStamps.push(this.circleStamp);\n\n  var sphereModel = RigidModel.createOctahedron()\n      .createQuadrupleTriangleModel()\n      .createQuadrupleTriangleModel()\n      .createQuadrupleTriangleModel()\n      .sphereize(Vec4.ZERO, 1);\n  this.sphereStamp = sphereModel.createModelStamp(this.renderer.gl);\n  this.levelStamps.push(this.sphereStamp);\n};\n\nPlayScreen.prototype.initWorld = function() {\n  this.lastPathRefreshTime = -Infinity;\n  var groupCount = Object.keys(PlayScreen.Group).length;\n  this.world = new World(PlayScreen.WORLD_CELL_SIZE, groupCount, [\n    [PlayScreen.Group.EMPTY, PlayScreen.Group.EMPTY],\n    [PlayScreen.Group.ROCK, PlayScreen.Group.WALL],\n    [PlayScreen.Group.ROCK, PlayScreen.Group.ROCK],\n    [PlayScreen.Group.PLAYER, PlayScreen.Group.WALL],\n    [PlayScreen.Group.PLAYER, PlayScreen.Group.ROCK],\n    [PlayScreen.Group.PLAYER_MISSILE, PlayScreen.Group.WALL],\n    [PlayScreen.Group.PLAYER_MISSILE, PlayScreen.Group.ROCK],\n    [PlayScreen.Group.ENEMY, PlayScreen.Group.WALL],\n    [PlayScreen.Group.ENEMY, PlayScreen.Group.ROCK],\n    [PlayScreen.Group.ENEMY, PlayScreen.Group.PLAYER],\n    [PlayScreen.Group.ENEMY, PlayScreen.Group.PLAYER_MISSILE],\n    [PlayScreen.Group.ENEMY, PlayScreen.Group.ENEMY],\n    [PlayScreen.Group.ENEMY_MISSILE, PlayScreen.Group.WALL],\n    [PlayScreen.Group.ENEMY_MISSILE, PlayScreen.Group.ROCK],\n    [PlayScreen.Group.ENEMY_MISSILE, PlayScreen.Group.PLAYER]\n  ]);\n  this.lastPlayerFireTime = 0;\n  this.resolver = new HitResolver();\n  this.resolver.defaultElasticity = 0.8;\n  this.initBoulder(new Vec2d(135, -125));\n  this.initBoulder(new Vec2d(-135, -125));\n  this.initCreatures();\n  this.initWalls();\n};\n\nPlayScreen.prototype.initCreatures = function() {\n  this.playerSpiritId = this.initPlayer(0, 30, PlayScreen.PLAYER_RAD, 1,\n      2, 0.2, 1.5,\n      this.sphereStamp);\n\n  var maxEnemies = 8;\n  for (var i = 0; i < maxEnemies; i++) {\n    var r = 6 * i/maxEnemies + 2;\n    this.initEnemy(\n            Math.sin(Math.PI * 2 * i/maxEnemies) * (120-r),\n            Math.cos(Math.PI * 2 * i/maxEnemies) * (120-r));\n  }\n};\n\nPlayScreen.prototype.initEnemy = function(x, y) {\n  var rad = PlayScreen.ENEMY_RAD;\n  var density = 1;\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.setPosXYAtTime(x, y, this.world.now);\n  b.rad = rad;\n  b.hitGroup = PlayScreen.Group.ENEMY;\n  b.mass = (Math.PI * 4/3) * b.rad * b.rad * b.rad * density;\n  b.pathDurationMax = EnemySpirit.MOVE_TIMEOUT * 1.01;\n  var spirit = new EnemySpirit(this);\n  spirit.bodyId = this.world.addBody(b);\n  spirit.setModelStamp(this.sphereStamp);\n  var spiritId = this.world.addSpirit(spirit);\n  b.spiritId = spiritId;\n  this.world.spirits[spiritId].setColorRGB(0.2, 1, 0.6);\n  this.world.spirits[spiritId].onTimeout(this.world);\n  return spiritId;\n};\n\nPlayScreen.prototype.initEnemyMissile = function(pos, vel) {\n  var density = 2;\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.setPosAtTime(pos, this.world.now);\n  b.setVelAtTime(vel, this.world.now);\n  b.rad = PlayScreen.ENEMY_MISSILE_RAD;\n  b.hitGroup = PlayScreen.Group.ENEMY_MISSILE;\n  b.mass = (Math.PI * 4/3) * b.rad * b.rad * b.rad * density;\n  b.pathDurationMax = Infinity;\n  var spirit = new BallSpirit(); // TODO EnemyBulletSpirit?\n  spirit.bodyId = this.world.addBody(b);\n  spirit.setModelStamp(this.sphereStamp);\n  var spiritId = this.world.addSpirit(spirit);\n  b.spiritId = spiritId;\n  this.world.spirits[spiritId].setColorRGB(1, 1, 0);\n  return spiritId;\n};\n\nPlayScreen.prototype.initPlayerMissile = function(pos, vel) {\n  var density = 2;\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.setPosAtTime(pos, this.world.now);\n  b.setVelAtTime(vel, this.world.now);\n  b.rad = PlayScreen.PLAYER_MISSILE_RAD;\n  b.hitGroup = PlayScreen.Group.PLAYER_MISSILE;\n  b.mass = (Math.PI * 4/3) * b.rad * b.rad * b.rad * density;\n  b.pathDurationMax = PlayScreen.PLAYER_MISSILE_DURATION;\n  var spirit = new BallSpirit();\n  spirit.bodyId = this.world.addBody(b);\n  spirit.setModelStamp(this.sphereStamp);\n  var spiritId = this.world.addSpirit(spirit);\n  b.spiritId = spiritId;\n  this.world.spirits[spiritId].setColorRGB(1, 0, 0.5);\n  this.world.addTimeout(this.world.now + PlayScreen.PLAYER_MISSILE_DURATION, spiritId);\n  return spiritId;\n};\n\nPlayScreen.prototype.initBoulder = function(pos) {\n  var density = 1;\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.setPosAtTime(pos, this.world.now);\n  b.rad = 30;\n  b.hitGroup = PlayScreen.Group.ROCK;\n  b.mass = (Math.PI * 4/3) * b.rad * b.rad * b.rad * density;\n  b.pathDurationMax = Infinity;\n  var spirit = new BallSpirit();\n  spirit.bodyId = this.world.addBody(b);\n  spirit.setModelStamp(this.sphereStamp);\n  var spiritId = this.world.addSpirit(spirit);\n  b.spiritId = spiritId;\n  this.world.spirits[spiritId].setColorRGB(0.5, 0.5, 0.5);\n  return spiritId;\n};\n\nPlayScreen.prototype.initPlayer = function(x, y, rad, density, red, green, blue, stamp) {\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.setPosXYAtTime(x, y, this.world.now);\n  b.rad = rad;\n  b.hitGroup = PlayScreen.Group.PLAYER;\n  b.mass = (Math.PI * 4/3) * b.rad * b.rad * b.rad * density;\n  // TODO: add friction, fix path durations\n  b.pathDurationMax = PATH_DURATION * 1.1;\n  var spirit = new BallSpirit();\n  spirit.bodyId = this.world.addBody(b);\n  spirit.setModelStamp(stamp);\n  var spiritId = this.world.addSpirit(spirit);\n  this.world.spirits[spiritId].setColorRGB(red, green, blue);\n  return spiritId;\n};\n\nPlayScreen.prototype.initWalls = function() {\n  var rad = 100;\n\n  this.bitGrid = new BitGrid(this.pixelSize);\n\n  this.bitGrid.drawPill(new Segment(new Vec2d(-rad*1.2, -rad), new Vec2d(0, 0.8 * rad)), rad, 1);\n  this.bitGrid.drawPill(new Segment(new Vec2d(0, 0.8 * rad), new Vec2d(rad*1.2, -rad)), rad, 1);\n  this.bitGrid.drawPill(new Segment(new Vec2d(-rad*1.2, -rad), new Vec2d(rad*1.2, -rad)), rad, 1);\n\n  this.bitGrid.drawPill(new Segment(new Vec2d(-rad * 2.15, rad), new Vec2d(-rad * 2.15, rad)), rad*1.2, 1);\n  this.bitGrid.drawPill(new Segment(new Vec2d(rad * 2.15, rad), new Vec2d(rad * 2.15, rad)), rad*1.2, 1);\n\n  this.bitGrid.drawPill(new Segment(new Vec2d(-rad * 2.15, rad), new Vec2d(-rad * 2.15, rad)), rad*0.5, 0);\n  this.bitGrid.drawPill(new Segment(new Vec2d(rad * 2.15, rad), new Vec2d(rad * 2.15, rad)), rad*0.9, 0);\n\n  this.bitGrid.drawPill(new Segment(new Vec2d(rad/2, -rad/4), new Vec2d(-rad/4, -rad/2)), rad/3, 0);\n\n  this.tiles = {};\n  var changedCellIds = this.bitGrid.flushChangedCellIds();\n  for (var i = 0; i < changedCellIds.length; i++) {\n    this.changeTerrain(changedCellIds[i]);\n  }\n};\n\nPlayScreen.prototype.digTerrainAtPos = function(pos) {\n  this.bitGrid.drawPill(new Segment(pos, pos), 15, 1);\n  var changedCellIds = this.bitGrid.flushChangedCellIds();\n  for (var i = 0; i < changedCellIds.length; i++) {\n    this.changeTerrain(changedCellIds[i]);\n  }\n  this.addDiggingDust(pos.x, pos.y);\n};\n\n/**\n * The cell at the cellId definitely changes, so unload it and reload it.\n * Make sure the four cardinal neighbors are also loaded.\n * @param cellId\n */\nPlayScreen.prototype.changeTerrain = function(cellId) {\n  var center = Vec2d.alloc();\n  this.bitGrid.cellIdToIndexVec(cellId, center);\n  this.loadCellXY(center.x - 1, center.y);\n  this.loadCellXY(center.x + 1, center.y);\n  this.loadCellXY(center.x, center.y - 1);\n  this.loadCellXY(center.x, center.y + 1);\n  this.unloadCellXY(center.x, center.y);\n  this.loadCellXY(center.x, center.y);\n  center.free();\n};\n\nPlayScreen.prototype.loadCellXY = function(cx, cy) {\n  var cellId = this.bitGrid.getCellIdAtIndexXY(cx, cy);\n  var tile = this.tiles[cellId];\n  if (!tile) {\n    this.tiles[cellId] = tile = {\n      cellId: cellId,\n      stamp: null,\n      bodyIds: null\n    };\n  }\n  if (!tile.bodyIds) {\n    tile.bodyIds = [];\n    // Create wall bodies and remember their IDs.\n    var rects = this.bitGrid.getRectsOfColorForCellId(0, cellId);\n    for (var r = 0; r < rects.length; r++) {\n      var rect = rects[r];\n      var body = this.createWallBody(rect);\n      tile.bodyIds.push(this.world.addBody(body));\n    }\n  }\n  // TODO don't repeat stamp for solid walls\n  if (!tile.stamp) {\n    if (!rects) rects = this.bitGrid.getRectsOfColorForCellId(0, cellId);\n    tile.stamp = this.createTileStamp(rects);\n  }\n};\n\nPlayScreen.prototype.unloadCellXY = function(cx, cy) {\n  this.unloadCellId(this.bitGrid.getCellIdAtIndexXY(cx, cy));\n};\n\nPlayScreen.prototype.unloadCellId = function(cellId) {\n  var tile = this.tiles[cellId];\n  if (!tile) return;\n  if (tile.stamp) {\n    tile.stamp.dispose(this.renderer.gl);\n    tile.stamp = null;\n  }\n  if (tile.bodyIds) {\n    for (var i = 0; i < tile.bodyIds.length; i++) {\n      var id = tile.bodyIds[i];\n      this.world.removeBodyId(id);\n    }\n    tile.bodyIds = null;\n  }\n};\n\n/**\n * Creates but DOES NOT ADD the body to the world\n */\nPlayScreen.prototype.createWallBody = function(rect) {\n  var b = Body.alloc();\n  b.shape = Body.Shape.RECT;\n  b.setPosAtTime(rect.pos, this.world.now);\n  b.rectRad.set(rect.rad);\n  b.hitGroup = PlayScreen.Group.WALL;\n  b.mass = Infinity;\n  b.pathDurationMax = Infinity;\n  return b;\n};\n\nPlayScreen.prototype.createTileStamp = function(rects) {\n  var model = new RigidModel();\n  for (var i = 0; i < rects.length; i++) {\n    model.addRigidModel(this.createWallModel(rects[i]));\n  }\n  return model.createModelStamp(this.renderer.gl);\n};\n\nPlayScreen.prototype.createWallModel = function(rect) {\n  var transformation, wallModel;\n  transformation = new Matrix44()\n      .toTranslateOpXYZ(rect.pos.x, rect.pos.y, 0)\n      .multiply(new Matrix44().toScaleOpXYZ(rect.rad.x, rect.rad.y, 1));\n  wallModel = RigidModel.createSquare().transformPositions(transformation);\n  wallModel.setColorRGB(0.6, 0.5, 0.3);\n  return wallModel;\n};\n\nPlayScreen.prototype.handleInput = function() {\n  if (!this.world) return;\n\n  this.setTouchTriggerArea();\n  var triggered = this.trigger.getVal();\n\n  var spirit = this.world.spirits[this.playerSpiritId];\n  var body = this.world.bodies[spirit.bodyId];\n  var newVel = Vec2d.alloc();\n  if (this.trackball.isTouched()) {\n    this.trackball.getVal(this.movement);\n    var sensitivity = 4;\n    this.movement.scale(sensitivity);\n    newVel.setXY(this.movement.x, -this.movement.y);\n\n    var accel = Vec2d.alloc().set(newVel).subtract(body.vel);\n    var maxAccel = 10;\n    accel.clipToMaxLength(maxAccel);\n\n    // Firing makes you much less maneuverable\n    if (triggered) accel.scale(0.1);\n\n    newVel.set(body.vel).add(accel);\n    body.setVelAtTime(newVel, this.world.now);\n    this.playerThrustSum += this.movement.magnitude();\n    accel.free();\n  }\n\n  if (!triggered) {\n    this.aim.reset();\n  } else {\n    if (true || this.aim.isZero()) {\n      var missileVel = this.trackball.getVal(this.movement).scaleXY(1, -1);\n      var missileVelMag = missileVel.magnitude();\n      if (missileVelMag > PlayScreen.PLAYER_MIN_SPEED_TO_FIRE) {\n        this.aim.set(missileVel).scaleToLength(PlayScreen.PLAYER_MISSILE_SPEED);\n      }\n    }\n    if (this.world.now >= this.lastPlayerFireTime + PlayScreen.PLAYER_FIRE_DELAY && !this.aim.isZero()) {\n      this.playerFire(this.getPlayerPos(), this.aim);\n      this.lastPlayerFireTime = this.world.now;\n    }\n  }\n\n  newVel.free();\n\n  this.trackball.reset();\n};\n\nPlayScreen.prototype.onHitEvent = function(e) {\n  var b0 = this.world.getBodyByPathId(e.pathId0);\n  var b1 = this.world.getBodyByPathId(e.pathId1);\n\n  if (b0 && b1) {\n    this.resolver.resolveHit(e.time, e.collisionVec, b0, b1);\n    var strikeVec = Vec2d.alloc().set(b1.vel).subtract(b0.vel).projectOnto(e.collisionVec);\n    var mag = strikeVec.magnitude();\n    this.hitsThisFrame++;\n    if (this.hitsThisFrame < 4) {\n      this.bonk(b0, mag);\n      this.bonk(b1, mag);\n    }\n    strikeVec.free();\n\n    var enemyMissileBody = this.bodyIfInGroup(PlayScreen.Group.ENEMY_MISSILE, b0, b1);\n    if (enemyMissileBody) {\n      var playerBody = this.bodyIfInGroup(PlayScreen.Group.PLAYER, b0, b1);\n      if (playerBody) {\n        this.soundKaboom(this.getBodyPos(playerBody));\n        this.soundKaboom(this.getBodyPos(playerBody));\n        this.loseLife();\n      } else {\n        this.soundBing(this.getBodyPos(enemyMissileBody));\n        this.digTerrainAtPos(this.getBodyPos(enemyMissileBody));\n      }\n      this.world.removeBodyId(enemyMissileBody.id);\n      this.world.removeSpiritId(enemyMissileBody.spiritId);\n    }\n\n    var playerMissileBody = this.bodyIfInGroup(PlayScreen.Group.PLAYER_MISSILE, b0, b1);\n    if (playerMissileBody) {\n      var enemyBody = this.bodyIfInGroup(PlayScreen.Group.ENEMY, b0, b1);\n      if (enemyBody) {\n        var pos = this.getBodyPos(enemyBody);\n        this.soundKaboom(pos);\n        this.world.removeSpiritId(enemyBody.spiritId);\n        this.world.removeBodyId(enemyBody.id);\n        this.addEnemyExplosion(pos.x, pos.y);\n      } else {\n        this.soundBing(this.getBodyPos(playerMissileBody));\n        this.digTerrainAtPos(this.getBodyPos(playerMissileBody));\n      }\n      this.world.removeSpiritId(playerMissileBody.spiritId);\n      this.world.removeBodyId(playerMissileBody.id);\n    }\n  }\n};\n\nPlayScreen.prototype.loseLife = function() {\n  this.restarting = true;\n};\n\nPlayScreen.prototype.bodyIfInGroup = function(group, b0, b1) {\n  if (b0 && b0.hitGroup == group) return b0;\n  if (b1 && b1.hitGroup == group) return b1;\n  return null;\n};\n\nPlayScreen.prototype.bonk = function(body, mag) {\n  var bodyPos = Vec2d.alloc();\n  body.getPosAtTime(this.world.now, bodyPos);\n  this.vec4.setXYZ(bodyPos.x, bodyPos.y, 0);\n  this.vec4.transform(this.viewMatrix);\n  if (body.shape == Body.Shape.RECT) {\n    this.soundWallThump(bodyPos, mag);\n  } else {\n    this.soundBodyCheck(bodyPos, mag, body.mass);\n  }\n  bodyPos.free();\n};\n\nPlayScreen.prototype.updateViewMatrix = function() {\n  this.camera.follow(this.getPlayerPos());\n  this.viewMatrix.toIdentity();\n  var ratio = (this.canvas.height + this.canvas.width) / (2 + this.camera.getViewDist());\n  this.viewMatrix\n      .multiply(this.mat4.toScaleOpXYZ(\n              ratio / this.canvas.width,\n              ratio / this.canvas.height,\n          0.2));\n\n  // center\n  this.viewMatrix.multiply(this.mat4.toTranslateOpXYZ(\n      -this.camera.getX(),\n      -this.camera.getY(),\n      0));\n\n  this.renderer.setViewMatrix(this.viewMatrix);\n};\n\nPlayScreen.prototype.drawScene = function() {\n  this.hitsThisFrame = 0;\n\n  // TODO: Make player add player trail, in timeout.\n  var playerPos = this.getPlayerPos();\n  var playerVel = this.getPlayerVel();\n  while (this.playerThrustSum > 0) {\n    this.playerThrustSum -= 30;\n    this.addPlayerTrail(playerPos.x, playerPos.y, playerVel.x, playerVel.y);\n    this.playerThrustSum = 0;\n  }\n\n  this.splasher.draw(this.renderer, this.world.now);\n\n  for (var id in this.world.spirits) {\n    this.world.spirits[id].onDraw(this.world, this.renderer);\n  }\n\n  if (this.tiles) {\n    this.renderer\n        .setColorVector(this.levelColorVector)\n        .setModelMatrix(this.levelModelMatrix);\n    var cx = Math.round((this.camera.getX() - this.bitGrid.cellWorldSize/2) / (this.bitGrid.cellWorldSize));\n    var cy = Math.round((this.camera.getY() - this.bitGrid.cellWorldSize/2) / (this.bitGrid.cellWorldSize));\n    var cellRad = 3;\n    for (var dy = -cellRad; dy <= cellRad; dy++) {\n      for (var dx = -cellRad; dx <= cellRad; dx++) {\n        this.loadCellXY(cx + dx, cy + dy);\n        var cellId = this.bitGrid.getCellIdAtIndexXY(cx + dx, cy + dy);\n        var tile = this.tiles[cellId];\n        if (tile && tile.stamp) {\n          this.renderer\n              .setStamp(tile.stamp)\n              .drawStamp();\n        }\n      }\n    }\n  }\n\n  this.drawHud();\n\n  if (this.restarting) {\n    this.controller.restart();\n    this.restarting = false;\n  } else {\n    // Animate whenever this thing draws.\n    this.controller.requestAnimation();\n  }\n};\n\nPlayScreen.prototype.addPlayerTrail = function(x, y, dx, dy) {\n  var s = this.splash;\n  s.reset(PlayScreen.SplashType.PLAYER_TRAIL, this.circleStamp);\n  s.startTime = this.world.now;\n  s.duration = 15;\n\n  var dir = 2 * Math.PI * Math.random();\n  dx = (-dx + 10 * Math.sin(dir)) / 15;\n  dy = (-dy + 10 * Math.cos(dir)) / 15;\n\n  s.startPose.pos.setXYZ(x, y, 0);\n  s.endPose.pos.setXYZ(x + dx * s.duration, y + dy * s.duration, 1);\n  var startRad = 0.8 * PlayScreen.PLAYER_RAD;\n  s.startPose.scale.setXYZ(startRad, startRad, 1);\n  s.endPose.scale.setXYZ(0, 0, 1);\n\n  s.startColor.setXYZ(1, 0, 0);\n  s.endColor.setXYZ(0, 1, 1);\n\n  this.splasher.addCopy(s);\n};\n\nPlayScreen.prototype.addEnemyExplosion = function(x, y) {\n  var self = this;\n  var s = this.splash;\n  var particles, explosionRad, dirOffset, i, dir, dx, dy, duration;\n\n  function addSplash(x, y, dx, dy, duration, sizeFactor) {\n    s.reset(PlayScreen.SplashType.EXPLOSION, self.circleStamp);\n    s.startTime = self.world.now;\n    s.duration = duration;\n\n    s.startPose.pos.setXYZ(x, y, 0);\n    s.endPose.pos.setXYZ(x + dx * s.duration, y + dy * s.duration, 1);\n    var startRad = sizeFactor * PlayScreen.ENEMY_RAD;\n    s.startPose.scale.setXYZ(startRad, startRad, 1);\n    s.endPose.scale.setXYZ(0, 0, 1);\n\n    s.startColor.setXYZ(1, 1, 1);\n    s.endColor.setXYZ(1, 1, 1);\n    self.splasher.addCopy(s);\n  }\n\n  particles = Math.ceil(15 * (1 + Math.random()));\n  explosionRad = 60;\n  dirOffset = 2 * Math.PI * Math.random();\n  for (i = 0; i < particles; i++) {\n    duration = 8 * (1 + Math.random());\n    dir = dirOffset + 2 * Math.PI * (i/particles) + Math.random();\n    dx = Math.sin(dir) * explosionRad / duration;\n    dy = Math.cos(dir) * explosionRad / duration;\n    addSplash(x, y, dx, dy, duration, 1);\n  }\n\n  particles = Math.ceil(8 * (1 + Math.random()));\n  explosionRad = 30;\n  dirOffset = 2 * Math.PI * Math.random();\n  for (i = 0; i < particles; i++) {\n    duration = 20 * (1 + Math.random()*0.5);\n    dir = dirOffset + 2 * Math.PI * (i/particles) + Math.random()/4;\n    dx = Math.sin(dir) * explosionRad / duration;\n    dy = Math.cos(dir) * explosionRad / duration;\n    addSplash(x, y, dx, dy, duration, 1.5);\n  }\n};\n\nPlayScreen.prototype.addDiggingDust = function(x, y) {\n  var self = this;\n  var s = this.splash;\n  var particles, explosionRad, dirOffset, i, dir, dx, dy, duration;\n\n  function addSplash(x, y, dx, dy, duration) {\n    s.reset(PlayScreen.SplashType.TERRAIN_DUST, self.circleStamp);\n    s.startTime = self.world.now;\n    s.duration = duration;\n\n    s.startPose.pos.setXYZ(x, y, 0);\n    s.endPose.pos.setXYZ(x + dx * s.duration, y + dy * s.duration, 1);\n    s.startPose.scale.setXYZ(17, 17, 1);\n    s.endPose.scale.setXYZ(0, 0, 1);\n\n    //return self.vec4.setXYZ(0.6 + (1-t) * 0.4, 0.5, 0.3).scale1(1 - t/2);\n    s.startColor.setXYZ(1, 0.5, 0.3);\n    s.endColor.setXYZ(0.3, 0.25, 0.15);\n    self.splasher.addCopy(s);\n  }\n\n  particles = Math.ceil(6 * (1 + Math.random()));\n  explosionRad = 30 + 5 * Math.random();\n  dirOffset = 2 * Math.PI * Math.random();\n  for (i = 0; i < particles; i++) {\n    duration = 15 * (1 + Math.random());\n    dir = dirOffset + 2 * Math.PI * (i/particles) + Math.random()/4;\n    dx = Math.sin(dir) * explosionRad / duration;\n    dy = Math.cos(dir) * explosionRad / duration;\n    addSplash(x, y, dx, dy, duration);\n  }\n};\n\n/**\n * Draw stuff on screen coords, with 0,0 at the top left and canvas.width, canvas.height at the bottom right.\n */\nPlayScreen.prototype.drawHud = function() {\n  this.renderer.setBlendingEnabled(true);\n  this.touchDetector.decrease();\n\n  // Set hud view matrix\n  this.hudViewMatrix.toIdentity()\n      .multiply(this.mat4.toScaleOpXYZ(\n              2 / this.canvas.width,\n              -2 / this.canvas.height,\n          1))\n      .multiply(this.mat4.toTranslateOpXYZ(-this.canvas.width/2, -this.canvas.height/2, 0));\n  this.renderer.setViewMatrix(this.hudViewMatrix);\n\n  // draw trigger\n  this.renderer\n      .setStamp(this.circleStamp)\n      .setColorVector(this.getTriggerColorVector());\n  this.modelMatrix.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(this.triggerPixelX, this.triggerPixelY, -0.99))\n      .multiply(this.mat44.toScaleOpXYZ(\n              this.triggerPixelRad * this.visibleTriggerScale,\n              this.triggerPixelRad * this.visibleTriggerScale,\n          1));\n  this.renderer.setModelMatrix(this.modelMatrix);\n  this.renderer.drawStamp();\n  this.renderer.setBlendingEnabled(false);\n};\n\nPlayScreen.prototype.getTriggerColorVector = function() {\n  this.colorVector.setXYZ(1, 1, 1);\n  var touchiness = this.touchDetector.getVal();\n  this.colorVector.v[3] = this.trigger.getVal() ? 0.2 : 0.1 * touchiness;\n  return this.colorVector;\n};\n\nPlayScreen.prototype.unloadLevel = function() {\n  if (this.tiles) {\n    for (var cellId in this.tiles) {\n      this.unloadCellId(cellId);\n    }\n    this.tiles = null;\n  }\n  if (this.world) {\n    for (var spiritId in this.world.spirits) {\n      var s = this.world.spirits[spiritId];\n      var b = this.world.bodies[s.bodyId];\n      this.world.removeBodyId(b.id);\n      this.world.removeSpiritId(spiritId);\n    }\n    this.world = null;\n  }\n  this.splasher = null;\n};\n\nPlayScreen.prototype.getBodyPos = function(body) {\n  return body.getPosAtTime(this.world.now, this.vec2d);\n};\n\n\nPlayScreen.prototype.getPlayerPos = function() {\n  var spirit = this.world.spirits[this.playerSpiritId];\n  var body = this.world.bodies[spirit.bodyId];\n  body.getPosAtTime(this.world.now, this.tempPlayerPos);\n  return this.tempPlayerPos;\n};\n\nPlayScreen.prototype.getPlayerVel = function() {\n  var spirit = this.world.spirits[this.playerSpiritId];\n  var body = this.world.bodies[spirit.bodyId];\n  return body.vel;\n};\n\nPlayScreen.prototype.isPlayerPathId = function(pathId) {\n  var spirit = this.world.spirits[this.playerSpiritId];\n  return this.world.paths[pathId] == this.world.bodies[spirit.bodyId];\n};\n\n/**\n * @param {Vec2d} fromPos\n * @param {Vec2d} outVec populated if player is found\n * @returns {Vec2d} outVec if the player was found, or null otherwise.\n */\nPlayScreen.prototype.scanForPlayer = function(fromPos, outVec) {\n  var req = ScanRequest.alloc();\n  req.hitGroup = PlayScreen.Group.ENEMY_MISSILE;\n  // write the body's position into the req's position slot.\n  req.pos.set(fromPos);\n  req.vel.set(this.getPlayerPos()).subtract(fromPos);\n  req.shape = Body.Shape.CIRCLE;\n  req.rad = PlayScreen.ENEMY_MISSILE_RAD;\n  var resp = ScanResponse.alloc();\n  var retval = null;\n  var hit = this.world.rayscan(req, resp);\n  var hitPlayer = this.isPlayerPathId(resp.pathId);\n  if (hit && hitPlayer) {\n    retval = outVec.set(req.vel);\n  }\n  resp.free();\n  req.free();\n  return retval;\n};\n\nPlayScreen.prototype.enemyFire = function(fromPos, vel) {\n  this.initEnemyMissile(fromPos, vel);\n  this.soundPew(fromPos);\n};\n\nPlayScreen.prototype.playerFire = function(fromPos, vel) {\n  this.initPlayerMissile(fromPos, vel);\n//  var spread = Math.PI/32;\n//  this.initPlayerMissile(fromPos, vel.rot(-spread));\n//  this.initPlayerMissile(fromPos, vel.rot(spread*2));\n  this.soundBang(fromPos);\n};\n\n\n////////////\n// Sounds //\n////////////\n\nPlayScreen.prototype.soundPew = function(pos) {\n  this.vec4.setXYZ(pos.x, pos.y, 0).transform(this.viewMatrix);\n  var x = this.vec4.v[0];\n  var y = this.vec4.v[1];\n\n  var freq = 1500 + 1500 * Math.random();\n  var attack = 0.05;\n  var sustain = (4 + Math.random() * 2) / 60;\n  var decay = (20 + 10 * Math.random()) / 60;\n  this.sfx.sound(x, y, 0, 0.15, attack, sustain, decay, freq, 0.5, 'sine');\n  this.sfx.sound(x, y, 0, 0.1, attack, sustain, decay, freq * (2 + Math.random()), 0.5, 'square');\n};\n\nPlayScreen.prototype.soundBang = function(worldPos) {\n  this.vec4.setXYZ(worldPos.x, worldPos.y, 0).transform(this.viewMatrix);\n  var x = this.vec4.v[0];\n  var y = this.vec4.v[1];\n\n  var voices = 3;\n  var maxLength = 0;\n  var sustain = 0.05 * (Math.random() + 1);\n  var baseFreq = (Math.random() + 0.5) * 100;\n  for (var i = 0; i < voices; i++) {\n    var attack = 0;\n    var decay = sustain * 4;\n    maxLength = Math.max(maxLength, attack + decay);\n    var freq1 = baseFreq * (1 + i/3);\n    var freq2 = 1 + i;\n    this.sfx.sound(x, y, 0, 2/voices, attack, sustain, decay, freq1, freq2, 'square');\n  }\n};\n\nPlayScreen.prototype.soundWallThump = function(worldPos, mag) {\n  this.vec4.setXYZ(worldPos.x, worldPos.y, 0).transform(this.viewMatrix);\n  var x = this.vec4.v[0];\n  var y = this.vec4.v[1];\n\n  var vol = Math.min(1, mag*mag/300);\n  if (vol > 0.01) {\n    var dur = Math.min(0.1, 0.01 * mag*mag);\n    var freq = mag + 200 + 5 * Math.random();\n    var freq2 = 1;\n    this.sfx.sound(x, y, 0, vol, 0, 0, dur, freq, freq2, 'square');\n  }\n};\n\nPlayScreen.prototype.soundBodyCheck = function(worldPos, mag, mass) {\n  this.vec4.setXYZ(worldPos.x, worldPos.y, 0).transform(this.viewMatrix);\n  var x = this.vec4.v[0];\n  var y = this.vec4.v[1];\n\n  var massSqrt = Math.sqrt(mass);\n  var vol = Math.min(1, 0.005*mag*mag);\n  if (vol > 0.01) {\n    var freq = 200 + 10000 / massSqrt;\n    var freq2 = 1;//freq/10;//freq * (1 + (Math.random() - 0.5) * 0.01);\n    var dur = Math.min(0.2, Math.max(mass / 600, 0.05));\n    this.sfx.sound(x, y, 0, vol, 0, 0, dur, freq, freq2, 'sine');\n  }\n\n};\n\nPlayScreen.prototype.soundBing = function(worldPos) {\n  this.vec4.setXYZ(worldPos.x, worldPos.y, 0).transform(this.viewMatrix);\n  var x = this.vec4.v[0];\n  var y = this.vec4.v[1];\n\n  var voices = 2;\n  var maxLength = 0;\n  var sustain = 0.05 * (Math.random() + 0.5);\n  var baseFreq = (Math.random() + 0.5) * 200;\n  for (var i = 0; i < voices; i++) {\n    var attack = 0;\n    var decay = sustain * 4;\n    maxLength = Math.max(maxLength, attack + decay);\n    var freq1 = baseFreq * (1 + i/3);\n    var freq2 = 1 + i;\n    this.sfx.sound(x, y, 0, 2/voices * 0.2, attack, sustain, decay, freq1, freq2, 'square');\n  }\n};\n\nPlayScreen.prototype.soundKaboom = function(worldPos) {\n  this.vec4.setXYZ(worldPos.x, worldPos.y, 0).transform(this.viewMatrix);\n  var x = this.vec4.v[0];\n  var y = this.vec4.v[1];\n\n  var voices = 8;\n  for (var i = 0; i < voices; i++) {\n    var delay = (i % 2 ? 0 : 0.1) * (1 + 0.1 * Math.random());\n    var attack = 0.002;\n    var sustain = 0.1 * (Math.random() + 0.01);\n    var decay = (Math.random() + 1) * 0.5;\n    var freq1 = Math.random() * 30 + 30;\n    var freq2 = Math.random() * 10 + 10;\n    this.sfx.sound(x, y, 0, 0.8, attack, sustain, decay, freq1, freq2, 'square', delay);\n  }\n};\n\n\n\n/**\n * @constructor\n * @extends {BaseScreen}\n */\nfunction PauseScreen(controller, canvas, renderer, glyphs, stamps, sound) {\n  BaseScreen.call(this, controller, canvas, renderer, glyphs, stamps, sound);\n}\nPauseScreen.prototype = new BaseScreen();\nPauseScreen.prototype.constructor = PauseScreen;\n\nPauseScreen.prototype.lazyInit = function() {\n  if (!this.world) {\n    this.initWorld();\n  }\n};\n\nPauseScreen.prototype.onSpaceDown = function() {\n  this.resumeSpirit.onClick();\n};\n\nPauseScreen.prototype.onPointerDown = function(pageX, pageY) {\n  this.vec2d.setXY(pageX, pageY);\n  this.transformCanvasToWorld(this.vec2d);\n  if (this.resumeSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.resumeSpirit.onClick();\n  }\n  if (this.fullScreenSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.fullScreenSpirit.onClick();\n  }\n  if (this.quitSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.quitSpirit.onClick();\n  }\n};\n\nPauseScreen.prototype.initWorld = function() {\n  this.world = new World(World.DEFAULT_CELL_SIZE, 2, [[0, 0], [1, 1]]);\n  this.resolver = new HitResolver();\n  this.resolver.defaultElasticity = 0.9;\n  var labelMaker = new LabelMaker(this.glyphs);\n  var controller = this.controller;\n  var sfx = this.sfx;\n  var world = this.world;\n\n  var buttonMaker = new ButtonMaker(labelMaker, this.world, null, this.renderer);\n  buttonMaker\n      .setNextCharMatrix(new Matrix44().toTranslateOpXYZ(3, 0, 0))\n      .setPaddingXY(1.5, 0.5);\n\n  buttonMaker.setLetterColor([1*0.7, 0.75*0.7, 0.25*0.7]).setBlockColor(null);\n  buttonMaker.addButton(0, 0, \"PAUSED\", null);\n\n  var spiritId;\n\n  // RESUME\n  buttonMaker.setLetterColor([1, 0.75, 0.25]).setBlockColor([1*0.5, 0.75*0.5, 0.25*0.5]);\n  spiritId = buttonMaker.addButton(0, -8, \"RESUME\", function(e) {\n    var freq0 = 100;\n    var freq1 = 5000;\n    var delay = 0;\n    var attack = 0.01;\n    var sustain = 0.1;\n    var decay = 0.04;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.gotoScreen(Game1.SCREEN_PLAY);\n    controller.requestPointerLock();\n  });\n  this.resumeSpirit = this.world.spirits[spiritId];\n\n  // FULL SCREEN\n  buttonMaker.setScale(0.75);\n  spiritId = buttonMaker.addButton(0, -8-6, \"FULL SCREEN\", function(e) {\n    var freq0 = 200;\n    var freq1 = 2200;\n    var delay = 0;\n    var attack = 0.05;\n    var sustain = 0.1;\n    var decay = 0.2;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.requestFullScreen();\n  });\n  this.fullScreenSpirit = world.spirits[spiritId];\n\n  // QUIT\n  spiritId = buttonMaker.addButton(0, -8-6-5, \"QUIT\", function(e) {\n    var freq0 = 200;\n    var freq1 = 5;\n    var delay = 0;\n    var attack = 0;\n    var sustain = 1;\n    var decay = 0.1;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.quit();\n  });\n  this.quitSpirit = world.spirits[spiritId];\n\n  for (spiritId in this.world.spirits) {\n    var s = this.world.spirits[spiritId];\n    var b = this.world.bodies[s.bodyId];\n    this.worldBoundingRect.coverRect(b.getBoundingRectAtTime(this.world.now));\n  }\n//  this.worldBoundingRect.coverXY(0, 5);\n//  this.worldBoundingRect.coverXY(0, -27);\n};\n\nPauseScreen.prototype.updateViewMatrix = function() {\n  var br = this.worldBoundingRect;\n  this.viewMatrix.toIdentity();\n  var ratio = Math.min(this.canvas.height, this.canvas.width) / Math.max(br.rad.x, br.rad.y);\n  this.viewMatrix\n      .multiply(this.mat4.toScaleOpXYZ(\n              ratio / this.canvas.width,\n              ratio / this.canvas.height,\n          0.2));\n\n  // scale\n  var v = this.visibility;\n  this.viewMatrix.multiply(this.mat4.toScaleOpXYZ(3 - v*2, v * v, 1));\n\n  // center\n  this.viewMatrix.multiply(this.mat4.toTranslateOpXYZ(\n      -br.pos.x,\n      -br.pos.y,\n      0));\n\n  this.renderer.setViewMatrix(this.viewMatrix);\n};\n\n\n// ----------------------- MAIN ------------------------\n\n\nvar canvas = document.createElement('canvas');\ncanvas.id = 'canvas';\nresizeCanvas();\ndocument.body.appendChild(canvas);\nthis.addEventListener(\"load\", main);\n\n// ------  main  -------\n\nfunction resizeCanvas() {\n  var w = window.innerWidth;\n  var h = window.innerHeight;\n  canvas.style.width = w + \"px\";\n  canvas.style.height = h + \"px\";\n  canvas.width = w;\n  canvas.height = h;\n}\n\nfunction main() {\n  var game1 = new Game1();\n}\n\nfunction Game1() {\n  this.canvas = canvas;\n  new RendererLoader(this.canvas, 'vertex-shader.txt', 'fragment-shader.txt').load(this.onRendererLoaded.bind(this));\n  this.sfx = new SoundFx();\n  this.sfx.setListenerXYZ(0, 0, 5);\n  this.iosSoundUnlocked = false;\n  this.animateFrameFn = this.animateFrame.bind(this);\n  // on-event sound unlocker for iOS\n  document.body.addEventListener('mouseup', this.unlockIosSound.bind(this));\n  document.body.addEventListener('touchend', this.unlockIosSound.bind(this));\n}\n\nvar MS_PER_FRAME = 1000 / 60;\nvar CLOCKS_PER_FRAME = 0.5;\nvar PATH_DURATION = CLOCKS_PER_FRAME * 2;\n\nGame1.SCREEN_TITLE = 'title';\nGame1.SCREEN_PLAY = 'play';\nGame1.SCREEN_PAUSE = 'pause';\n\nGame1.SCREENS = [Game1.SCREEN_TITLE, Game1.SCREEN_PLAY, Game1.SCREEN_PAUSE];\n\nGame1.prototype.unlockIosSound = function() {\n  if (!this.iosSoundUnlocked) {\n    this.sfx.sound(0, 0, 0, 0.001, 0, 0, 0.001, 1, 1, 'sine');\n    this.iosSoundUnlocked = true;\n  }\n};\n\nGame1.prototype.onRendererLoaded = function(r) {\n  this.renderer = r;\n  this.initScreens();\n  this.requestAnimation();\n};\n\nGame1.prototype.initScreens = function() {\n  this.initStamps();\n  this.screens = {};\n  this.screens[Game1.SCREEN_TITLE] = new TitleScreen(this, this.canvas, this.renderer, this.glyphs, this.stamps, this.sfx);\n  this.screens[Game1.SCREEN_PLAY] = new PlayScreen(this, this.canvas, this.renderer, this.glyphs, this.stamps, this.sfx);\n  this.screens[Game1.SCREEN_PAUSE] = new PauseScreen(this, this.canvas, this.renderer, this.glyphs, this.stamps, this.sfx);\n\n  this.visibility = {};\n  for (var i = 0; i < Game1.SCREENS.length; i++) {\n    var screen = Game1.SCREENS[i];\n    this.visibility[screen] = screen == Game1.SCREEN_TITLE ? 1 : 0;\n  }\n  this.frontScreenId = Game1.SCREEN_TITLE;\n  this.animationRequested = false;\n};\n\nGame1.prototype.initStamps = function() {\n  var glyphMaker = new GlyphMaker(0.4, 1.2);\n  this.glyphs = new Glyphs(glyphMaker);\n  var glyphStamps = this.glyphs.initStamps(this.renderer.gl);\n  this.stamps = {};\n  for (var key in glyphStamps) {\n    this.stamps[key] = glyphStamps[key];\n  }\n};\n\nGame1.prototype.animateFrame = function() {\n  this.animationRequested = false;\n  this.renderer.resize().clear();\n  for (var i = 0; i < Game1.SCREENS.length; i++) {\n    var id = Game1.SCREENS[i];\n    var oldVisibility = this.visibility[id];\n    var seconds = 0.2;\n    if (this.frontScreenId == id) {\n      this.visibility[id] = Math.min(1, this.visibility[id] + 1 / (seconds * 60));\n    } else {\n      this.visibility[id] = Math.max(0, this.visibility[id] - 1 / (seconds * 60));\n    }\n    this.screens[id].setScreenListening(this.frontScreenId == id);\n    if (this.visibility[id]) {\n      this.screens[id].drawScreen(this.visibility[id]);\n    }\n    if (oldVisibility != this.visibility[id]) {\n      this.requestAnimation();\n    }\n  }\n};\n\nGame1.prototype.gotoScreen = function(screenId) {\n  this.frontScreenId = screenId;\n  this.requestAnimation();\n};\n\nGame1.prototype.quit = function() {\n  this.exitPointerLock();\n  this.screens[Game1.SCREEN_PLAY].unloadLevel();\n  this.gotoScreen(Game1.SCREEN_TITLE);\n};\n\nGame1.prototype.restart = function() {\n  this.screens[Game1.SCREEN_PLAY].unloadLevel();\n  this.requestAnimation();\n};\n\nGame1.prototype.requestFullScreen = function() {\n  var elem = document.body;\n  if (elem.requestFullscreen) {\n    elem.requestFullscreen();\n  } else if (elem.msRequestFullscreen) {\n    elem.msRequestFullscreen();\n  } else if (elem.mozRequestFullScreen) {\n    elem.mozRequestFullScreen();\n  } else if (elem.webkitRequestFullscreen) {\n    elem.webkitRequestFullscreen();\n  }\n  this.requestAnimation();\n};\n\nGame1.prototype.requestPointerLock = function() {\n  this.canvas.requestPointerLock = this.canvas.requestPointerLock ||\n      this.canvas.mozRequestPointerLock ||\n      this.canvas.webkitRequestPointerLock;\n  if (this.canvas.requestPointerLock) {\n    this.canvas.requestPointerLock();\n  }\n  this.requestAnimation();\n};\n\nGame1.prototype.exitPointerLock = function() {\n  document.exitPointerLock = document.exitPointerLock ||\n      document.mozExitPointerLock ||\n      document.webkitExitPointerLock;\n  if (document.exitPointerLock) {\n    document.exitPointerLock();\n  } else {\n    console.log('exitPointerLock UNPOSSIBLE');\n  }\n  this.requestAnimation();\n};\n\nGame1.prototype.requestAnimation = function() {\n  if (!this.animationRequested) {\n    this.animationRequested = true;\n    requestAnimationFrame(this.animateFrameFn, this.canvas);\n  }\n};\n\n// -------------------- END OF FILE ------------------------\n","language":"text/javascript","encrypted":false,"added":1460411012},{"paste_id":13,"description":"bWkfba8GExhjz7FHv8w9mwLKACBWXsP5ZysWGEPwk0BhsQKcmVGWEe5iEXDTdLlEBTlW8gAg9BXRQscv/z0PeVGIorGXCSbqRW+WMJXzNciuvrmpoQ+gIuUkQ9sqgzQAwyf1uEObAkCurLLt0pbhGiG9kG+Hdd7veppKwhi+7g6PeLDOhKU=","body":"oBhaNI/ogLxHYM+WI5ay+wLKACDpE4FwVS5MFtaPhSeSOLFaUpZpUN9ktZtUz7cvXImlnwAgA+XK99k0nT7o49nQ9ToX1GXkjrevNsABrkPvDw7r2ltndc1zxrXgOQ04CAdYGeD/yAIVgUB8l1VPViN/IY6N1mNWV/728fZp5pgg1GAhcM6h3f0S3dwpLvfgC2UmQn7wqgn3iwUGMINe/BqFPWaIUnVWMGDUFwmbjSzJevqLVAXBv2+Xzdyvj2Hy0+zgIxnR016rb4BeW+uz99snn76a3cr2h/fiYP+eFEPD4KJSwJ8PKLeoGKmctiizJD4QYYcNTT4B6+ykObYm/v004dzKcz32X7b0KalMtbhJwmn/JnKp4cDBdf5nXqX9Ed0NhPtXbjhozXw4mFntV+7ze/uneBI+fXFNvtvU9/B2ETFGpVBclwNpDiabxiZM/iwfkSwmnGv2sy80+0goM6Tr1/UBqZ23gQbDMlJIyhi+JevUgxtgiIGT7hek4gxh4t24pPT87d/19kMOPS6Yh7vSNYeleFO9o+ujs2Bze59qev63FBshVZlzvKY4S9RpDvNyOslGedBSpV7og8gOqLigW+z1QmaEHH8EPYcFtrTUyuyTVEXfBouuFV2nAUZleloJ9UAbBUqAEGTOwXSrGrYxDkeJ8xVwu4soPQ+tet2fiLdB0DI=","language":"ToyGaga9cH6bfMS7Pjj2WgLKACAFuBi3Wb5n1H9s7YkZtwcBLjZ4XEGi7vjxDHsPfsUvfwAgSG6sZBOxEdn/wxXbXo16lNe9yW/sTKUSX2wycYVeEZDUmG082SjxL7J2YofzYf+siXIgf7uZ12ImyNWcKGYN1ny5JBKHBTQ6sr7YXQadQNw=","encrypted":true,"added":1460719732},{"paste_id":15,"description":"Map Editor (Cave2D.com)","body":"\n// Test 38\n// Editor1 by Aaron Whyte\n// CAVE2D.com\n\n// BOT: Spacebar to pause. Testing map save (still buggy)\n\n\n/* ---- js/math.js ---- */\n\n\nif (!Math.sign) {\n  // Mozilla's suggested polyfill.\n  Math.sign = function sign(x) {\n    x = +x; // convert to a number\n    if (x === 0 || isNaN(x))\n      return x;\n    return x > 0 ? 1 : -1\n  }\n}\n\n\n/* ---- js/poolify.js ---- */\n\n\n/**\n * Adds a static pool, plus alloc and free methods, to a constructor.\n *\n * That constructor's instances must implement \"reset()\" which clears\n * the instance in preparation for re-use, taking the same arguments\n * as the constructor.\n *\n * @param {Function} ctor A constructor.\n */\nfunction Poolify(ctor) {\n  ctor.pool = [];\n  ctor.alloc = Poolify.alloc;\n  ctor.free = Poolify.free;\n  ctor.prototype.free = function() {\n    ctor.free(this);\n  };\n}\n\nPoolify.alloc = function() {\n  var retval;\n  if (this.pool.length) {\n    retval = this.pool.pop();\n    retval.reset.apply(retval, arguments);\n  } else {\n    retval = Object.create(this.prototype);\n    this.apply(retval, arguments);\n  }\n  return retval;\n};\n\nPoolify.free = function(o) {\n  this.pool.push(o);\n};\n\n\n/* ---- js/vec2d.js ---- */\n\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @constructor\n */\nfunction Vec2d(opt_x, opt_y) {\n  this.reset(opt_x, opt_y);\n}\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n */\nVec2d.prototype.reset = function(opt_x, opt_y) {\n  this.x = opt_x || 0;\n  this.y = opt_y || 0;\n  return this;\n};\n\nVec2d.pool = [];\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n */\nVec2d.alloc = function(opt_x, opt_y) {\n  if (Vec2d.pool.length) {\n    return Vec2d.pool.pop().reset(opt_x, opt_y);\n  }\n  return new Vec2d(opt_x, opt_y);\n};\n\nVec2d.prototype.free = function() {\n  Vec2d.pool.push(this);\n};\n\nVec2d.X = 'x';\nVec2d.Y = 'y';\n\nVec2d.AXES = [Vec2d.X, Vec2d.Y];\n\nVec2d.ZERO = new Vec2d(0, 0);\n\nVec2d.otherAxis = function(axis) {\n  return axis === Vec2d.X ? Vec2d.Y : Vec2d.X;\n};\n\nVec2d.prototype.add = function(v) {\n  this.x += v.x;\n  this.y += v.y;\n  return this;\n};\n\nVec2d.prototype.addXY = function(x, y) {\n  this.x += x;\n  this.y += y;\n  return this;\n};\n\nVec2d.prototype.subtract = function(v) {\n  this.x -= v.x;\n  this.y -= v.y;\n  return this;\n};\n\nVec2d.prototype.multiply = function(v) {\n  this.x *= v.x;\n  this.y *= v.y;\n  return this;\n};\n\nVec2d.prototype.roundToGrid = function(cellSize) {\n  this.x = Math.round(this.x / cellSize);\n  this.y = Math.round(this.y / cellSize);\n  return this.scale(cellSize);\n};\n\nVec2d.prototype.set = function(v) {\n  this.x = v.x;\n  this.y = v.y;\n  return this;\n};\n\nVec2d.prototype.setXY = function(xx, yy) {\n  this.x = xx;\n  this.y = yy;\n  return this;\n};\n\nVec2d.prototype.scale = function(s) {\n  this.x *= s;\n  this.y *= s;\n  return this;\n};\n\nVec2d.prototype.scaleXY = function(sx, sy) {\n  this.x *= sx;\n  this.y *= sy;\n  return this;\n};\n\nVec2d.prototype.abs = function() {\n  this.x = Math.abs(this.x);\n  this.y = Math.abs(this.y);\n  return this;\n};\n\nVec2d.prototype.sign = function() {\n  this.x = Math.sign(this.x);\n  this.y = Math.sign(this.y);\n  return this;\n};\n\nVec2d.prototype.rot90Right = function() {\n  var tmp = this.x;\n  this.x = -this.y;\n  this.y = tmp;\n  return this;\n};\n\nVec2d.prototype.rot = function(rads) {\n  if (!rads) {\n    // no rotation\n    return this;\n  }\n  var sin = Math.sin(rads);\n  var cos = Math.cos(rads);\n  var nx = cos * this.x + sin * this.y;\n  var ny = -sin * this.x + cos * this.y;\n  this.x = nx;\n  this.y = ny;\n  return this;\n};\n\nVec2d.prototype.dot = function(that) {\n  return this.x * that.x + this.y * that.y;\n};\n\nVec2d.dotXYXY = function(x0, y0, x1, y1) {\n  return x0 * x1 + y0 * y1;\n};\n\nVec2d.prototype.magnitudeSquared = function() {\n  return this.x * this.x + this.y * this.y;\n};\n\nVec2d.prototype.magnitude = function() {\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\nVec2d.prototype.distanceSquared = function(that) {\n  var dx = this.x - that.x;\n  var dy = this.y - that.y;\n  return dx * dx + dy * dy;\n};\n\nVec2d.prototype.distance = function(that) {\n  var dx = this.x - that.x;\n  var dy = this.y - that.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nVec2d.magnitude = function(x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n\n/**\n * Scales to the desired length, or 0 if the vector is {0, 0}\n */\nVec2d.prototype.scaleToLength = function(length) {\n  var m = this.magnitude();\n  if (m) {\n    this.scale(length / m);\n  }\n  return this;\n};\n\n/**\n * If the magnitude is over the max, this scales it down.\n */\nVec2d.prototype.clipToMaxLength = function(maxLength) {\n  var m = this.magnitude();\n  if (m > maxLength) {\n    this.scale(maxLength / m);\n  }\n  return this;\n};\n\nVec2d.prototype.slideByFraction = function(towardsPoint, fraction) {\n  this.x = this.x * (1 - fraction) + towardsPoint.x * fraction;\n  this.y = this.y * (1 - fraction) + towardsPoint.y * fraction;\n};\n\n\nVec2d.prototype.equals = function(v) {\n  return (this.x == v.x && this.y == v.y);\n};\n\nVec2d.prototype.isZero = function() {\n  return this.x == 0 && this.y == 0;\n};\n\nVec2d.prototype.toString = function() {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nVec2d.dirs = [\n  new Vec2d(0, -1),\n  new Vec2d(1, -1),\n  new Vec2d(1, 0),\n  new Vec2d(1, 1),\n  new Vec2d(0, 1),\n  new Vec2d(-1, 1),\n  new Vec2d(-1, 0),\n  new Vec2d(-1, -1)\n];\n\n// static func\nVec2d.randDir = function() {\n  var dir = Vec2d.dirs[Math.floor(Math.random()*8)];\n  return new Vec2d(dir.x, dir.y);\n};\n\nVec2d.alongRayDistance = function(startPoint, towardsPoint, distance) {\n  return new Vec2d()\n      .set(towardsPoint)\n      .subtract(startPoint)\n      .scaleToLength(distance)\n      .add(startPoint);\n};\n\nVec2d.alongRayFraction = function(startPoint, towardsPoint, fraction) {\n  return new Vec2d()\n      .set(towardsPoint)\n      .subtract(startPoint)\n      .scale(fraction)\n      .add(startPoint);\n};\n\nVec2d.midpoint = function(a, b) {\n  return new Vec2d()\n      .set(a)\n      .add(b)\n      .scale(0.5);\n};\n\nVec2d.distance = function(x0, y0, x1, y1) {\n  var dx = x0 - x1;\n  var dy = y0 - y1;\n  return Math.sqrt((dx * dx) + (dy * dy));\n};\n\nVec2d.distanceSq = function(x0, y0, x1, y1) {\n  var dx = x0 - x1;\n  var dy = y0 - y1;\n  return (dx * dx) + (dy * dy);\n};\n\nVec2d.prototype.projectOnto = function(that) {\n  var coef = this.dot(that) / that.dot(that);\n  return this.set(that).scale(coef);\n};\n\nVec2d.prototype.toJSON = function() {\n  return [this.x, this.y];\n};\n\nVec2d.prototype.setFromJSON = function(json) {\n  this.x = json[0];\n  this.y = json[1];\n};\n\nVec2d.fromJSON = function(json) {\n  return new Vec2d(json[0], json[1]);\n};\n\n\n/* ---- js/vec4.js ---- */\n\n\n/**\n * A 4D vector, for use as a 3D vector, plus a \"w\" value to help with\n * 3D matrix transformations.\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_z\n * @param {=number} opt_w\n * @constructor\n */\nfunction Vec4(opt_x, opt_y, opt_z, opt_w) {\n  this.v = [0, 0, 0, 1];\n  this.reset(opt_x, opt_y, opt_z, opt_w);\n}\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_z\n * @param {=number} opt_w\n */\nVec4.prototype.reset = function(opt_x, opt_y, opt_z, opt_w) {\n  this.v[0] = opt_x || 0;\n  this.v[1] = opt_y || 0;\n  this.v[2] = opt_z || 0;\n  this.v[3] = (typeof opt_w != 'undefined' ? opt_w : 1);\n  return this;\n};\n\nVec4.pool = [];\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_z\n * @param {=number} opt_w\n */\nVec4.alloc = function(opt_x, opt_y, opt_z, opt_w) {\n  if (Vec4.pool.length) {\n    return Vec4.pool.pop().reset(opt_x, opt_y, opt_z, opt_w);\n  }\n  return new Vec4(opt_x, opt_y, opt_z, opt_w);\n};\n\nVec4.prototype.free = function() {\n  Vec4.pool.push(this);\n};\n\nVec4.ZERO = new Vec4();\n\nVec4.temp = new Vec4();\n\n/**\n * Transforms this vector by multiplying it by the matrix.\n * @param {Matrix44} matrix\n * @returns {Vec4}\n */\nVec4.prototype.transform = function(matrix) {\n  Vec4.temp.reset();\n  // In this case we want even \"w\" to be 0. It will get a 1 if the math works out.\n  Vec4.temp.v[3] = 0;\n  for (var row = 0; row < 4; row++) {\n    for (var col = 0; col < 4; col++) {\n      Vec4.temp.v[row] += this.v[col] * matrix.m[col + 4*row];\n    }\n  }\n  return this.set(Vec4.temp);\n};\n\nVec4.prototype.add = function(that) {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] += that.v[i];\n  }\n  return this;\n};\n\nVec4.prototype.addXYZ = function(x, y, z) {\n  this.v[0] += x;\n  this.v[1] += y;\n  this.v[2] += z;\n  return this;\n};\n\nVec4.prototype.subtract = function(that) {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] -= that.v[i];\n  }\n  return this;\n};\n\nVec4.prototype.set = function(that) {\n  for (var i = 0; i < 4; i++) {\n    this.v[i] = that.v[i];\n  }\n  return this;\n};\n\nVec4.prototype.setXYZ = function(x, y, z) {\n  this.v[0] = x;\n  this.v[1] = y;\n  this.v[2] = z;\n  return this;\n};\n\nVec4.prototype.setRGBA = function(r, g, b, a) {\n  this.v[0] = r;\n  this.v[1] = g;\n  this.v[2] = b;\n  this.v[3] = a;\n  return this;\n};\n\nVec4.prototype.getX = Vec4.prototype.getR = function() {\n  return this.v[0];\n};\n\nVec4.prototype.getY = Vec4.prototype.getG = function() {\n  return this.v[1];\n};\n\nVec4.prototype.getZ = Vec4.prototype.getB = function() {\n  return this.v[2];\n};\n\nVec4.prototype.getW = Vec4.prototype.getA = function() {\n  return this.v[2];\n};\n\nVec4.prototype.scale1 = function(s) {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] *= s;\n  }\n  return this;\n};\n\nVec4.prototype.abs = function() {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] = Math.abs(this.v[i]);\n  }\n  return this;\n};\n\nVec4.prototype.sign = function() {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] = Math.sign(this.v[i]);\n  }\n  return this;\n};\n\nVec4.prototype.dot = function(that) {\n  var dot = 0;\n  for (var i = 0; i < 3; i++) {\n    dot += this.v[i] * that.v[i];\n  }\n  return dot;\n};\n\nVec4.prototype.magnitudeSquared = function() {\n  return this.dot(this);\n};\n\nVec4.prototype.magnitude = function() {\n  return Math.sqrt(this.magnitudeSquared());\n};\n\n/**\n * Scales to the desired length, or 0 if the vector is {0, 0}\n */\nVec4.prototype.scaleToLength = function(length) {\n  var m = this.magnitude();\n  if (m) {\n    this.scale1(length / m);\n  }\n  return this;\n};\n\n/**\n * If the magnitude is over the max, this scales it down.\n */\nVec4.prototype.clipToMaxLength = function(maxLength) {\n  var m = this.magnitude();\n  if (m > maxLength) {\n    this.scale1(maxLength / m);\n  }\n  return this;\n};\n\nVec4.prototype.setToInterpolation = function(a, b, t) {\n  for (var i = 0; i < 4; i++) {\n    this.v[i] = a.v[i] * (1-t) + b.v[i] * t;\n  }\n  return this;\n};\n\n\nVec4.prototype.equals = function(that, opt_slop) {\n  var slop = opt_slop || 0;\n  for (var i = 0; i < 3; i++) {\n    if (Math.abs(this.v[i] - that.v[i]) > slop) return false;\n  }\n  return true;\n};\n\nVec4.prototype.toString = function() {\n  return '(' + this.v.join(', ') + ')';\n};\n\nVec4.alongRayDistance = function(startPoint, towardsPoint, distance) {\n  return new Vec4()\n      .set(towardsPoint)\n      .subtract(startPoint)\n      .scaleToLength(distance)\n      .add(startPoint);\n};\n\nVec4.alongRayFraction = function(startPoint, towardsPoint, fraction) {\n  return new Vec4()\n      .set(towardsPoint)\n      .subtract(startPoint)\n      .scale(fraction)\n      .add(startPoint);\n};\n\nVec4.midpoint = function(a, b) {\n  return new Vec4()\n      .set(a)\n      .add(b)\n      .scale(0.5);\n};\n\nVec4.prototype.projectOnto = function(that) {\n  var coef = this.dot(that) / that.dot(that);\n  return this.set(that).scale(coef);\n};\n\nVec4.prototype.toJSON = function() {\n  return [this.v[0], this.v[1], this.v[2], this.v[3]];\n};\n\nVec4.prototype.setFromJSON = function(json) {\n  for (var i = 0; i < 3; i++) {\n    this.v[i] = json[i];\n  }\n};\n\nVec4.fromJSON = function(json) {\n  return new Vec4(json[0], json[1], json[2], json[3]);\n};\n\n\n/* ---- js/matrix33.js ---- */\n\n\n/**\n * @constructor\n */\nfunction Matrix33() {\n  // (0,0), (1,0), (2,0), (0,1), (1,0)...\n  this.m = [];\n  this.reset();\n}\n\nMatrix33.IDENTITY_ARRAY = [\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, 1];\n\nMatrix33.tempArray = [\n  0, 0, 0,\n  0, 0, 0,\n  0, 0, 0];\n\n/**\n * Start as the the identity matrix.\n * @returns {Matrix33}\n */\nMatrix33.prototype.reset = function() {\n  return this.toIdentity();\n};\n\nMatrix33.pool = [];\n\nMatrix33.alloc = function() {\n  if (Matrix33.pool.length) {\n    return Matrix33.pool.pop().reset();\n  }\n  return new Matrix33();\n};\n\nMatrix33.prototype.free = function() {\n  Matrix33.pool.push(this);\n};\n\nMatrix33.prototype.toIdentity = function() {\n  for (var i = 0; i < 9; i++) {\n    this.m[i] = Matrix33.IDENTITY_ARRAY[i];\n  }\n  return this;\n};\n\nMatrix33.prototype.setColRowVal = function(col, row, val) {\n  this.m[col + 3 * row] = val;\n};\n\nMatrix33.prototype.getColRowVal = function(col, row) {\n  return this.m[col + 3 * row];\n};\n\nMatrix33.prototype.toTranslateXYOp = function(tx, ty) {\n  this.toIdentity();\n  this.setColRowVal(2, 0, tx);\n  this.setColRowVal(2, 1, ty);\n  return this;\n};\n\nMatrix33.prototype.toScaleXYOp = function(sx, sy) {\n  this.toIdentity();\n  this.setColRowVal(0, 0, sx);\n  this.setColRowVal(1, 1, sy);\n  return this;\n};\n\n/**\n * Right-handed rotation clockwise as you look from the origin to positive-Z.\n * @param {number} angle\n * @returns {Matrix33}\n */\nMatrix33.prototype.toRotateOp = function(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  this.toIdentity();\n  this.setColRowVal(0, 0, cos);\n  this.setColRowVal(1, 0, -sin);\n  this.setColRowVal(0, 1, sin);\n  this.setColRowVal(1, 1, cos);\n  return this;\n};\n/**\n * Mutates this matrix by multiplying it by that one.\n * @param {Matrix33} that\n * @return {Matrix33} this, mutated\n */\nMatrix33.prototype.multiply = function(that) {\n  for (var y = 0; y < 3; y++) {\n    for (var x = 0; x < 3; x++) {\n      var val = 0;\n      for (var i = 0; i < 3; i++) {\n        val += this.m[i + 3*y] * that.m[x + 3*i];\n      }\n      Matrix33.tempArray[x + 3*y] = val;\n    }\n  }\n  for (var a = 0; a < 9; a++) {\n    this.m[a] = Matrix33.tempArray[a];\n  }\n  return this;\n};\n\nMatrix33.prototype.set = function(that) {\n  for (var i = 0; i < 9; i++) {\n    this.m[i] = that.m[i];\n  }\n  return this;\n};\n\nMatrix33.prototype.equals = function(that, opt_slop) {\n  var slop = opt_slop || 0;\n  for (var i = 0; i < 9; i++) {\n    if (Math.abs(this.m[i] - that.m[i]) > slop) return false;\n  }\n  return true;\n};\n\nMatrix33.prototype.determinant = function() {\n  var m = this.m;\n  return m[0] * m[4] * m[8] +\n       m[1] * m[5] * m[6] +\n       m[2] * m[3] * m[7] -\n       m[2] * m[4] * m[6] -\n       m[1] * m[3] * m[8] -\n       m[0] * m[5] * m[7];\n};\n\nMatrix33.prototype.toString = function() {\n  return JSON.stringify(this.m);\n};\n\nMatrix33.prototype.toJSON = function() {\n  return this.m.concat();\n};\n\nMatrix33.fromJSON = function(json) {\n  return (new Matrix33()).set(json);\n};\n\n\n/* ---- js/matrix44.js ---- */\n\n\n/**\n * @constructor\n */\nfunction Matrix44() {\n  // (0,0), (1,0), (2,0), (3,0), (0,1), (1,0)...\n  this.m = [];\n  this.reset();\n}\n\nMatrix44.IDENTITY_ARRAY = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1];\n\nMatrix44.tempArray = [\n  0, 0, 0, 0,\n  0, 0, 0, 0,\n  0, 0, 0, 0,\n  0, 0, 0, 0];\n\n/**\n * Start as the the identity matrix.\n * @returns {Matrix44}\n */\nMatrix44.prototype.reset = function() {\n  return this.toIdentity();\n};\n\nMatrix44.pool = [];\n\nMatrix44.alloc = function() {\n  if (Matrix44.pool.length) {\n    return Matrix44.pool.pop().reset();\n  }\n  return new Matrix44();\n};\n\nMatrix44.prototype.free = function() {\n  Matrix44.pool.push(this);\n};\n\nMatrix44.prototype.toIdentity = function() {\n  for (var i = 0; i < 16; i++) {\n    this.m[i] = Matrix44.IDENTITY_ARRAY[i];\n  }\n  return this;\n};\n\nMatrix44.prototype.toTranslateOp = function(vec4) {\n  this.toIdentity();\n  for (var row = 0; row < 3; row++) {\n    this.m[3 + 4 * row] = vec4.v[row];\n  }\n  return this;\n};\n\nMatrix44.prototype.toTranslateOpXYZ = function(x, y, z) {\n  this.toIdentity();\n  this.m[3] = x;\n  this.m[7] = y;\n  this.m[11] = z;\n  return this;\n};\n\nMatrix44.prototype.toScaleOp = function(vec4) {\n  this.toIdentity();\n  for (var xy = 0; xy < 3; xy++) {\n    this.m[5 * xy] = vec4.v[xy];\n  }\n  return this;\n};\n\nMatrix44.prototype.toScaleOpXYZ = function(x, y, z) {\n  this.toIdentity();\n  this.m[0] = x;\n  this.m[5] = y;\n  this.m[10] = z;\n  return this;\n};\n\n/**\n * Right-handed rotation clockwise as you look from the origin to positive-X.\n * @param {number} angle\n * @returns {Matrix44}\n */\nMatrix44.prototype.toRotateXOp = function(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  this.toIdentity();\n  this.setColRowVal(1, 1, cos);\n  this.setColRowVal(2, 1, -sin);\n  this.setColRowVal(1, 2, sin);\n  this.setColRowVal(2, 2, cos);\n  return this;\n};\n\n/**\n * Right-handed rotation clockwise as you look from the origin to positive-Y.\n * @param {number} angle\n * @returns {Matrix44}\n */\nMatrix44.prototype.toRotateYOp = function(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  this.toIdentity();\n  this.setColRowVal(0, 0, cos);\n  this.setColRowVal(2, 0, sin);\n  this.setColRowVal(0, 2, -sin);\n  this.setColRowVal(2, 2, cos);\n  return this;\n};\n\n/**\n * Right-handed rotation clockwise as you look from the origin to positive-Z.\n * @param {number} angle\n * @returns {Matrix44}\n */\nMatrix44.prototype.toRotateZOp = function(angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  this.toIdentity();\n  this.setColRowVal(0, 0, cos);\n  this.setColRowVal(1, 0, -sin);\n  this.setColRowVal(0, 1, sin);\n  this.setColRowVal(1, 1, cos);\n  return this;\n};\n\nMatrix44.prototype.setColRowVal = function(col, row, val) {\n  this.m[col + 4 * row] = val;\n};\n\nMatrix44.prototype.getColRowVal = function(col, row) {\n  return this.m[col + 4 * row];\n};\n\n/**\n * Mutates this matrix by multiplying it by that one.\n * @param {Matrix44} that\n * @return {Matrix44} this, mutated\n */\nMatrix44.prototype.multiply = function(that) {\n  for (var y = 0; y < 4; y++) {\n    for (var x = 0; x < 4; x++) {\n      var val = 0;\n      for (var i = 0; i < 4; i++) {\n        val += this.m[i + 4*y] * that.m[x + 4*i];\n      }\n      Matrix44.tempArray[x + 4*y] = val;\n    }\n  }\n  for (var a = 0; a < 16; a++) {\n    this.m[a] = Matrix44.tempArray[a];\n  }\n  return this;\n};\n\nMatrix44.prototype.set = function(that) {\n  for (var i = 0; i < 16; i++) {\n    this.m[i] = that.m[i];\n  }\n  return this;\n};\n\nMatrix44.prototype.setToPose = function(pose) {\n  var temp = Matrix44.alloc();\n  var retval =  this.toTranslateOp(pose.pos)\n      .multiply(temp.toScaleOp(pose.scale))\n      .multiply(temp.toRotateZOp(pose.rotZ));\n  temp.free();\n  return retval;\n};\n\nMatrix44.prototype.equals = function(that, opt_slop) {\n  var slop = opt_slop || 0;\n  for (var i = 0; i < 16; i++) {\n    if (Math.abs(this.m[i] - that.m[i]) > slop) return false;\n  }\n  return true;\n};\n\nMatrix44.prototype.getInverse = function(out) {\n  out = out || new Matrix44();\n  // Calculate the matrix of cofactors, the adugate matrix.\n  // Divide by the determinant as we go.\n  var oneOverDet = 1/this.determinant();\n  var cofactor = Matrix33.alloc();\n  for (var y = 0; y < 4; y++) {\n    for (var x = 0; x < 4; x++) {\n      // Transpose as we go, by swapping x and y coords.\n      out.setColRowVal(y, x,\n          oneOverDet *\n          ((x % 2) ? -1 : 1) *\n          ((y % 2) ? -1 : 1) *\n          this.getCofactor(x, y, cofactor).determinant());\n    }\n  }\n  cofactor.free();\n  return out;\n};\n\nMatrix44.prototype.transpose = function() {\n  for (var y = 0; y < 3; y++) {\n    for (var x = y + 1; x < 4; x++) {\n      var temp = this.getColRowVal(x, y);\n      this.setColRowVal(x, y, this.getColRowVal(y, x));\n      this.setColRowVal(y, x, temp);\n    }\n  }\n  return this;\n};\n\nMatrix44.prototype.determinant = function() {\n  var total = 0;\n  var row = 0;\n  var cofactor = Matrix33.alloc();\n  for (var col = 0; col < 4; col++) {\n    this.getCofactor(col, row, cofactor);\n    total +=\n        ((col % 2) ? -1 : 1) *\n        this.getColRowVal(col, row) *\n        cofactor.determinant();\n  }\n  cofactor.free();\n  return total;\n};\n\nMatrix44.prototype.getCofactor = function(col, row, mat33) {\n  mat33 = mat33 || new Matrix33();\n  for (var y = 0; y < 3; y++) {\n    for (var x = 0; x < 3; x++) {\n      mat33.setColRowVal(x, y, this.getColRowVal(x + (x < col ? 0 : 1), y + (y < row ? 0 : 1)));\n    }\n  }\n  return mat33;\n};\n\nMatrix44.prototype.toString = function() {\n  return JSON.stringify(this.m);\n};\n\nMatrix44.prototype.toJSON = function() {\n  return this.m.concat();\n};\n\nMatrix44.fromJSON = function(json) {\n  return (new Matrix44()).set(json);\n};\n\n\n/* ---- js/pose.js ---- */\n\n\n/**\n * The kind of thing you need to map from model-space and world-space.\n * 4D is kind of overkill but lets not be stingy.\n * @constructor\n */\nfunction Pose(opt_pos, opt_rotZ, opt_scale) {\n  this.pos = new Vec4();\n  this.rotZ = 0;\n  this.scale = new Vec4();\n  this.reset(opt_pos, opt_rotZ, opt_scale);\n}\n\nPose.prototype.reset = function(opt_pos, opt_rotZ, opt_scale) {\n  if (opt_pos) {\n    this.pos.set(opt_pos);\n  }\n  opt_rotZ = opt_rotZ || 0;\n  this.rotZ = opt_rotZ;\n  if (opt_scale) {\n    this.scale.set(opt_scale);\n  }\n  return this;\n};\n\nPose.pool = [];\n\nPose.alloc = function(pos, rotZ, scale) {\n  if (Pose.pool.length) {\n    return Pose.pool.pop().reset(pos, rotZ, scale);\n  }\n  return new Pose(pos, rotZ, scale);\n};\n\nPose.prototype.free = function() {\n  Pose.pool.push(this);\n};\n\nPose.SCHEMA = {\n  0: \"pos\",\n  1: \"rotZ\",\n  2: \"scale\"\n};\n\nPose.getJsoner = function() {\n  if (!Pose.jsoner) {\n    Pose.jsoner = new Jsoner(Pose.SCHEMA);\n  }\n  return Pose.jsoner;\n};\n\nPose.prototype.toJSON = function() {\n  return Pose.getJsoner().toJSON(this);\n};\n\nPose.prototype.setFromJSON = function(json) {\n  Pose.getJsoner().setFromJSON(json, this);\n};\n\nPose.prototype.set = function(that) {\n  this.pos.set(that.pos);\n  this.rotZ = that.rotZ;\n  this.scale.set(that.scale);\n};\n\nPose.prototype.setToInterpolation = function(a, b, t) {\n  this.pos.setToInterpolation(a.pos, b.pos, t);\n  this.rotZ = a.rotZ * (1-t) + b.rotZ * t;\n  this.scale.setToInterpolation(a.scale, b.scale, t);\n}; \n\n\n/* ---- js/pubsub.js ---- */\n\n\n/**\n * Allows a publisher to call multiple subscriber functions at once.\n * Subscribers can add and remove themselves.\n * @constructor\n */\nPubSub = function() {\n  this.subs = new ArraySet();\n};\n\n/**\n * Adds a subscriber function.\n * @param {Object} func\n */\nPubSub.prototype.subscribe = function(func) {\n  this.subs.put(func);\n};\n\n/**\n * Deletes a subscriber function.\n * @param {Object} func\n */\nPubSub.prototype.unsubscribe = function(func) {\n  this.subs.remove(func);\n};\n\n/**\n * Calls all the subscribers in the order in which they were added,\n * passing all arguments along.  Calls the functions in the global context.\n */\nPubSub.prototype.publish = function(/* whatever */) {\n  for (var i = 0, n = this.subs.vals.length; i < n; ++i) {\n    this.subs.vals[i].apply(null, arguments);\n  }\n};\n\n/**\n * Clears the subscriber list.\n */\nPubSub.prototype.clear = function () {\n  this.subs.clear();\n};\n\n\n/* ---- js/textloader.js ---- */\n\n\n/**\n * @param {Array.<String>} paths\n * @constructor\n */\nfunction TextLoader(paths) {\n  this.paths = paths;\n  this.texts = {};\n}\n\n/**\n * @param {Function} callback\n */\nTextLoader.prototype.load = function(callback) {\n  this.callback = callback;\n  for (var i = 0; i < this.paths.length; i++) {\n    this.loadTextNum(i);\n  }\n};\n\nTextLoader.prototype.getTextByIndex = function(num) {\n  return this.getTextByPath(this.paths[num]);\n};\n\nTextLoader.prototype.getTextByPath = function(path) {\n  return this.texts[path];\n};\n\n\n/////////////\n// PRIVATE //\n/////////////\n\nTextLoader.prototype.loadTextNum = function(num) {\n  var path = this.paths[num];\n  if (!this.texts[path]) {\n    this.xhr(path, this.getOnTextLoadedFunc(num));\n  }\n};\n\nTextLoader.prototype.getOnTextLoadedFunc = function(num) {\n  var self = this;\n  return function(text) {\n    var path = self.paths[num];\n    self.texts[path] = text;\n    self.callback && self.callback(num);\n  };\n};\n\nTextLoader.prototype.xhr = function(url, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url, true);\n  xhr.responseType = 'text';\n  xhr.onload = function() {\n\t// alert(this.response);\n    callback(this.response);\n  };\n  xhr.send();\n};\n\n\n\n/* ---- js/rect.js ---- */\n\n\n\n/**\n * An axis-aligned rectangle with a center and an x and y radius (half height and half width)\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_rx\n * @param {=number} opt_ry\n * @constructor\n */\nfunction Rect(opt_x, opt_y, opt_rx, opt_ry) {\n  this.pos = new Vec2d();\n  this.rad = new Vec2d();\n  this.reset(opt_x, opt_y, opt_rx, opt_ry);\n};\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_rx\n * @param {=number} opt_ry\n */\nRect.prototype.reset = function(opt_x, opt_y, opt_rx, opt_ry) {\n  this.pos.setXY(opt_x || 0 , opt_y || 0);\n  this.rad.setXY(opt_rx || 0, opt_ry || 0);\n  return this;\n};\n\nRect.pool = [];\n\n/**\n * @param {=number} opt_x\n * @param {=number} opt_y\n * @param {=number} opt_rx\n * @param {=number} opt_ry\n */\nRect.alloc = function(opt_x, opt_y, opt_rx, opt_ry) {\n  if (Rect.pool.length) {\n    return Rect.pool.pop().reset(opt_x, opt_y, opt_rx, opt_ry);\n  }\n  return new Rect(opt_x, opt_y, opt_rx, opt_ry);\n};\n\nRect.prototype.free = function() {\n  Rect.pool.push(this);\n};\n\nRect.free = function(obj) {\n  obj.free();\n};\n\nRect.prototype.set = function(r) {\n  this.pos.set(r.pos);\n  this.rad.set(r.rad);\n  return this;\n};\n\nRect.prototype.setToCorners = function(a, b) {\n  this.pos.set(a).add(b).scale(0.5);\n  this.rad.set(a).subtract(b).scale(0.5).abs();\n  return this;\n};\n\nRect.prototype.setPos = function(v) {\n  this.pos.set(v);\n  return this;\n};\n\nRect.prototype.setRad = function(v) {\n  this.rad.set(v);\n  return this;\n};\n\nRect.prototype.setPosXY = function(x, y) {\n  this.pos.setXY(x, y);\n  return this;\n};\n\nRect.prototype.setRadXY = function(x, y) {\n  this.rad.setXY(x, y);\n  return this;\n};\n\nRect.prototype.padXY = function(x, y) {\n  this.rad.x += x;\n  this.rad.y += y;\n  return this;\n};\n\nRect.prototype.pad = function(p) {\n  this.rad.x += p;\n  this.rad.y += p;\n  return this;\n};\n\nRect.prototype.coverRect = function(that) {\n  var minX = Math.min(this.getMinX(), that.getMinX());\n  var minY = Math.min(this.getMinY(), that.getMinY());\n  var maxX = Math.max(this.getMaxX(), that.getMaxX());\n  var maxY = Math.max(this.getMaxY(), that.getMaxY());\n  this.pos.setXY((minX + maxX) / 2, (minY + maxY) / 2);\n  this.rad.setXY(Math.abs(minX - maxX) / 2, Math.abs(minY - maxY) / 2);\n  return this;\n};\n\nRect.prototype.coverVec = function(v) {\n  return this.coverXY(v.x, v.y);\n};\n\nRect.prototype.coverXY = function(x, y) {\n  var minX = Math.min(this.getMinX(), x);\n  var minY = Math.min(this.getMinY(), y);\n  var maxX = Math.max(this.getMaxX(), x);\n  var maxY = Math.max(this.getMaxY(), y);\n  this.pos.setXY((minX + maxX) / 2, (minY + maxY) / 2);\n  this.rad.setXY(Math.abs(minX - maxX) / 2, Math.abs(minY - maxY) / 2);\n  return this;\n};\n\nRect.prototype.getMinX = function() {\n  return this.pos.x - this.rad.x;\n};\n\nRect.prototype.getMinY = function() {\n  return this.pos.y - this.rad.y;\n};\n\nRect.prototype.getMaxX = function() {\n  return this.pos.x + this.rad.x;\n};\n\nRect.prototype.getMaxY = function() {\n  return this.pos.y + this.rad.y;\n};\n\nRect.prototype.getWidth = function() {\n  return this.rad.x * 2;\n};\n\nRect.prototype.getHeight = function() {\n  return this.rad.y * 2;\n};\n\nRect.prototype.overlapsRectXYXY = function(x, y, rx, ry) {\n  return Math.abs(this.pos.x - x) <= this.rad.x + rx &&\n         Math.abs(this.pos.y - y) <= this.rad.y + ry;\n};\n\n\n/* ---- js/Strings.js ---- */\n\n\n\nStrings = {};\n\nStrings.REGEXP_ESCAPE_RE_ = /([\\{\\}\\|\\^\\$\\[\\]\\(\\)\\.\\?\\*\\+\\\\\\,\\:\\!])/g;\n\nStrings.AMP_RE_ = /&/g;\nStrings.LT_RE_ = /</g;\nStrings.SQUOT_RE_ = /'/g;\nStrings.DQUOT_RE_ = /\"/g;\nStrings.EOLN_RE_ = /\\n/g;\nStrings.TWOSPACE_RE_ = /  /g;\n\n/**\n * Backslash-escapes regexp symbols.  Useful for creating regexps that match\n * literal strings.\n * @param {String} text\n * @return {String} a string for passing to the RegExp constructor\n */\nStrings.textToRegExpStr = function(text) {\n  return String(text).replace(Strings.REGEXP_ESCAPE_RE_, '\\\\$1');\n};\n\n/**\n * Converts text to HTML, including double-quotes, but not single-quotes.\n * @param {String} text\n * @param {Boolean=} opt_preserveSpaces  if true, nbsp's will replace every\n *     other space in a run of spaces, and br's will replace eolns.\n */\nStrings.textToHtml = function(text, opt_preserveSpaces) {\n  var html = String(text).\n      replace(Strings.AMP_RE_, '&amp;').\n      replace(Strings.LT_RE_, '&lt;').\n      replace(Strings.DQUOT_RE_, '&quot;');\n  if (opt_preserveSpaces) {\n    html = html.\n        replace(Strings.EOLN_RE_, '<br>').\n        replace(Strings.TWOSPACE_RE_, '&nbsp; ');\n  }\n  return html;\n};\n\n/**\n * Converts text to a string that can go between single-quotes in a JS string\n * literal.\n * @param {String} text\n * @return {String} the JS literal, with single-quotes escaped.\n */\nStrings.textToSingleQuoteJsLiteral = function(text) {\n  return String(text).\n      replace(Strings.SQUOT_RE_, '\\\\\\'').\n      replace(Strings.EOLN_RE_, '\\\\n');\n};\n\nStrings.replace = function(text, oldStr, newStr) {\n  var re = new RegExp(Strings.textToRegExpStr(oldStr), 'g');\n  // Ha-ha! Read about \"$\" here:\n  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/replace\n  var sub = newStr.replace(/\\$/g, \"$$$$\"); // Replaces one dollar-sign with two.\n  return text.replace(re, sub);\n};\n\nStrings.padLeft = function(strToPad, paddingChar, padToLength) {\n  if (paddingChar.length != 1) {\n    throw Error('Expected exactly one character, but got \"' + paddingChar + '\".');\n  }\n  if (!(strToPad instanceof String)) {\n    strToPad = String(strToPad);\n  }\n  var padSize = padToLength - strToPad.length;\n  if (padSize <= 0) {\n    return strToPad;\n  } else {\n    return Strings.repeat(paddingChar, padSize) + strToPad;\n  }\n};\n\nStrings.repeat = function(str, count) {\n  var out = [];\n  for (var i = 0; i < count; i++) {\n    out.push(str);\n  }\n  return out.join('');\n};\n\nStrings.formatTimeString = function(date) {\n  function padDateNum(num) {\n    return Strings.padLeft(num, '0', 2);\n  }\n  return date.getFullYear() + '-' +\n      padDateNum(date.getMonth() + 1) + '-' +\n      padDateNum(date.getDate()) + ' ' +\n      padDateNum(date.getHours()) + ':' +\n      padDateNum(date.getMinutes()) + ':' +\n      padDateNum(date.getSeconds()) + '.' +\n      Strings.padLeft(date.getMilliseconds(), '0', 4);\n}; \n\n\n/* ---- js/skipqueue.js ---- */\n\n\n\n/**\n * A SkipQueue priority queue, ordered by time.\n * Nodes must have a \"time\" value, and a \"next\" array.\n * @constructor\n */\nfunction SkipQueue(base, maxLevel) {\n  this.base = base;\n  this.maxLevel = maxLevel;\n  this.levelUpOdds = 1 / this.base;\n\n  this.level = this.maxLevel;\n  this.next = [];\n  this.size = 0;  \n  this.prevs = [];\n}\n\nSkipQueue.getRecommendedMaxLevel = function(expectedLength, base) {\n  return Math.ceil(Math.log(expectedLength) / Math.log(base));\n};\n\nSkipQueue.prototype.randomLevel = function() {\n  var level = 0;\n  var rand = Math.random();\n  var bar = this.levelUpOdds;\n  while (rand < bar && level < this.maxLevel) {\n    level++;\n    bar *= this.levelUpOdds;\n  }\n  return level;\n};\n\n/**\n * Add a node, in the right order.\n * @param {Object} addMe\n */\nSkipQueue.prototype.add = function(addMe) {\n  var prevs = this.prevs;\n  addMe.level = this.randomLevel();\n  \n  // set up for traversal\n  var node = this;\n\n  var next;\n  for (var level = this.maxLevel; level >= 0; --level) {\n    // right\n    next = node.next[level];\n    while (next && next.time < addMe.time) {\n      node = next;\n      next = node.next[level];\n    }\n    prevs[level] = node;\n  }\n  // For the levels that this node blocks, do inserts.\n  for (level = addMe.level; level >= 0; --level) {\n    addMe.next[level] = prevs[level].next[level];\n    prevs[level].next[level] = addMe;\n  }\n  this.size++;\n};\n\n/**\n * Returns the first node, or null if empty, and also removes it.\n */\nSkipQueue.prototype.removeFirst = function() {\n  var node = this.next[0];\n  if (!node) return null;\n  for (var level = node.level; level >= 0; --level) {\n    this.next[level] = node.next[level];\n  }\n  this.size--;\n  return node;\n};\n\n/**\n * Returns the first node without removing it.\n */\nSkipQueue.prototype.getFirst = function() {\n  return this.next[0];\n};\n\nSkipQueue.prototype.toString = function() {\n  var node = this.next[0];\n  var out = [];\n  while (node != null) {\n    out.push(node.toString());\n    node = node.next[0];\n  }\n  return '[' + out.join(',\\n') + ']';\n};\n\n\n/* ---- js/arrayset.js ---- */\n\n\n/**\n * A small set, implemented with an array.\n * It has O(n) put, remove, and contains, but it has fast iteration.\n * Good for small sets that will get iterated over a lot.\n * Chrome can optimize this, because there are no for-each loops over arbitrary keys.\n * @constructor\n */\nfunction ArraySet() {\n  this.vals = [];\n}\n\nArraySet.prototype.reset = function() {\n  this.vals.length = 0;\n  return this;\n};\n\nPoolify(ArraySet);\n\nArraySet.prototype.put = function(v) {\n  for (var i = 0; i < this.vals.length; i++) {\n    if (this.vals[i] == v) {\n      return;\n    }\n  }\n  this.vals.push(v);\n  return this;\n};\n\nArraySet.prototype.contains = function(v) {\n  for (var i = 0; i < this.vals.length; i++) {\n    if (this.vals[i] == v) {\n      return true;\n    }\n  }\n  return false;\n};\n\nArraySet.prototype.remove = function(v) {\n  for (var i = 0; i < this.vals.length; i++) {\n    if (this.vals[i] == v) {\n      this.vals[i] = this.vals[this.vals.length - 1];\n      this.vals.pop();\n    }\n  }\n  return this;\n};\n\nArraySet.prototype.clear = function(v) {\n  this.vals.length = 0;\n  return this;\n};\n\n\nArraySet.prototype.removeIndex = function(index) {\n  this.vals[index] = this.vals[this.vals.length - 1];\n  this.vals.pop();\n  return this;\n};\n\nArraySet.prototype.isEmpty = function() {\n  return this.vals.length == 0;\n};\n\nArraySet.prototype.getValues = function() {\n  return this.vals.concat();\n};\n\nArraySet.prototype.size = function() {\n  return this.vals.length;\n};\n\n\n/* ---- js/objset.js ---- */\n\n\n/**\n * A small set, implemented with an object.\n * Has the same interface as ArraySet, for easy swapping out.\n * @constructor\n */\nfunction ObjSet() {\n  this.vals = {};\n}\n\nObjSet.prototype.reset = function() {\n  for (var key in this.vals) {\n    delete this.vals[key];\n  }\n  return this;\n};\n\nPoolify(ObjSet);\n\nObjSet.prototype.put = function(v) {\n  this.vals[v] = true;\n  return this;\n};\n\nObjSet.prototype.contains = function(v) {\n  return !!this.vals[v];\n};\n\nObjSet.prototype.remove = function(v) {\n  delete this.vals[v];\n  return this;\n};\n\nObjSet.prototype.clear = function(v) {\n  return this.reset();\n};\n\n\nObjSet.prototype.isEmpty = function() {\n  for (var key in this.vals) {\n    return false;\n  }\n  return true;\n};\n\nObjSet.prototype.getValues = function() {\n  var retval = {};\n  for (var key in this.vals) {\n    retval[key] = this.vals[key];\n  }\n  return retval;\n};\n\nObjSet.prototype.size = function() {\n  var n = 0;\n  for (var key in this.vals) {\n    n++;\n  }\n  return n;\n};\n\n\n/* ---- js/map.js ---- */\n\n\n/**\n * Map class, with arbitrary keys that won't collide with any system stuff.\n * @constructor\n */\nMap = function() {\n  this.m = {};\n  this.length = 0;\n};\n\nMap.PREFIX = '=';\n\nMap.prototype.set = function(k, v) {\n  var objKey = Map.PREFIX + k;\n  if (!this.m[objKey]) this.length++;\n  this.m[objKey] = v;\n  return this;\n};\n\nMap.prototype.get = function(k) {\n  return this.m[Map.PREFIX + k];\n};\n\nMap.prototype.contains = function(k) {\n  return this.get(k) !== undefined;\n};\n\nMap.prototype.remove = function(k) {\n  var objKey = Map.PREFIX + k;\n  if (this.m[objKey]) this.length--;\n  delete this.m[objKey];\n};\n\n/**\n * @return {Array}\n */\nMap.prototype.getKeys = function() {\n  var keys = [];\n  for (var pk in this.m) {\n    keys.push(pk.substr(1));\n  }\n  return keys;\n}; \n\n\n/* ---- js/circularqueue.js ---- */\n\n\n/**\n * A circular buffer, backed by an array.\n * In this API, enqueuing adds to the head, and dequeing removes from the tail.\n * This might be backwards from what you're used to. But I wrote this when I was\n * thinking of a rotating log, so the \"head\" was the present, and the \"tail\" was the past,\n * ad you'd add the the head, and usually process the tail first. Sorry for any confusion.\n * \n * @param {number} maxLen  Must be one or more.\n * @constructor\n */\nfunction CircularQueue(maxLen) {\n  if (maxLen < 1) {\n    throw new Error('maxlen must be at least one, but it was ' + maxLen);\n  }\n  this.maxLen = maxLen;\n  this.a = [];\n  this.head = this.tail = -1;\n}\n\n/**\n * @return {boolean}\n */\nCircularQueue.prototype.isEmpty = function() {\n  return this.head == -1;\n};\n\n/**\n * @return {boolean}\n */\nCircularQueue.prototype.isFull = function() {\n  if (this.head == -1) return false;\n  var nextHead = this.head + 1;\n  if (nextHead >= this.maxLen) {\n    nextHead = 0;\n  }\n  return nextHead == this.tail;\n};\n\n/**\n * Adds an item to the head of the queue.\n * If the queue is full, an item is dropped from the tail.\n * @param val  Any value, to be enqueued.\n * @return the object that fell off the tail, or null if nothing fell off\n */\nCircularQueue.prototype.enqueue = function(val) {\n  var whatFellOff = null;\n  if (this.head == -1) {\n    // was empty\n    this.head = this.tail = 0;\n  } else {\n    this.head++;\n    if (this.head >= this.maxLen) {\n      this.head = 0;\n    }\n    if (this.head == this.tail) {\n      whatFellOff = this.a[this.tail];\n      // something falls off the tail\n      this.tail++;\n      if (this.tail >= this.maxLen) {\n        this.tail = 0;\n      }\n    }\n  }\n  this.a[this.head] = val;\n  return whatFellOff;\n};\n\n\n/**\n * @return Whatever was pulled off the tail of the queue, or null if the queue is empty.\n */\nCircularQueue.prototype.dequeue = function() {\n  if (this.tail == -1) {\n    // empty\n    return null;\n  }\n  var val = this.a[this.tail];\n  if (this.tail == this.head) {\n    // now it's empty\n    this.head = this.tail = -1;\n  } else {\n    // move tail fwd\n    this.tail++;\n    if (this.tail >= this.maxLen) {\n      this.tail = 0;\n    }\n  }\n  return val;\n};\n\n\n/**\n * @return {number} number of elements in the queue, between 0 and maxLength\n */\nCircularQueue.prototype.size = function() {\n  if (this.tail == -1) {\n    // empty\n    return 0;\n  }\n  var size = 1 + this.head - this.tail;\n  if (size <= 0) {\n    size += this.maxLen;\n  }\n  return size;\n};\n\n\n/**\n * @param {number} index gets the nth index from the tail.  Does not dequeue.\n */\nCircularQueue.prototype.getFromTail = function(index) {\n  if (index < 0) {\n    throw new Error(\"index \" + index + \" < 0\");\n  }\n  if (index >= this.size()) {\n    throw new Error(\"index \" + index + \" is greater than size \" + this.size());\n  }\n  var i = index + this.tail;\n  if (i >= this.maxLen) {\n    // wrap around\n    i -= this.maxLen;\n  }\n  return this.a[i];\n};\n\n/**\n * @param {number} index gets the nth index from the head.  Does not dequeue.\n */\nCircularQueue.prototype.getFromHead = function(index) {\n  if (index < 0) {\n    throw new Error(\"index \" + index + \" < 0\");\n  }\n  if (index >= this.size()) {\n    throw new Error(\"index \" + index + \" is greater than size \" + this.size());\n  }\n  var i = this.head - index;\n  if (i < 0) {\n    // wrap around\n    i += this.maxLen;\n  }\n  return this.a[i];\n};\n\n\n/* ---- js/url.js ---- */\n\n\nUrl = {};\n\n/**\n * Replaces the hash fragment with the string.  Does not encode.  Falsy values\n * are converted to empty-string.\n */\nUrl.setFragment = function(val) {\n  // Just setting the location.hash to the val fails to encode newlines in\n  // Safari, so we replace the whole URL.\n  // Also, setting the hash to empty-string removes the '#', causing a reload,\n  // so always add the #.\n  var href = location.href;\n  var hashIndex = href.indexOf(\"#\");\n  var nonHash = hashIndex < 0 ? href : href.substr(0, hashIndex);\n  location.replace(nonHash + \"#\" + val);\n};\n\n/**\n * Gets the encoded URL fragment, not including the leading \"#\".  Does not\n * decode.  If there's no fragment, returns emptystring.\n */\nUrl.getFragment = function() {\n  var hashIndex = window.location.href.indexOf(\"#\");\n  if (hashIndex == -1) return '';\n  return window.location.href.substr(hashIndex + 1);\n};\n\nUrl.encodeQuery = function(map) {\n  var q = [];\n  for (var key in map) {\n    q.push(encodeURIComponent(key) + '=' +\n        encodeURIComponent(map[key]));\n  }\n  return q.join('&');\n};\n\nUrl.decodeQuery = function(queryString) {\n  var map = {};\n  var params = queryString.split('&');\n  for (var i = 0; i < params.length; i++) {\n    var param = params[i];\n    var eqPos = param.indexOf('=');\n    if (eqPos > 0) {\n      var key = param.substring(0, eqPos);\n      var val = param.substring(eqPos + 1);\n    } else {\n      key = param;\n      val = '';\n    }\n    map[decodeURIComponent(key)] = decodeURIComponent(val);\n  }\n  return map;\n};\n\nUrl.getQuery = function() {\n  var s = window.location.search;\n  if (!s) return '';\n  return s.substr(1)\n};\n\nUrl.URI_CHARS =             \"!#$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz~\";\nUrl.LEGAL_HASH_CHARS =      \"!$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\";\nUrl.URI_COMPONENT_CHARS =   \"!'()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\";\n// Firefox incorrectly percent-escapes single-quotes when you do window.location.href.\nUrl.TOTES_SAFE_HASH_CHARS = \"!()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\";\n\n/**\n * Splits a percent-encoded UTF-8-encoded URL into strings representing\n * individual Unicode code points.\n * This method does not check to make sure that the input was properly\n * encoded in the first place, but it will throw exceptions if it cannot\n * decode the bits of a percent-encoded codepoint.\n * See http://en.wikipedia.org/wiki/UTF-8#Description.\n * @param url The encoded URL to tokenize\n * @return {Array} Array of strings where each element represents\n * one percent-encoded UTF-8 character.\n * So \"a%20b\" would become [\"a\", \"%20\", \"b\"],\n * and \"c d\" would still be[\"c\", \" \", \"d\"], because this function does not\n * make sure all chars that should have been encoded were actually encoded.\n */\nUrl.tokenizeEncodedUrl = function(url) {\n  var tokens = [];\n  for (var i = 0; i < url.length;) {\n    var c = url.charAt(i);\n    if (c != \"%\") {\n      tokens.push(c);\n      i++;\n      continue;\n    }\n    var bits = parseInt(url.substr(i + 1, 2), 16);\n    var len;\n    if ((0x80 & bits) == 0) {\n      // 0xxxxxxx, so the byte represents a char in the 0-127 range.\n      len = 3;\n    } else if ((0xE0 & bits) == 0xC0) {\n      // 110xxxxx\n      len = 6;\n    } else if ((0xF0 & bits) == 0xE0) {\n      // 1110xxxx\n      len = 9;\n    } else if ((0xF8 & bits) == 0xF0) {\n      // 11110xxx\n      len = 12;\n    } else if ((0xFC & bits) == 0xF8) {\n      // 111110xx\n      len = 15;\n    } else if ((0xFE & bits) == 0xFC) {\n      // 1111110x\n      len = 18;\n    } else {\n      throw Error(\"error decoding bits \" + Number(bits).toString(2));\n    }\n    tokens.push(url.substr(i, len));\n    i += len;\n  }\n  // check our work...\n  if (url != tokens.join('')) {\n    throw Error('original URL\\n' + url +\n        '\\n!= joined tokens\\n' + tokens.join(''));\n  }\n  return tokens;\n};\n\n/**\n * @param {String} c  A single character to encode.\n * @return {String} A percent-encoded string of the unicode codepoint number of the char,\n * even if it's in the ASCII range, 0-127.\n */\nUrl.percentEscapeCharacter = function(c) {\n  if (c.length != 1) {\n    throw Error('Expected exactly one character, but got \"' + c + '\".');\n  }\n  var num = c.charCodeAt(0);\n  if (num < 128) {\n    var hex = Number(num).toString(16).toUpperCase();\n    return '%' + Strings.padLeft(hex, '0', 2);\n  } else {\n    // Anything above 127 will be escaped by encodeURI.\n    var encoded = encodeURIComponent(c);\n    if (encoded.charAt(0) != '%') {\n      throw Error('expected char \"' + c +\n          '\" to get percent-escaped by encodeURI, but it turned into \"' + encoded + '\"');\n    }\n    return encoded;\n  }\n};\n\nUrl.percentEncodeUnwhitelistedChars = function(str, whitelist) {\n  var tokens = str.split('');\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n    if (whitelist.indexOf(token) == -1) {\n      tokens[i] = Url.percentEscapeCharacter(token);\n    }\n  }\n  return tokens.join('');\n}; \n\n\n\n/* ---- js/bits/base64.js ---- */\n\n\n// taken from https://bitbucket.org/davidchambers/base64.js/src\n// Adds text/base64 conversion \"atob\" and \"btoa\" to browsers that don't have it, i.e. IE.\n;(function () {\n\n  var\n      object = window,\n      chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  if (!object['btoa']) {\n    object.btoa = function (input) {\n      for (\n        // initialize result and counter\n          var block, charCode, idx = 0, map = chars, output = '';\n        // if the next input index does not exist:\n        //   change the mapping table to \"=\"\n        //   check if d has no fractional digits\n          input.charAt(idx | 0) || (map = '=', idx % 1);\n        // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n          output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n          ) {\n        charCode = input.charCodeAt(idx += 3 / 4);\n        if (charCode > 0xFF) throw Error('invalid charCode:' + charCode);\n        block = block << 8 | charCode;\n      }\n      return output;\n    };\n  }\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  if (!object['atob']) {\n      object.atob = function (input) {\n        input = input.replace(/=+$/, '');\n        if (input.length % 4 == 1) throw Error('invalid input length:' + input.length);\n        for (\n          // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = '';\n          // get next character\n            buffer = input.charAt(idx++);\n          // character found in table? initialize bit storage and add its ascii value;\n            ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n              // and if not first of each 4 characters,\n              // convert the first 8 bits to one ascii character\n                bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n            ) {\n          // try to find character in table (0-63, not found => -1)\n          buffer = chars.indexOf(buffer);\n        }\n        return output;\n      };\n  }\n}());\n\n\n/* ---- js/bits/bitqueue.js ---- */\n\n\nBitQueue = function() {\n  // Array of strings that we append to when writing, and that we\n  // consolidate into a single string when reading.\n  this.queue = [];\n  this.nextReadPos = 0;\n  this.length = 0;\n};\n\n/**\n * @param num\n * @param bitCount\n */\nBitQueue.prototype.enqueueNumber = function(num, bitCount) {\n  // todo: trim the read part off the 0th element, and reset nextReadPos.\n  var bitStr = Number(num).toString(2);\n  if (bitStr.length > bitCount) {\n    throw Error('number ' + num + ' has more bits than bitCount ' + bitCount);\n  }\n  this.queue.push(Strings.padLeft(bitStr, '0', bitCount));\n  this.length += bitCount;\n};\n\n/**\n * @param bitCount  the number of bits to consume to read a number.\n * @return {Number}\n */\nBitQueue.prototype.dequeueNumber = function(bitCount) {\n  // Smush the queue into one string before reading.\n  if (this.queue.length > 1) {\n    this.queue[0] = this.queue.join('');\n    this.queue.length = 1;\n  }\n  var queueStr = this.queue[0];\n  var queueLen = queueStr.length - this.nextReadPos;\n  if (bitCount > queueLen) {\n    throw Error('bitCount ' + bitCount + ' > queueLen ' + queueLen);\n  }\n  var bitStr = queueStr.substr(this.nextReadPos, bitCount);\n  var num = parseInt(bitStr, 2);\n  this.nextReadPos += bitCount;\n  this.length -= bitCount;\n  return num;\n};\n\n/**\n * Writes an array of chars representihg bytes into the BitQueue.\n * This is the opposite of dequeueToBytesAndPadZerosRight().\n * @param bytes\n */\nBitQueue.prototype.enqueueBytes = function(bytes) {\n  for (var i = 0; i < bytes.length; i++) {\n    this.enqueueNumber(bytes.charCodeAt(i), 8);\n  }\n};\n\n/**\n * Serializes the BitQueue to an array of characters representing numbers from 0-255.\n * This is the opposite of enqueueBytes().\n * @returns {string}\n */\nBitQueue.prototype.dequeueToBytesAndPadZerosRight = function() {\n  var bytesArray = [];\n  var tailLength = this.length % 8;\n  if (tailLength) {\n    this.enqueueNumber(0, 8 - tailLength);\n  }\n  while (this.length) {\n    var num = this.dequeueNumber(8);\n    bytesArray.push(String.fromCharCode(num));\n  }\n  return bytesArray.join('');\n};\n\n\n\n\n/* ---- js/bits/lempelziv.js ---- */\n\n\n\n/**\n * @param alphabet A string made of all the legal characters in the input.\n * @constructor\n */\nLempelZiv = function(alphabet) {\n  this.alphabet = alphabet;\n};\n\nLempelZiv.STOPCODE = 0;\n\n\nLempelZiv.prototype.contains = function(v) {\n  for (var i = 0; i < this.vals.length; i++) {\n    if (this.vals[i] == v) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @param {string} str  A string made up only of what's in the alphabet.\n * @return {Array} An array of integers.\n */\nLempelZiv.prototype.encodeToIntegers = function(str) {\n  if (str == '') {\n    return [LempelZiv.STOPCODE];\n  }\n  var w = '';\n  var result = [];\n  var dict = this.createEncodingDictionary();\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charAt(i);\n    var wc = w + c;\n    if (dict.contains(wc)) {\n      w = wc;\n    } else {\n      result.push(dict.get(w));\n      dict.set(wc, dict.length + 1);\n      w = String(c);\n    }\n  }\n\n  // Output the last code.\n  if (w !== \"\") {\n    result.push(dict.get(w));\n  }\n  result.push(LempelZiv.STOPCODE);\n  return result;\n};\n\n/**\n * @param {Array} ints  An array of integers.\n * @return {string} A string made up only of what's in the alphabet.\n */\nLempelZiv.prototype.decodeFromIntegers = function(ints) {\n  if (ints.length == 1 && ints[0] == LempelZiv.STOPCODE) {\n    return '';\n  }\n  var entry = '';\n  var dict = this.createDecodingDictionary();\n  var w = dict.get(ints[0]);\n  var result = w;\n\n  for (var i = 1; i < ints.length; i++) {\n    var k = ints[i];\n    if (k == LempelZiv.STOPCODE) {\n      break;\n    }\n    if (dict.contains(k)) {\n      entry = dict.get(k);\n    } else {\n      if (k === dict.length + 1) {\n        entry = w + w.charAt(0);\n      } else {\n        throw Error('could not decode integer ' + k);\n      }\n    }\n    result += entry;\n\n    // Add w+entry[0] to the dictionary.\n    dict.set(dict.length + 1, w + entry.charAt(0));\n\n    w = entry;\n  }\n  if (k != 0) {\n    throw Error('k:' + k + ' but expected stop-code:' + LempelZiv.STOPCODE);\n  }\n  return result;\n};\n\nLempelZiv.prototype.encodeToBitQueue = function(str, opt_bitQueue) {\n  var ints = this.encodeToIntegers(str);\n  var bitQueue = opt_bitQueue || new BitQueue();\n  var highestValuePossible = this.createEncodingDictionary().length + 1; // +1 for stopcode\n  for (var i = 0; i < ints.length; i++) {\n    var bitsNeeded = Number(highestValuePossible).toString(2).length;\n    bitQueue.enqueueNumber(ints[i], bitsNeeded);\n    highestValuePossible++;\n  }\n  return bitQueue;\n};\n\nLempelZiv.prototype.decodeFromBitQueue = function(bitQueue) {\n  var highestValuePossible = this.createEncodingDictionary().length + 1; // +1 for stopcode\n  var ints = [];\n  var num = -1;\n  while (num != LempelZiv.STOPCODE) {\n    var bitsNeeded = Number(highestValuePossible).toString(2).length;\n    num = bitQueue.dequeueNumber(bitsNeeded);\n    ints.push(num);\n    highestValuePossible++;\n  }\n  return this.decodeFromIntegers(ints);\n};\n\n/**\n * @param str The string to encode.\n * @return {String} of chars whose charCodes are from 0-255\n */\nLempelZiv.prototype.encodeToBytes = function(str) {\n//  // make sure the input only uses the legal alphabet\n//  for (var i = 0; i < str.length; i++) {\n//    if (this.alphabet.indexOf(str.charAt(i)) == -1) {\n//      throw Error('char ' + str.charAt(i) + ' not in alphabet ' + this.alphabet);\n//    }\n//  }\n  var q = this.encodeToBitQueue(str);\n  return q.dequeueToBytesAndPadZerosRight();\n};\n\n/**\n * @param {String} bytes  String of chars whose charCodes are from 0-255\n * @return {String} the decoded string\n */\nLempelZiv.prototype.decodeFromBytes = function(bytes) {\n  var q = new BitQueue();\n  q.enqueueBytes(bytes);\n  return this.decodeFromBitQueue(q);\n};\n\nLempelZiv.prototype.createEncodingDictionary = function() {\n  var dict = new Map();\n  var nextKey = 1;\n  for (var i = 0; i < this.alphabet.length; i++) {\n    dict.set(this.alphabet.charAt(i), nextKey++);\n  }\n  return dict;\n};\n\nLempelZiv.prototype.createDecodingDictionary = function() {\n  var dict = new Map();\n  var nextKey = 1;\n  for (var i = 0; i < this.alphabet.length; i++) {\n    dict.set(nextKey++, this.alphabet.charAt(i));\n  }\n  return dict;\n};\n\n\n/* ---- js/bits/squisher.js ---- */\n\n\n/**\n * String compressor that uses a configurable, optional static word list and Lempel-Ziv to losslessly compress\n * a string, finally encoding it in URL-friendly base64. Decompressor also included.\n *\n * @param staticWords An array of up to about 100 strings that will be compressed down\n * to single bytes.\n *\n * @constructor\n */\nSquisher = function(staticWords) {\n  this.staticWords = staticWords || [];\n};\n\n/**\n * Commands indicating how the rest of the data is encoded.\n * \"bytes\" always means a string where every character represents one byte.\n * @enum {string}\n */\nSquisher.Encoding = {\n  /** The rest is base64 encoded. */\n  BASE64_BYTES: 'a',\n\n  /** The rest is bytes representing an LZ-encoded bitstream. */\n  LZ_BITSTREAM: 'z',\n\n  /** The rest is static dictionary encoded bytes. */\n  DICTIONARY: 'd',\n\n  /** The rest is the original (percent-encoded to ASCII). */\n  ORIGINAL: 'o'\n};\n\n/**\n * @param {String} original\n * @return {String} the squished string in base 64\n */\nSquisher.prototype.squish = function(original) {\n  var squished = Squisher.Encoding.ORIGINAL + this.encodeToAscii(original);\n\n  var newSquished = Squisher.Encoding.DICTIONARY + this.compressWithStaticDictionary(squished);\n  if (newSquished.length < squished.length) {\n    squished = newSquished;\n  }\n\n  var lz = new LempelZiv(this.getAlphabet());\n  newSquished = Squisher.Encoding.LZ_BITSTREAM + lz.encodeToBytes(squished);\n  if (newSquished.length < squished.length) {\n    squished = newSquished;\n  }\n\n  squished = Squisher.Encoding.BASE64_BYTES + btoa(squished);\n  return squished;\n};\n\nSquisher.prototype.unsquish = function(str) {\n  var command = str.charAt(0);\n  str = str.substr(1);\n  var next;\n  if (command == Squisher.Encoding.BASE64_BYTES) {\n    next = atob(str);\n  } else if (command == Squisher.Encoding.LZ_BITSTREAM) {\n    var lz = new LempelZiv(this.getAlphabet());\n    next = lz.decodeFromBytes(str);\n  } else if (command == Squisher.Encoding.DICTIONARY) {\n    next = this.decompressWithStaticDictionary(str);\n  } else if (command == Squisher.Encoding.ORIGINAL) {\n    str = decodeURI(str);\n    // Done!\n    return str;\n  } else {\n    throw Error('unknown command ' + command + ' for str ' + str);\n  }\n  // The recursion is nice because we'll get debuggable stackframes if there's a problem.\n  return this.unsquish(next);\n};\n\nSquisher.prototype.compressWithStaticDictionary = function(str) {\n  var dict = this.getDictionary();\n  for (var i = 0; i < dict.length; i++) {\n    var entry = dict[i];\n    var byteChar = entry[0];\n    var word = entry[1];\n    str = Strings.replace(str, word, byteChar);\n  }\n  return str;\n};\n\nSquisher.prototype.decompressWithStaticDictionary = function(str) {\n  var dict = this.getDictionary();\n  for (var i = 0; i < dict.length; i++) {\n    var entry = dict[i];\n    var byteChar = entry[0];\n    var word = entry[1];\n    str = Strings.replace(str, byteChar, word);\n  }\n  return str;\n};\n\nSquisher.prototype.getAlphabet = function() {\n  if (!this.alphabet) {\n    this.initAlphabetAndDictionary()\n  }\n  return this.alphabet;\n};\n\nSquisher.prototype.getDictionary = function() {\n  if (!this.dictionary) {\n    this.initAlphabetAndDictionary();\n  }\n  return this.dictionary;\n};\n\n\n/** all the non-control lower-ASCII chars, for starters */\nSquisher.BASE_ALPHABET = ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\n\nSquisher.prototype.encodeToAscii = function(str) {\n  var out = [];\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charAt(i);\n    var charCode = str.charCodeAt(i);\n    if (c == '%' || charCode < 32 || charCode > 126) {\n      out[i] = Url.percentEscapeCharacter(c);\n    } else {\n      out[i] = c;\n    }\n  }\n  return out.join('');\n};\n\n/**\n * All dictionary words get URI encoded, because the whole string gets URI encoded as step 1.\n */\nSquisher.prototype.initAlphabetAndDictionary = function() {\n  var builder = [];\n  for (var i = 32; i <= 126; i++) {\n    builder.push(String.fromCharCode(i));\n  }\n  this.alphabet = Squisher.BASE_ALPHABET;\n\n  this.dictionary = [];\n  var nextNum = 255;\n  for (var i = 0; i < this.staticWords.length; i++) {\n    // Find an unused byte.\n    var byteChar = String.fromCharCode(nextNum);\n    while (nextNum > 1 && this.alphabet.indexOf(byteChar) != -1) {\n      byteChar = String.fromCharCode(nextNum);\n      nextNum--;\n    }\n    if (nextNum <= 1) {\n      // no more unused bytes\n      return;\n    }\n    var word = this.staticWords[i];\n    this.dictionary.push([byteChar, this.encodeToAscii(word)]);\n    this.alphabet += byteChar;\n    nextNum--;\n  }\n};\n\n\n/* ---- js/bits/jsoner.js ---- */\n\n\n/**\n * @param schema A mapping from field number to field name, like\n * {0: 'foo', 1: 'bar')\n * @constructor\n */\nfunction Jsoner(schema) {\n  this.schema = schema;\n}\n\nJsoner.prototype.toJSON = function(that) {\n  var json = [];\n  for (var fieldNum in this.schema) {\n    var fieldName = this.schema[fieldNum];\n    var thatVal = that[fieldName];\n    var jsonVal;\n    if (thatVal.toJSON) {\n      jsonVal = thatVal.toJSON();\n    } else if (thatVal == Infinity) {\n      // JSON spec doesn't include Infinity :-(\n      jsonVal = \"Infinity\";\n    } else if (thatVal == -Infinity) {\n      jsonVal = \"-Infinity\";\n    } else {\n      jsonVal = thatVal;\n    }\n    json[fieldNum] = jsonVal;\n  }\n  return json;\n};\n\nJsoner.prototype.setFromJSON = function(json, that) {\n  for (var fieldNum in this.schema) {\n    var fieldName = this.schema[fieldNum];\n    var jsonVal = json[fieldNum];\n    if (that[fieldName] && that[fieldName].setFromJSON) {\n      that[fieldName].setFromJSON(jsonVal);\n    } else if (typeof that[fieldName] == \"number\" && jsonVal == \"Infinity\") {\n      that[fieldName] = Infinity;\n    } else if (typeof that[fieldName] == \"number\" && jsonVal == \"-Infinity\") {\n      that[fieldName] = -Infinity;\n    } else {\n      that[fieldName] = jsonVal;\n    }\n  }\n};\n\n\n/* ---- js/segment.js ---- */\n\n\n/**\n * A line segment.\n * @param {Vec2d} p1\n * @param {Vec2d} p2\n * @constructor\n */\nfunction Segment(p1, p2) {\n  this.p1 = p1;\n  this.p2 = p2;\n  this.lengthSquared = p1.distanceSquared(p2);\n}\n\nSegment.prototype.distanceToPointSquared = function(p3) {\n  if (this.lengthSquared == 0) return this.p1.distanceSquared(p3);\n  var x1 = this.p1.x;\n  var y1 = this.p1.y;\n  var x2 = this.p2.x;\n  var y2 = this.p2.y;\n\n  // u is 0 at p1 and 1 at p2.\n  // Find the value of u where p3 is closest to the segment\n  var u = ((p3.x - x1)*(x2 - x1) + (p3.y - y1)*(y2 - y1)) / this.lengthSquared;\n  var retval;\n  if (u < 0) {\n    retval = p3.distanceSquared(this.p1);\n  } else if (u > 1) {\n    retval = p3.distanceSquared(this.p2);\n  } else {\n    var p = Vec2d.alloc();\n    p.set(this.p2).subtract(this.p1).scale(u).add(this.p1);\n    retval = p3.distanceSquared(p);\n    p.free();\n  }\n  return retval;\n};\n\nSegment.prototype.distanceToPointSquaredXY = function(x, y) {\n  var v = Vec2d.alloc(x, y);\n  var dist = this.distanceToPointSquared(v);\n  v.free();\n  return dist;\n};\n\nSegment.prototype.getBoundingRect = function(rectOut) {\n  if (!rectOut) rectOut = new Rect();\n  return rectOut.setToCorners(this.p1, this.p2);\n};\n\n\n/* ---- js/terrain/bitgrid.js ---- */\n\n\n/**\n * An very big grid of pixels, optimized for memory, speed, and serialization size.\n * It has over 67 million rows and columns, each holding a 32x32 subgrid of pixels.\n * Values are 0 and 1, defaulting to 0.\n * @constructor\n */\nfunction BitGrid(pixelSize) {\n  this.bitWorldSize = pixelSize;\n  this.cellWorldSize = this.bitWorldSize * BitGrid.BITS;\n\n  // A cell can be nonexistent (value 0), or have a value of 1, or an array of 32 32-bit integers forming a\n  // 32x32 pixel subgrid.\n  this.cells = {};\n\n  // A map from touched cellIds to their old values, so callers can see which were modified.\n  this.changedCells = {};\n}\n\n/**\n * Quadtree compression assumes that this is a power of 2.\n * JavaScript bitwise operations only work on the first 32 bits of a number.\n * So 32 is a good number.\n * @type {number}\n */\nBitGrid.BITS = 32;\n\n// It's got over 67 million columns.\nBitGrid.COLUMNS = 0x4000000;\n\nBitGrid.ROW_OF_ONES = (function() {\n  var row = 0;\n  for (var i = 0; i < BitGrid.BITS; i++) {\n    row |= (1 << i);\n  }\n  return row;\n})();\n\nBitGrid.prototype.cellIdToIndexVec = function(cellId, out) {\n  if (!out) out = new Vec2d();\n  var cy = Math.floor(cellId / BitGrid.COLUMNS);\n  var cx = cellId - cy * BitGrid.COLUMNS - BitGrid.COLUMNS / 2;\n  out.setXY(cx, cy);\n  return out;\n};\n\nBitGrid.prototype.flushChangedCellIds = function() {\n  var changedIds = [];\n  for (var id in this.changedCells) {\n    if (this.changedCells[id] != this.cells[id]) {\n      changedIds.push(id);\n    }\n  }\n  this.changedCells = {};\n  return changedIds;\n};\n\nBitGrid.prototype.getRectsOfColorForCellId = function(color, cellId) {\n  var bx, by;\n  var self = this;\n  function createRect(bx0, by0, bx1, by1) {\n    var wx0 = cx * self.cellWorldSize + (bx0 - 0.5) * self.bitWorldSize;\n    var wy0 = cy * self.cellWorldSize + (by0 - 0.5) * self.bitWorldSize;\n    var wx1 = cx * self.cellWorldSize + (bx1 + 0.5) * self.bitWorldSize;\n    var wy1 = cy * self.cellWorldSize + (by1 + 0.5) * self.bitWorldSize;\n    return new Rect(\n        (wx0 + wx1)/2, (wy0 + wy1)/2, (wx1 - wx0)/2, (wy1 - wy0)/2);\n  }\n\n  var cy = Math.floor(cellId / BitGrid.COLUMNS);\n  var cx = cellId - cy * BitGrid.COLUMNS - BitGrid.COLUMNS / 2;\n  var rects = [];\n  var cell = this.cells[cellId];\n  if (this.cellEqualsColor(cell, color)) {\n    rects.push(new Rect(\n        (cx + 0.5) * this.cellWorldSize - this.bitWorldSize/2,\n        (cy + 0.5) * this.cellWorldSize - this.bitWorldSize/2,\n        this.cellWorldSize / 2,\n        this.cellWorldSize / 2));\n  } else if (Array.isArray(cell)) {\n\n    var oldRects = {};\n    for (by = 0; by < BitGrid.BITS; by++) {\n      var newRects = {};\n      var runStartX = -1;\n      // Record newRects in this row.\n      for (bx = 0; bx < BitGrid.BITS; bx++) {\n        var bit = (cell[by] >> bx) & 1;\n        if (bit == color) {\n          // Color match.\n          if (runStartX < 0) {\n            // First bit on the row.\n            runStartX = bx;\n            newRects[runStartX] = {startY: by, endX: bx};\n          } else {\n            // Continue run\n            newRects[runStartX].endX = bx;\n          }\n        } else {\n          // Not a color match.\n          runStartX = -1;\n        }\n      }\n      var isLastRow = by == BitGrid.BITS - 1;\n      for (bx = 0; bx < BitGrid.BITS; bx++) {\n        var oldRect = oldRects[bx];\n        var newRect = newRects[bx];\n        // Harvest unmatched old ones.\n        if (oldRect && newRect && oldRect.endX == newRect.endX) {\n          // This is a merge, unless we're on the last row, in which case we harvest.\n          if (isLastRow) {\n            // last row harvest\n            rects.push(createRect(bx, oldRect.startY, oldRect.endX, by));\n          }\n        } else {\n          // old and new are not equal start/end (or maybe not existent)\n          if (oldRect) {\n            // harvest and delete\n            rects.push(createRect(bx, oldRect.startY, oldRect.endX, by - 1));\n            delete oldRects[bx];\n          }\n          if (newRect) {\n            if (isLastRow) {\n              // make rect on this row\n              rects.push(createRect(bx, newRect.startY, newRect.endX, by));\n            } else {\n              // graduate\n              oldRects[bx] = newRects[bx];\n            }\n          }\n        }\n      }\n    }\n  }\n  return rects;\n};\n\n/**\n * @returns {Number} the grid cell X index that corresponds with world coord X.\n */\nBitGrid.prototype.getCellIndexX = function(x) {\n  return Math.floor(x / this.cellWorldSize);\n};\n\n/**\n * @return {Number} the grid cell Y index that corresponds with world coord Y.\n */\nBitGrid.prototype.getCellIndexY = function(y) {\n  return Math.floor(y / this.cellWorldSize);\n};\n\nBitGrid.prototype.getCellIdAtIndexXY = function(cx, cy) {\n  return BitGrid.COLUMNS * cy + cx + BitGrid.COLUMNS/2;\n};\n\nBitGrid.prototype.getCellAtIndexXY = function(cx, cy) {\n  return this.cells[this.getCellIdAtIndexXY(cx, cy)];\n};\n\nBitGrid.prototype.setCellAtIndexXY = function(cx, cy, cell) {\n  this.cells[this.getCellIdAtIndexXY(cx, cy)] = cell;\n};\n\nBitGrid.prototype.deleteCellAtIndexXY = function(cx, cy) {\n  delete this.cells[this.getCellIdAtIndexXY(cx, cy)];\n};\n\nBitGrid.prototype.cellEqualsColor = function(cell, color) {\n  return !Array.isArray(cell) && ((color == 0 && !cell) || (color == 1 && cell === 1));\n};\n\nBitGrid.prototype.drawPill = function(seg, rad, color) {\n  // bounding rect\n  var rect = seg.getBoundingRect(this.rect).pad(rad);\n  var cx0 = this.getCellIndexX(rect.getMinX());\n  var cy0 = this.getCellIndexY(rect.getMinY());\n  var cx1 = this.getCellIndexX(rect.getMaxX());\n  var cy1 = this.getCellIndexY(rect.getMaxY());\n  for (var cx = cx0; cx <= cx1; cx++) {\n    for (var cy = cy0; cy <= cy1; cy++) {\n      var cell = this.getCellAtIndexXY(cx, cy);\n      if (!this.cellEqualsColor(cell, color)) {\n        this.drawPillOnCellIndexXY(seg, rad, color, cx, cy);\n      }\n    }\n  }\n};\n\nBitGrid.prototype.drawPillOnCellIndexXY = function(seg, rad, color, cx, cy) {\n  var pixelCenter = Vec2d.alloc();\n  var cell = this.getCellAtIndexXY(cx, cy);\n\n  var cellId = this.getCellIdAtIndexXY(cx, cy);\n  var clean = !(cellId in this.changedCells);\n\n  var radSquared = rad * rad;\n  var isArray = Array.isArray(cell);\n  var startingColor = isArray ? 0.5 : (cell ? 1 : 0);\n  var zeroRows = 0;\n  var oneRows = 0;\n  for (var by = 0; by < BitGrid.BITS; by++) {\n    var oldRowVal = isArray ? cell[by] : (startingColor ? BitGrid.ROW_OF_ONES : 0);\n    var newRowVal = oldRowVal;\n    pixelCenter.y = cy * this.cellWorldSize + by * this.bitWorldSize;\n    for (var bx = 0; bx < BitGrid.BITS; bx++) {\n      pixelCenter.x = cx * this.cellWorldSize + bx * this.bitWorldSize;\n      if (seg.distanceToPointSquared(pixelCenter) <= radSquared) {\n        newRowVal = color\n            ? (newRowVal | (1 << bx))\n            : (newRowVal & (BitGrid.ROW_OF_ONES ^ (1 << bx)));\n      }\n    }\n    if (newRowVal == 0) {\n      zeroRows++;\n    } else if (newRowVal == BitGrid.ROW_OF_ONES) {\n      oneRows++;\n    }\n\n    if (newRowVal != oldRowVal) {\n      // If it was clean to start with, then preserve the clean value in changedCells.\n      if (clean) {\n        this.changedCells[cellId] = Array.isArray(cell) ? cell.concat() : cell;\n        clean = false;\n      }\n      // If it wasn't an array already, make it one now so we can adjust this row.\n      if (!isArray) {\n        cell = this.createCellArray(startingColor);\n        this.setCellAtIndexXY(cx, cy, cell);\n        isArray = true;\n      }\n      cell[by] = newRowVal;\n    }\n  }\n\n  // Simplify the grid?\n  if (zeroRows == BitGrid.BITS) {\n    this.deleteCellAtIndexXY(cx, cy);\n  } else if (oneRows == BitGrid.BITS) {\n    this.setCellAtIndexXY(cx, cy, 1);\n  }\n  pixelCenter.free();\n};\n\nBitGrid.prototype.createCellArray = function(color) {\n  var cell = new Array(BitGrid.BITS);\n  var rowVal = color ? BitGrid.ROW_OF_ONES : 0;\n  for (var i = 0; i < BitGrid.BITS; i++) {\n    cell[i] = rowVal;\n  }\n  return cell;\n};\n\nBitGrid.SOLID = 1;\nBitGrid.DETAILED = 0;\n\n/**\n * The \"cells\" field is an object where\n * each key is a cellId in base 32,\n * and each value is a base64-encoded BitQueue quadtree representation of the cell.\n * @returns {{bitWorldSize: *, cells: {}}}\n */\nBitGrid.prototype.toJSON = function() {\n  function enqueueQuad(startX, startY, size) {\n    var startColor = (cell[startY] & (1 << startX)) ? 1 : 0;\n    if (size == 1) {\n      bitQueue.enqueueNumber(startColor, 1);\n      return;\n    }\n    for (var by = startY; by < startY + size; by++) {\n      for (var bx = startX; bx < startX + size; bx++) {\n        var pixel = (cell[by] & (1 << bx)) ? 1 : 0;\n        if (pixel != startColor) {\n          // non-uniform square. Lets get quadruple recursive!\n          bitQueue.enqueueNumber(BitGrid.DETAILED, 1);\n          var half = size/2;\n          enqueueQuad(startX, startY, half);\n          enqueueQuad(startX + half, startY, half);\n          enqueueQuad(startX, startY + half, half);\n          enqueueQuad(startX + half, startY + half, half);\n          return;\n        }\n      }\n    }\n    // uniform square\n    bitQueue.enqueueNumber(BitGrid.SOLID, 1);\n    bitQueue.enqueueNumber(startColor, 1);\n  }\n\n  var json = {\n    bitWorldSize: this.bitWorldSize,\n    cells:{}\n  };\n  for (var cellId in this.cells) {\n    var cell = this.cells[cellId];\n    var bitQueue = new BitQueue();\n    if (Array.isArray(cell)) {\n      enqueueQuad(0, 0, BitGrid.BITS);\n    } else {\n      // Uniform cell\n      bitQueue.enqueueNumber(BitGrid.SOLID, 1);\n      bitQueue.enqueueNumber(cell, 1);\n    }\n    json.cells[Number(cellId).toString(32)] = btoa(bitQueue.dequeueToBytesAndPadZerosRight());\n  }\n  return json;\n};\n\nBitGrid.fromJSON = function(json) {\n  function plot(x, y, c) {\n    if (c) {\n      cell[y] |= 1 << x;\n    } else {\n      cell[y] &= BitGrid.ROW_OF_ONES ^ (1 << x);\n    }\n  }\n\n  function dequeueQuad(startX, startY, size) {\n    var color;\n    if (size == 1) {\n      color = bitQueue.dequeueNumber(1);\n      plot(startX, startY, color);\n      return;\n    }\n    var kind = bitQueue.dequeueNumber(1);\n    if (kind == BitGrid.SOLID) {\n      color = bitQueue.dequeueNumber(1);\n      for (var by = startY; by < startY + size; by++) {\n        for (var bx = startX; bx < startX + size; bx++) {\n          plot(bx, by, color);\n        }\n      }\n    } else {\n      // DETAILED\n      var half = size/2;\n      dequeueQuad(startX, startY, half);\n      dequeueQuad(startX + half, startY, half);\n      dequeueQuad(startX, startY + half, half);\n      dequeueQuad(startX + half, startY + half, half);\n    }\n  }\n\n  var bitGrid = new BitGrid(json.bitWorldSize);\n  for (var cellId32 in json.cells) {\n    var cellId = parseInt(cellId32, 32);\n    var cellBytes = atob(json.cells[cellId32]);\n    var bitQueue = new BitQueue();\n    bitQueue.enqueueBytes(cellBytes);\n    var cell = bitGrid.createCellArray(0);\n    dequeueQuad(0, 0, 32);\n    bitGrid.cells[cellId] = cell;\n\n    // Mark this cell as dirty. Its old value was 0, the default full-empty value.\n    bitGrid.changedCells[cellId] = 0;\n  }\n  return bitGrid;\n};\n\n// Old naive serializer/deserializer.\n//BitGrid.prototype.toJSON = function() {\n//  return {\n//    bitWorldSize: this.bitWorldSize,\n//    cells: this.cells\n//  };\n//};\n//\n//BitGrid.fromJSON = function(json) {\n//  var bitGrid = new BitGrid(json.bitWorldSize);\n//  bitGrid.cells = json.cells;\n//  return bitGrid;\n//};\n\n\n// ----------------------- WEBGL ----------------------\n\n\n\n/* ---- js/webgl/buttonmaker.js ---- */\n\n\n/**\n * Adds clickable buttons to the world and the GL.\n * @param labelMaker\n * @param world\n * @param multiPointer\n * @param renderer\n * @constructor\n */\nfunction ButtonMaker(labelMaker, world, multiPointer, renderer) {\n  this.labelMaker = labelMaker;\n  this.world = world;\n  this.multiPointer = multiPointer;\n  this.renderer = renderer;\n\n  this.startMatrix = new Matrix44();\n  this.nextCharMatrix = new Matrix44().toTranslateOpXYZ(3, 0, 0);\n  this.letterColor = [1, 1, 1];\n  this.blockColor = [0.5, 0.5, 0.5];\n  this.padding = new Vec2d(0.5, 0.5);\n\n  this.scale = 1;\n}\n\n/**\n * @param {Matrix44} m\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setStartMatrix = function(m) {\n  this.startMatrix = m;\n  return this;\n};\n\n/**\n * @param {Matrix44} m\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setNextCharMatrix = function(m) {\n  this.nextCharMatrix = m;\n  return this;\n};\n\n/**\n * @param {Array.<number>} c\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setLetterColor = function(c) {\n  this.letterColor = c;\n  return this;\n};\n\n/**\n * @param {Array.<number>} c\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setBlockColor = function(c) {\n  this.blockColor = c;\n  return this;\n};\n\n/**\n * @param {number} x\n * @param {number} y\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setPaddingXY = function(x, y) {\n  this.padding.setXY(x, y);\n  return this;\n};\n\n/**\n * @param {number} s\n * @returns {ButtonMaker}\n */\nButtonMaker.prototype.setScale = function(s) {\n  this.scale = s;\n  return this;\n};\n\n/**\n * Adds a button body and spirit to the world, and a button model to GL.\n * @param {number} x\n * @param {number} y\n * @param {string} text\n * @param {function} func or null for no callback\n * @return {number} The ID of the spirit added to the world.\n */\nButtonMaker.prototype.addButton = function(x, y, text, func) {\n  var labelModel = this.labelMaker.createLabelModel(this.startMatrix, this.nextCharMatrix, text);\n  labelModel.transformPositions(new Matrix44().toScaleOpXYZ(this.scale, this.scale, this.scale));\n  var brect = labelModel.getBoundingRect();\n  if (this.padding) {\n    brect.padXY(this.padding.x, this.padding.y);\n  }\n  labelModel.transformPositions(new Matrix44().toTranslateOpXYZ(-brect.pos.x, -brect.pos.y, 0));\n  for (var i = 0; i < labelModel.vertexes.length; i++) {\n    labelModel.vertexes[i].setColorArray(this.letterColor);\n  }\n\n  if (this.blockColor) {\n    var cuboid = RigidModel.createCube();\n    cuboid.transformPositions(new Matrix44().toScaleOpXYZ(brect.rad.x, brect.rad.y, 1));\n    cuboid.transformPositions(new Matrix44().toTranslateOpXYZ(0, 0, 1));\n    for (var i = 0; i < cuboid.vertexes.length; i++) {\n      cuboid.vertexes[i].setColorArray(this.blockColor);\n    }\n    labelModel.addRigidModel(cuboid);\n    labelModel.transformPositions(new Matrix44().toTranslateOpXYZ(0, 0, -1));\n  }\n  var stamp = labelModel.createModelStamp(this.renderer.gl);\n\n  var b = Body.alloc();\n  b.shape = Body.Shape.RECT;\n  var pos = new Vec2d(x, y);\n  b.setPosAtTime(pos, this.world.now);\n  b.rectRad.set(brect.rad);\n  b.group = 0;\n  b.mass = Infinity;\n  b.pathDurationMax = Infinity;\n  var spirit = new ButtonSpirit();\n  spirit.bodyId = this.world.addBody(b);\n  if (this.multiPointer) {\n    // TODO: remove multipointer from buttons completely?\n    spirit.setMultiPointer(this.multiPointer);\n  }\n  spirit.setModelStamp(stamp);\n  spirit.setOnClick(func);\n  return this.world.addSpirit(spirit);\n};\n\n\n\n/* ---- js/webgl/camera.js ---- */\n\n\nfunction Camera(minDistFraction, maxDistFraction, viewDist) {\n  this.cameraPos = new Vec2d();\n  this.minDistFraction = minDistFraction;\n  this.maxDistFraction = maxDistFraction;\n  this.viewDist = viewDist;\n}\n\nCamera.prototype.follow = function(followPos) {\n  var cameraDist = followPos.distance(this.cameraPos);\n  var minCameraDist = this.viewDist * this.minDistFraction;\n  var maxCameraDist = this.viewDist * this.maxDistFraction;\n\n  // Move towards min dist\n  if (cameraDist > minCameraDist) {\n    var temp = Vec2d.alloc();\n    temp.set(followPos)\n        .subtract(this.cameraPos)\n        .scaleToLength((cameraDist-minCameraDist) * 0.1)\n        .add(this.cameraPos);\n    this.cameraPos.set(temp);\n    cameraDist = followPos.distance(this.cameraPos);\n\n    // Clip to max dist\n    if (cameraDist > maxCameraDist) {\n      temp.set(followPos)\n          .subtract(this.cameraPos)\n          .scaleToLength(cameraDist - maxCameraDist)\n          .add(this.cameraPos);\n      this.cameraPos.set(temp);\n    }\n    temp.free();\n  }\n};\n\nCamera.prototype.add = function(vec) {\n  this.cameraPos.add(vec);\n};\n\nCamera.prototype.setXY = function(x, y) {\n  this.cameraPos.setXY(x, y);\n};\n\nCamera.prototype.getX = function() {\n  return this.cameraPos.x;\n};\n\nCamera.prototype.getY = function() {\n  return this.cameraPos.y;\n};\n\nCamera.prototype.getViewDist = function() {\n  return this.viewDist;\n};\n\nCamera.prototype.setViewDist = function(d) {\n  this.viewDist = d;\n  return this;\n};\n\n\n\n/* ---- js/webgl/splash.js ---- */\n\n\n\n/**\n * @constructor\n */\nfunction Splash(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration) {\n  this.type = 0;\n  this.stamp = null;\n  this.startPose = new Pose();\n  this.endPose = new Pose();\n  this.startPose2 = new Pose();\n  this.endPose2 = new Pose();\n  this.startColor = new Vec4();\n  this.endColor = new Vec4();\n  this.startTime = 0;\n  this.duration = 0;\n  this.reset(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration);\n}\n\nSplash.prototype.reset = function(\n    type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration) {\n  this.type = type || -1;\n  this.stamp = stamp || null;\n  startPose ? this.startPose.set(startPose) : this.startPose.reset();\n  endPose ? this.endPose.set(endPose) : this.endPose.reset();\n  startPose2 ? this.startPose2.set(startPose2) : this.startPose2.reset();\n  endPose2 ? this.endPose2.set(endPose2) : this.endPose2.reset();\n  startColor ? this.startColor.set(startColor) : this.startColor.reset();\n  endColor ? this.endColor.set(endColor) : this.endColor.reset();\n  this.startTime = startTime || 0;\n  this.duration = duration || 0;\n  return this;\n};\n\nSplash.pool = [];\n\nSplash.alloc = function(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration) {\n  if (Splash.pool.length) {\n    return Splash.pool.pop().reset(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration);\n  }\n  return new Splash(type, stamp, startPose, endPose, startPose2, endPose2, startColor, endColor, startTime, duration);\n};\n\nSplash.prototype.free = function() {\n  Splash.pool.push(this);\n};\n\nSplash.SCHEMA = {\n  0: \"type\",\n  1: \"startPose\",\n  2: \"endPose\",\n  3: \"startPose2\",\n  4: \"endPose2\",\n  5: \"startColor\",\n  6: \"endColor\",\n  7: \"startTime\",\n  8: \"duration\"\n};\n\nSplash.getJsoner = function() {\n  if (!Splash.jsoner) {\n    Splash.jsoner = new Jsoner(Splash.SCHEMA);\n  }\n  return Splash.jsoner;\n};\n\nSplash.prototype.toJSON = function() {\n  return Splash.getJsoner().toJSON(this);\n};\n\nSplash.prototype.setFromJSON = function(json) {\n  Splash.getJsoner().setFromJSON(json, this);\n};\n\nSplash.prototype.set = function(that) {\n  this.type = that.type;\n  this.stamp = that.stamp;\n  this.startPose.set(that.startPose);\n  this.endPose.set(that.endPose);\n  this.startPose2.set(that.startPose2);\n  this.endPose2.set(that.endPose2);\n  this.startColor.set(that.startColor);\n  this.endColor.set(that.endColor);\n  this.startTime = that.startTime;\n  this.duration = that.duration;\n  return this;\n};\n\nSplash.prototype.isVisible = function(time) {\n  return this.startTime <= time && time <= this.startTime + this.duration;\n};\n\nSplash.prototype.isExpired = function(time) {\n  return this.startTime + this.duration < time;\n};\n\nSplash.tempPose = new Pose();\n\nSplash.prototype.getModelMatrix = function(time, out) {\n  Splash.tempPose.setToInterpolation(this.startPose, this.endPose, (time - this.startTime) / this.duration);\n  return out.setToPose(Splash.tempPose);\n};\n\nSplash.prototype.getModelMatrix2 = function(time, out) {\n  Splash.tempPose.setToInterpolation(this.startPose2, this.endPose2, (time - this.startTime) / this.duration);\n  return out.setToPose(Splash.tempPose);\n};\n\nSplash.prototype.getColor = function(time, out) {\n  return out.setToInterpolation(this.startColor, this.endColor, (time - this.startTime) / this.duration);\n}; \n\n\n\n/* ---- js/webgl/splasher.js ---- */\n\n\n\n/**\n * @constructor\n */\nfunction Splasher() {\n  this.splashes = [];\n  this.matrix44 = new Matrix44();\n  this.vec4 = new Vec4();\n}\n\nSplasher.prototype.addCopy = function(copyMe) {\n  this.splashes.push(Splash.alloc().set(copyMe));\n};\n\nSplasher.prototype.draw = function(renderer, now) {\n  for (var i = 0; i < this.splashes.length;) {\n    var splash = this.splashes[i];\n    if (splash.isExpired(now)) {\n      // remove\n      splash.free();\n      this.splashes[i] = this.splashes[this.splashes.length - 1];\n      this.splashes.pop();\n    } else {\n      if (splash.isVisible(now)) {\n        renderer\n            .setStamp(splash.stamp)\n            .setColorVector(splash.getColor(now, this.vec4))\n            .setModelMatrix(splash.getModelMatrix(now, this.matrix44))\n            .setModelMatrix2(splash.getModelMatrix2(now, this.matrix44))\n            .drawStamp();\n      }\n      i++;\n    }\n  }\n};\n\n\n/* ---- js/webgl/fanbufferbuilder.js ---- */\n\n\nfunction FanBufferBuilder(gl) {\n  this.gl = gl;\n  this.pos = [];\n  this.color = [];\n  this.count = 0;\n}\n\nFanBufferBuilder.prototype.addCircle = function(pos, pz, rad, cornerCount, red, green, blue, alpha) {\n  this.pos.push(pos.x, pos.y, pz);\n  this.color.push(red, green, blue, alpha);\n  for (var i = 0; i <= cornerCount; i++) {\n    this.pos.push(\n            pos.x + rad * Math.sin(2 * Math.PI * i / cornerCount),\n            pos.y + rad * Math.cos(2 * Math.PI * i / cornerCount),\n        pz);\n    this.color.push(red, green, blue, 1);\n  }\n  this.count = cornerCount + 2;\n};\n\nFanBufferBuilder.prototype.getTriangleCount = function() {\n  return this.count;\n};\n\nFanBufferBuilder.prototype.createPositionBuff = function() {\n  return createStaticGlBuff(this.gl, this.pos);\n};\n\nFanBufferBuilder.prototype.createColorBuff = function() {\n  return createStaticGlBuff(this.gl, this.color);\n};\n\n\n\n/* ---- js/webgl/glyphmaker.js ---- */\n\n\n/**\n * Helps build glyph (printable character) RigidModel objects.\n * @param lineWidth\n * @param glyphDepth\n * @constructor\n */\nfunction GlyphMaker(lineWidth, glyphDepth) {\n  this.lineWidth = lineWidth;\n  this.glyphDepth = glyphDepth;\n\n  this.rigidModel = new RigidModel();\n  this.mat = new Matrix44();\n  this.vec = new Vec4();\n}\n\nGlyphMaker.prototype.clear = function() {\n  this.rigidModel.clear();\n};\n\nGlyphMaker.prototype.addStick = function(x0, y0, x1, y1) {\n  var len = Vec2d.distance(x0, y0, x1, y1) + this.lineWidth;\n  var fat = this.lineWidth/2;\n  var cuboid = RigidModel.createCube();\n\n  // scale to the final size\n  cuboid.transformPositions(this.mat.toScaleOp(this.vec.setXYZ(len/2, fat, this.glyphDepth/2)));\n\n  // translate so x0, y0 is at the origin\n  cuboid.transformPositions(this.mat.toTranslateOp(this.vec.setXYZ(len/2 - fat, 0, 0)));\n\n  // rotate to final angle\n  cuboid.transformPositions(this.mat.toRotateZOp(Math.atan2(y1 - y0, x1 - x0)));\n\n  // move to final position\n  cuboid.transformPositions(this.mat.toTranslateOp(this.vec.setXYZ(x0, y0, 0)));\n\n  this.rigidModel.addRigidModel(cuboid);\n};\n\nGlyphMaker.prototype.addToRigidModel = function(target) {\n  target.addRigidModel(this.rigidModel);\n  return target;\n};\n\n\n/* ---- js/webgl/glyphs.js ---- */\n\n\n/**\n * A collection of printable characters, as ModelStamp objects in the \"stamps\" map.\n * @param glyphMaker\n * @constructor\n */\nfunction Glyphs(glyphMaker) {\n  this.glyphMaker = glyphMaker;\n  this.models = null;\n  this.stamps = null;\n}\n\nGlyphs.prototype.initModels = function() {\n  this.models = {};\n  var r = this.glyphMaker.lineWidth / 2;\n  var h = 1.5;\n  var w = 1;\n  var self = this;\n  function g() {\n    self.glyphMaker.clear();\n    for (var i = 1; i < arguments.length; i+=4) {\n      self.glyphMaker.addStick(arguments[i], arguments[i + 1], arguments[i + 2], arguments[i + 3]);\n    }\n    self.models[arguments[0]] = self.glyphMaker.addToRigidModel(new RigidModel());\n  }\n  g('A',\n      -w, -h,  -r/5, h,\n      w, -h,  r/5, h,\n      -w/2, -h * 0.33, w/2, -h * 0.33);\n  g('B',\n      -w, h, -w, -h,\n      -w, h, w * 0.33, h,\n      w * 0.33, h, w * 0.33, 0,\n      -w, 0, w, 0,\n      w, 0, w, -h,\n      w, -h, -w, -h);\n  g('C',\n      -w + r, h, w/2, h,\n      -w, h - r, -w, -h + r,\n      -w + r, -h, w - r, -h);\n  g('D',\n      -w, h - r, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, 0,\n      w - r/2, r, -w, h);\n  g('E',\n      w * 0.5, h, -w, h,\n      -w, h, -w, -h,\n      -w, -h, w, -h,\n      -w, 0, w * 0.5, 0);\n  g('F',\n      w, h, -w, h,\n      -w, h, -w, -h,\n      -w, 0, w * 0.33, 0);\n  g('G',\n      w * 0.5, h, -w, h,\n      -w, h, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, 0,\n      w * 0.2, 0, w * 1.2, 0);\n  g('H',\n      -w, h, -w, -h,\n      w, h, w, -h,\n      w, 0, -w, 0);\n  g('I',\n      0, h, 0, -h,\n      -w, h, w, h,\n      -w, -h, w, -h);\n  g('J',\n      -w, -h * 0.33, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, h);\n  g('K',\n      -w, h, -w, -h,\n      -w * (1 - r), -h * 0.2, w * 0.6, h * 0.6,\n      -w * 0.2, 0, w, -h);\n  g('L',\n      -w, h, -w, -h,\n      -w, -h, w, -h);\n  g('M',\n      -w, -h, -w, h,\n      -w + r*0.6, h - r/2, -r*0.2, h * 0.33,\n      -r*0.2, h * 0.33, w - r*0.6, h - r/2,\n      w, h, w, -h);\n  g('N',\n      -w, -h, -w, h,\n      -w + r/2, h - r/2, w - r/2, -h + r/2,\n      w, -h, w, h);\n  g('O',\n      -w, h - r, -w, -h + r,\n      -w + r, h, w - r, h,\n      w, h - r, w, -h + r,\n      -w + r, -h, w - r, -h);\n  g('P',\n      -w, h, -w, -h,\n      -w, h, w, h,\n      w, h, w, 0,\n      w, 0, -w, 0);\n  g('Q',\n      -w, h - r, -w, -h + r,\n      -w + r, h, w - r, h,\n      w, h - r, w, -h + r,\n      -w + r, -h, w - r, -h,\n      w * 0.4, -h * 0.4, w * 1.4, -h);\n  g('R',\n      -w, h, -w, -h,\n      -w, h, w, h,\n      w, h, w, 0,\n      w, 0, -w, 0,\n      0, -r, w, -h);\n  g('S',\n      w, h, -w/2 + r, h,\n      -w/2, h - r/2, -w, h/2,\n      -w, h/2, w, -h/2,\n      w, -h/2, w/2, -h + r/2,\n      w/2 - r, -h, -w, -h);\n  g('T',\n      w, h, -w, h,\n      0, h, 0, -h);\n  g('U',\n      -w, h, -w, -h + r,\n      w, h, w, -h + r,\n      -w + r, -h, w - r, -h);\n  g('V',\n      -w, h,  -r/5, -h,\n      w, h,  r/5, -h);\n  g('W',\n      -w, h, -w, -h,\n      -w + r*0.6, -h + r/3, -r*0.2, -h * 0.5,\n      -r*0.2, -h * 0.5, w - r*0.6, -h + r/3,\n      w, -h, w, h);\n  g('X',\n      -w, h, w, -h,\n      w, h, -w, -h);\n  g('Y',\n      -w, h, -r/2, 0,\n      w, h, r/2, 0,\n      0, 0, 0, -h);\n  g('Z',\n      -w, h, w, h,\n      w, h - r/2, -w, -h + r/2,\n      -w, -h, w, -h);\n\n  g('0',\n      -w, h, -w, -h,\n      -w, h, w, h,\n      w, h, w, -h,\n      -w, -h, w, -h,\n      w - r, h - r, -w + r, -h + r);\n  g('1',\n      -w, h, 0 - r, h,\n      0, h, 0, -h,\n      -w, -h, w, -h);\n  g('2',\n      -w * 2/3, h, w, h,\n      w, h, w, 0,\n      w, 0, -w, 0,\n      -w, 0, -w, -h,\n      -w, -h, w, -h);\n  g('3',\n      -w, h, w, h,\n      w, h, w, -h,\n      -w, -h, w, -h,\n          -w/2, 0, w, 0);\n  g('4',\n      -w, h * 2/3, -w, 0,\n      -w, 0, w, 0,\n      w, h, w, -h);\n  g('5',\n      -w, h, w, h,\n      -w, h, -w, 0,\n      w, 0, -w, 0,\n      w, 0, w, -h,\n      -w, -h, w, -h);\n  g('6',\n      w * 2/3, h, -w, h,\n      -w, h, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, 0,\n      w, 0, -w, 0);\n  g('7',\n      -w, h, w, h,\n      w, h - r, 0, -h);\n  g('8',\n      w, h, -w, h,\n      -w, h, -w, -h,\n      -w, -h, w, -h,\n      w, -h, w, h,\n      w, 0, -w, 0);\n  g('9',\n      w, 0, -w, 0,\n      -w, 0, -w, h,\n      -w, h, w, h,\n      w, h, w, -h);\n\n  g(' ');\n  g('.',\n      0, -h, 0, -h);\n  g(',',\n      0, -h, -w/3, -h * 4/3);\n  g('\\'',\n      0, h, 0, h * 4/3);\n  g('\"',\n      r*2, h, r*2, h * 4/3,\n      -r*2, h, -r*2, h * 4/3);\n  g('?',\n      0, -h, 0, -h,\n      0, -h/3, 0, 0,\n      0, 0, w, 0,\n      w, 0, w, h,\n      w, h, -w, h,\n      -w, h, -w, h * 2/3);\n  g('!',\n      0, -h, 0, -h,\n      0, -h/3, 0, h);\n  g(':',\n      0, -h, 0, -h,\n      0, h/3, 0, h/3);\n  g(';',\n      0, -h, -w/3, -h * 4/3,\n      0, h/3, 0, h/3);\n  g('-',\n      -w, 0, w, 0);\n  g('+',\n      -w, 0, w, 0,\n      0, -w, 0, w);\n};\n\nGlyphs.prototype.initStamps = function(gl) {\n  if (this.stamps) return;\n\n  if (!this.models) {\n    this.initModels();\n  }\n  this.stamps = {};\n  for (var key in this.models) {\n    this.stamps[key] = this.models[key].createModelStamp(gl);\n  }\n  return this.stamps;\n};\n\n\n/* ---- js/webgl/labelmaker.js ---- */\n\n\n/**\n * @constructor\n */\nfunction LabelMaker(glyphs) {\n  this.glyphs = glyphs;\n}\n\nLabelMaker.prototype.createLabelModel = function(startMatrix, nextCharMatrix, text) {\n  this.glyphs.initModels();\n  var labelModel = new RigidModel();\n  var mutableGlyph = new RigidModel();\n  var matrix = new Matrix44();\n  matrix.set(startMatrix);\n  for (var i = 0; i < text.length; i++) {\n    var originalGlyph = this.glyphs.models[text.charAt(i)];\n    if (originalGlyph) {\n      mutableGlyph.clear().addRigidModel(originalGlyph);\n      mutableGlyph.transformPositions(matrix);\n      labelModel.addRigidModel(mutableGlyph);\n    }\n    matrix.multiply(nextCharMatrix);\n  }\n  return labelModel;\n};\n\n\n/* ---- js/webgl/modelstamp.js ---- */\n\n\n/**\n * Holds the GL values needed to prepare GL to render a model.\n * Use a RigidModel to create a ModelStamp.\n * @param glType probably gl.TRIANGLES\n * @param posBuff GL vertex position buffer, with four floats per position\n * @param colorBuff GL vertex color buffer, with four floats per position\n * @param groupBuff vertex group number buffer, with one float per position\n * @param indexBuff pointer to the element index buffer\n * @param indexCount the total number of index values. Ten triangles would be thirty.\n * @constructor\n */\nfunction ModelStamp(glType, posBuff, colorBuff, groupBuff, indexBuff, indexCount) {\n  this.glType = glType;\n  this.posBuff = posBuff;\n  this.colorBuff = colorBuff;\n  this.groupBuff = groupBuff;\n  this.indexBuff = indexBuff;\n  this.indexCount = indexCount;\n}\n\n\nModelStamp.prototype.prepareToDraw = function(gl, aVertexPosition, aVertexColor, aVertexGroup) {\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuff);\n  gl.vertexAttribPointer(aVertexPosition, 4, gl.FLOAT, false, 0, 0);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuff);\n  gl.vertexAttribPointer(aVertexColor, 4, gl.FLOAT, false, 0, 0);\n\n  if (typeof aVertexGroup != 'undefined') {\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.groupBuff);\n    gl.vertexAttribPointer(aVertexGroup, 1, gl.FLOAT, false, 0, 0);\n  }\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuff);\n};\n\nModelStamp.prototype.draw = function(gl) {\n  gl.drawElements(this.glType, this.indexCount, gl.UNSIGNED_SHORT, 0);\n};\n\nModelStamp.prototype.dispose = function(gl) {\n  gl.deleteBuffer(this.posBuff);\n  gl.deleteBuffer(this.colorBuff);\n  gl.deleteBuffer(this.groupBuff);\n  gl.deleteBuffer(this.indexBuff);\n  this.glType = null;\n  this.posBuff = null;\n  this.colorBuff = null;\n  this.groupBuff = null;\n  this.indexBuff = null;\n  this.indexCount = null;\n};\n\n\n/* ---- js/webgl/printer.js ---- */\n\n\n/**\n * @constructor\n */\nfunction Printer(renderer, glyphs) {\n  this.renderer = renderer;\n  this.glyphs = glyphs;\n\n  this.matrix = new Matrix44();\n}\n\nPrinter.prototype.printLine = function(startMatrix, nextCharMatrix, text) {\n  this.matrix.set(startMatrix);\n  for (var i = 0; i < text.length; i++) {\n    var glyph = this.glyphs[text.charAt(i)];\n    if (glyph) {\n      this.renderer.setStamp(glyph);\n      this.renderer.setModelMatrix(this.matrix);\n      this.renderer.drawStamp();\n    }\n    this.matrix.multiply(nextCharMatrix);\n  }\n};\n\n\n/* ---- js/webgl/renderer.js ---- */\n\n\n/**\n * The renderer has the viewport state,\n * manages uniforms and attributes,\n * and can draw a ModelStamp.\n * @param canvas\n * @param gl\n * @param program\n * @constructor\n */\nfunction Renderer(canvas, gl, program) {\n  this.canvas = canvas;\n  this.gl = gl;\n  this.program = program;\n  this.initAttributesAndUniforms();\n}\n\nRenderer.prototype.initAttributesAndUniforms = function() {\n  this.createVertexAttribute('aVertexPosition');\n  this.createVertexAttribute('aVertexColor');\n  this.createVertexAttribute('aVertexGroup');\n  this.createUniform('uViewMatrix');\n  this.createUniform('uModelMatrix');\n  this.createUniform('uModelMatrix2');\n  this.createUniform('uModelColor');\n};\n\nRenderer.prototype.createVertexAttribute = function(name) {\n  this[name] = this.gl.getAttribLocation(this.program, name);\n  this.gl.enableVertexAttribArray(this[name]);\n};\n\nRenderer.prototype.createUniform = function(name) {\n  this[name] = this.gl.getUniformLocation(this.program, name);\n};\n\n/**\n * @return {Renderer}\n */\nRenderer.prototype.resize = function() {\n  if (this.canvas.width != this.canvas.clientWidth ||\n      this.canvas.height != this.canvas.clientHeight) {\n    this.canvas.width = this.canvas.clientWidth;\n    this.canvas.height = this.canvas.clientHeight;\n    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n  }\n  return this;\n};\n\n/**\n * @return {Renderer}\n */\nRenderer.prototype.clear = function() {\n  this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n  return this;\n};\n\n/**\n * @return {Renderer}\n */\nRenderer.prototype.setBlendingEnabled = function(blend) {\n  if (blend) {\n    this.gl.enable(this.gl.BLEND);\n    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE)\n  } else {\n    this.gl.disable(this.gl.BLEND);\n  }\n  return this;\n};\n\n/**\n * @return {Renderer}\n */\nRenderer.prototype.clearColor = function(r, g, b, a) {\n  this.gl.clearColor(r, g, b, a);\n  return this;\n};\n\n/**\n * @param {Matrix44} viewMatrix\n * @return {Renderer}\n */\nRenderer.prototype.setViewMatrix = function(viewMatrix) {\n  this.viewMatrix = viewMatrix;\n  this.gl.uniformMatrix4fv(this.uViewMatrix, this.gl.FALSE, viewMatrix.m);\n  return this;\n};\n\n/**\n * @return {Matrix44} A reference to the inner viewMatrix, which may change.\n */\nRenderer.prototype.getViewMatrix = function() {\n  return this.viewMatrix;\n};\n\n/**\n * Sets the shader's model matrix uniform.\n * @param {Matrix44} modelMatrix\n * @return {Renderer}\n */\nRenderer.prototype.setModelMatrix = function(modelMatrix) {\n  this.gl.uniformMatrix4fv(this.uModelMatrix, this.gl.FALSE, modelMatrix.m);\n  return this;\n};\n\n/**\n * Sets the shader's second model matrix uniform.\n * @param {Matrix44} modelMatrix2\n * @return {Renderer}\n */\nRenderer.prototype.setModelMatrix2 = function(modelMatrix2) {\n  this.gl.uniformMatrix4fv(this.uModelMatrix2, this.gl.FALSE, modelMatrix2.m);\n  return this;\n};\n\n/**\n * Sets the shader's color vector uniform.\n * @param {Vec4} colorVector\n * @return {Renderer}\n */\nRenderer.prototype.setColorVector = function(colorVector) {\n  this.gl.uniform4fv(this.uModelColor, colorVector.v);\n  return this;\n};\n\n/**\n * Prepares for stamp() calls.\n * @param {ModelStamp} stamp\n * @return {Renderer}\n */\nRenderer.prototype.setStamp = function(stamp) {\n  this.modelStamp = stamp;\n  stamp.prepareToDraw(this.gl, this.aVertexPosition, this.aVertexColor, this.aVertexGroup);\n  return this;\n};\n\n/**\n * Draws the ModelStamp set by setStamp(), with the current\n * modelMatrix, colorVector, and view uniforms.\n * @return {Renderer}\n */\nRenderer.prototype.drawStamp = function() {\n  this.modelStamp.draw(this.gl);\n  return this;\n};\n\n\n/* ---- js/webgl/rendererloader.js ---- */\n\n\n/**\n * Asynchronously creates a Renderer by loading and compiling shaders.\n * @param canvas\n * @param {String} vertexShaderPath\n * @param {String} fragmentShaderPath\n * @constructor\n */\nfunction RendererLoader(canvas, vertexShaderPath, fragmentShaderPath) {\n  this.canvas = canvas;\n  this.textLoader = new TextLoader([vertexShaderPath, fragmentShaderPath]);\n  this.renderer = null;\n}\n\n/**\n * @param callback called with the renderer as a parameter, when the renderer is loaded\n */\nRendererLoader.prototype.load = function(callback) {\n  this.callback = callback;\n  var self = this;\n  this.textLoader.load(function() {\n    self.invalidate();\n  });\n};\n\nRendererLoader.prototype.invalidate = function() {\n  var vsText = this.textLoader.getTextByIndex(0);\n  var fsText = this.textLoader.getTextByIndex(1);\n  if (!this.renderer && vsText && fsText) {\n    var gl = getWebGlContext(this.canvas, {\n      alpha: false,\n      antialias: true\n    });\n    var vs = compileShader(gl, vsText, gl.VERTEX_SHADER);\n    var fs = compileShader(gl, fsText, gl.FRAGMENT_SHADER);\n    var program = createProgram(gl, vs, fs);\n    gl.enable(gl.DEPTH_TEST);\n    gl.useProgram(program);\n    this.renderer = new Renderer(this.canvas, gl, program);\n    this.callback(this.renderer);\n  }\n};\n\n\n/* ---- js/webgl/rigidmodel.js ---- */\n\n\n/**\n * A way to create, combine, and manipulate a 3D model in JS.\n * This is not optimized for repeated real-time use. It's meant to\n * be used during setup.\n * Generates static ModelStamp objects, which are meant to be used at runtime.\n * @constructor\n */\nfunction RigidModel() {\n  this.vertexes = [];\n  this.triangles = [];\n}\n\nRigidModel.prototype.clear = function() {\n  this.vertexes.length = 0;\n  this.triangles.length = 0;\n  return this;\n};\n\n/**\n * @param {Vertex} vertex\n * @return {number} the new vertex's index\n */\nRigidModel.prototype.addVertex = function(vertex) {\n  this.vertexes.push(vertex);\n  return this.vertexes.length - 1;\n};\n\n/**\n * Add the indexes of existing vertexes so the counter-clockwise face is showing.\n * @param {number} vertIndex0\n * @param {number} vertIndex1\n * @param {number} vertIndex2\n * @return {number} the new triangle's index\n */\nRigidModel.prototype.addTriangle = function(vertIndex0, vertIndex1, vertIndex2) {\n  this.triangles.push([vertIndex0, vertIndex1, vertIndex2]);\n  return this.triangles.length - 1;\n};\n\n/**\n * Adds a deep copy of a model \"that\" to this model.\n * @param {RigidModel} that\n * @return {RigidModel} this\n */\nRigidModel.prototype.addRigidModel = function(that) {\n  // Map that's vertex indexes to their new indexes in this.\n  var i, vertexMap = {};\n  for (i = 0; i < that.vertexes.length; i++) {\n    vertexMap[i] = this.addVertex(that.vertexes[i].copy());\n  }\n  for (i = 0; i < that.triangles.length; i++) {\n    var thatTri = that.triangles[i];\n    this.addTriangle(\n        vertexMap[thatTri[0]],\n        vertexMap[thatTri[1]],\n        vertexMap[thatTri[2]]);\n  }\n  return this;\n};\n\n/**\n * @return {Rect} the bounding rect, or null if there are no vertexes\n */\nRigidModel.prototype.getBoundingRect = function() {\n  if (!this.vertexes.length) {\n    return null;\n  }\n  var vert = this.vertexes[0];\n  var rect = new Rect(vert.position.v[0], vert.position.v[1], 0, 0);\n  for (var i = 1; i < this.vertexes.length; i++) {\n    vert = this.vertexes[i];\n    rect.coverXY(vert.position.v[0], vert.position.v[1]);\n  }\n  return rect;\n};\n\n/**\n * Mutates all the vertex positions in this model.\n * @param {Matrix44} matrix\n * @return {RigidModel} this\n */\nRigidModel.prototype.transformPositions = function(matrix) {\n  for (var i = 0; i < this.vertexes.length; i++) {\n    this.vertexes[i].transformPosition(matrix);\n  }\n  return this;\n};\n\n/**\n * Sets all the vertex colors in this model.\n * @return {RigidModel} this\n */\nRigidModel.prototype.setColorRGB = function(r, g, b) {\n  for (var i = 0; i < this.vertexes.length; i++) {\n    this.vertexes[i].setColorRGB(r, g, b);\n  }\n  return this;\n};\n\n/**\n * Mutates the vertexes by moving each towards or away from a centerpoint,\n * so they're all the same radius from it.\n * @param {Vec4} center\n * @param {number} radius\n * @return {RigidModel} this\n */\nRigidModel.prototype.sphereize = function(center, radius) {\n  for (var i = 0; i < this.vertexes.length; i++) {\n    var p = this.vertexes[i].position;\n    p.subtract(center).scaleToLength(radius).add(center);\n  }\n  return this;\n};\n\n/**\n * Creates a new RigidModel just like this one, but replaces all triangles with\n * four co-planer triangles covering the same area, creating a new vertex in the\n * middle of each edge. Color values for the new vertexes are the average of the\n * original two points along the edge.\n */\nRigidModel.prototype.createQuadrupleTriangleModel = function() {\n  var m = new RigidModel();\n  function childName(index0, index1) {\n    return (index0 < index1) ? index0 + \"_\" + index1 : index1 + \"_\" + index0;\n  }\n  // Each key is a name of a vertex - either the original parent vert index,\n  // or a name created by joining two parent IDs.\n  // Each value is a new model vertex index.\n  var namedVerts = {};\n  for (var ti = 0; ti < this.triangles.length; ti++) {\n    var oldTri = this.triangles[ti];\n    // copy original verts, as needed\n    for (var i = 0; i < 3; i++) {\n      var vi = oldTri[i];\n      // map old vertex index to new one\n      if (!(vi in namedVerts)) {\n        namedVerts[vi] = m.addVertex(this.vertexes[vi].copy());\n      }\n    }\n    // create children in the middle of edges, as needed\n    for (var i = 0; i < 3; i++) {\n      var parent0Index = oldTri[i];\n      var parent1Index = oldTri[(i + 1) % 3];\n      var name = childName(parent0Index, parent1Index);\n      if (!(name in namedVerts)) {\n        var parent0 = this.vertexes[parent0Index];\n        var parent1 = this.vertexes[parent1Index];\n        var newVert = parent0.copy();\n        newVert.position.add(parent1.position).scale1(0.5);\n        // I'm assuming alpha is always 1, so if that changes, change this to average alpha, too.\n        newVert.color.add(parent1.color).scale1(0.5);\n        namedVerts[name] = m.addVertex(newVert);\n      }\n    }\n    // manually add triangles using the new vertexes\n    var a = namedVerts[oldTri[0]];\n    var b = namedVerts[oldTri[1]];\n    var c = namedVerts[oldTri[2]];\n    var ab = namedVerts[childName(oldTri[0], oldTri[1])];\n    var bc = namedVerts[childName(oldTri[1], oldTri[2])];\n    var ac = namedVerts[childName(oldTri[0], oldTri[2])];\n    m.addTriangle(a, ab, ac);\n    m.addTriangle(ab, b, bc);\n    m.addTriangle(ac, bc, c);\n    m.addTriangle(ab, bc, ac);\n  }\n  return m;\n};\n\n/**\n * Adds immutable snapshot data to GL and returns a handle to it.\n * @param gl\n * @returns {ModelStamp}\n */\nRigidModel.prototype.createModelStamp = function(gl) {\n  var i, positionArray = [], colorArray = [], groupArray = [];\n  for (i = 0; i < this.vertexes.length; i++) {\n    var vertex = this.vertexes[i];\n    for (var d = 0; d < 4; d++) {\n      positionArray.push(vertex.position.v[d]);\n      colorArray.push(vertex.color.v[d]);\n    }\n    groupArray.push(vertex.group || 0);\n  }\n  var posBuff = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, posBuff);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionArray), gl.STATIC_DRAW);\n\n  var colorBuff = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuff);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorArray), gl.STATIC_DRAW);\n\n  var groupBuff = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, groupBuff);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(groupArray), gl.STATIC_DRAW);\n\n  var elementsArray = [];\n  for (i = 0; i < this.triangles.length; i++) {\n    var triangle = this.triangles[i];\n    for (var v = 0; v < 3; v++) {\n      elementsArray.push(triangle[v]);\n    }\n  }\n  var elementBuff = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuff);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(elementsArray), gl.STATIC_DRAW);\n\n  return new ModelStamp(gl.TRIANGLES,\n      posBuff,\n      colorBuff,\n      groupBuff,\n      elementBuff, elementsArray.length\n  );\n};\n\n/**\n * Creates a unit-square, with points at 1 and -1 along each dimension X and Y, with Z=0,\n * so edge-length is 2 and area is 4.\n * @returns {RigidModel}\n */\nRigidModel.createSquare = function() {\n  var m = new RigidModel();\n  var v = [];\n  for (var y = -1; y <= 1; y+= 2) {\n    for (var x = -1; x <= 1; x+= 2) {\n      v.push(m.addVertex(new Vertex().setPositionXYZ(x, y, 0).setColorRGB(1, 1, 1)));\n    }\n  }\n  function face(nw, ne, sw, se) {\n    m.addTriangle(v[nw], v[sw], v[ne]);\n    m.addTriangle(v[se], v[ne], v[sw]);\n  }\n  // 2   3\n  //\n  // 0   1\n  face(2, 3, 0, 1);\n  return m;\n};\n\n/**\n * Creates an equalateral triangle, with one point on the positive Y axis and two with negative Y and varying X,\n * sized so it covers a unit circle. The highest Y is 2 and the lowest is -1.\n * @returns {RigidModel}\n */\nRigidModel.createTriangle = function() {\n  var m = new RigidModel();\n  var top = new Vertex().setPositionXYZ(0, 2, 0).setColorRGB(1, 1, 1);\n  var right = top.copy().transformPosition(new Matrix44().toRotateZOp(2*Math.PI/3));\n  var left = top.copy().transformPosition(new Matrix44().toRotateZOp(-2*Math.PI/3));\n  var topIndex = m.addVertex(top);\n  var leftIndex = m.addVertex(left);\n  var rightIndex = m.addVertex(right);\n  m.addTriangle(topIndex, leftIndex, rightIndex);\n  return m;\n};\n\n/**\n * Creates a unit-circle model made of a mesh of mostly equilateral triangles, except for those with vertexes which\n * have been pulled towards the center to prevent them from protruding outside the circle.\n * @param depth The number of createQuadrupleTriangleModel() calls to make on the starting triangle, resulting\n * in something like depth^4 triangles.\n * @returns {RigidModel}\n */\n\nRigidModel.createCircleMesh = function(depth) {\n  var model = RigidModel.createTriangle();\n  for (var i = 0; i < depth; i++) {\n    model = model.createQuadrupleTriangleModel();\n  }\n  // Remove triangles outside circle.\n  var outsiders = [];\n  var circleRadius = 1;\n  for (var t = 0; t < model.triangles.length;) {\n    var tri = model.triangles[t];\n    outsiders.length = 0;\n    for (var v = 0; v < 3; v++) {\n      var vert = model.vertexes[tri[v]];\n      if (vert.position.magnitude() > circleRadius) {\n        outsiders.push(vert);\n      }\n    }\n    if (outsiders.length == 3) {\n      // All verts are outside the circle. Remove the triangle.\n      model.triangles[t] = model.triangles[model.triangles.length - 1];\n      model.triangles.pop();\n    } else {\n      // Reposition outside verts to be on the circle's edge.\n      for (var o = 0; o < outsiders.length; o++) {\n        outsiders[o].position.scaleToLength(circleRadius);\n      }\n      t++;\n    }\n  }\n  return model;\n};\n\nRigidModel.createRingMesh = function(depth, innerRadius) {\n  var model = RigidModel.createCircleMesh(depth);\n\n  // Remove triangles inside inner circle.\n  var insiders = [];\n  for (var t = 0; t < model.triangles.length;) {\n    var tri = model.triangles[t];\n    insiders.length = 0;\n    for (var v = 0; v < 3; v++) {\n      var vert = model.vertexes[tri[v]];\n      if (vert.position.magnitude() <= innerRadius) {\n        insiders.push(vert);\n      }\n    }\n    if (insiders.length == 3) {\n      // All verts are inside ring. Remove the triangle.\n      model.triangles[t] = model.triangles[model.triangles.length - 1];\n      model.triangles.pop();\n    } else {\n      // Reposition inside verts to be on the circle's edge.\n      for (var i = 0; i < insiders.length; i++) {\n        insiders[i].position.scaleToLength(innerRadius);\n      }\n      t++;\n    }\n  }\n  return model;\n};\n\n/**\n * Creates a model for a white unit circle on the XY plane, where there are two vertexes at each position,\n * one in group 0 and one in group 1. Group 0 and Group 1 are opposite ends of this dimensionless tube.\n * @param corners\n * @returns {RigidModel}\n */\nRigidModel.createDoubleRing = function(corners) {\n  var m = new RigidModel(), v = [], i;\n  for (i = 0; i < corners; i++) {\n    var a = 2 * Math.PI * i / corners;\n    v.push(m.addVertex(new Vertex().setPositionXYZ(Math.sin(a), Math.cos(a), 0).setColorRGB(1, 1, 1).setGroup(0)));\n    v.push(m.addVertex(new Vertex().setPositionXYZ(Math.sin(a), Math.cos(a), 0).setColorRGB(1, 1, 1).setGroup(1)));\n  }\n  function face(nw, ne, sw, se) {\n    m.addTriangle(v[nw], v[sw], v[ne]);\n    m.addTriangle(v[se], v[ne], v[sw]);\n  }\n  for (i = 0; i < v.length; i += 2) {\n    // 0 2\n    // 1 3\n    face(i, (i + 2) % v.length, i + 1, (i + 3) % v.length);\n  }\n\n  return m;\n};\n\n/**\n * Creates a unit-cube, with points at 1 and -1 along each dimension,\n * so edge-length is 2 and volume is 8.\n * @returns {RigidModel}\n */\nRigidModel.createCube = function() {\n  var m = new RigidModel();\n  var v = [];\n  for (var z = -1; z <= 1; z+= 2) {\n    for (var y = -1; y <= 1; y+= 2) {\n      for (var x = -1; x <= 1; x+= 2) {\n        v.push(m.addVertex(new Vertex().setPositionXYZ(x, y, z).setColorRGB(1, 1, 1)));\n      }\n    }\n  }\n  function face(nw, ne, sw, se) {\n    m.addTriangle(v[nw], v[sw], v[ne]);\n    m.addTriangle(v[se], v[ne], v[sw]);\n  }\n  // 2   3\n  //  6   7\n  //\n  // 0   1\n  //  4   5\n  face(4, 5, 0, 1); // bottom\n  face(2, 3, 6, 7); // top\n  face(6, 7, 4, 5); // front\n  face(3, 2, 1, 0); // back\n  face(2, 6, 0, 4); // left\n  face(7, 3, 5, 1); // right\n  return m;\n};\n\n/**\n * Creates a four-faced triangular pyramid, with one edge parallel to the Y axis,\n * and one edge parallel to the X axis. Edges have a length of 2.\n * @returns {RigidModel}\n */\nRigidModel.createTetrahedron = function() {\n  var m = new RigidModel();\n  var dz = Math.sqrt(2) / 2;\n  var a = m.addVertex(new Vertex().setPositionXYZ(0, 1, -dz).setColorRGB(1, 1, 1));\n  var b = m.addVertex(new Vertex().setPositionXYZ(0, -1, -dz).setColorRGB(1, 1, 1));\n  var c = m.addVertex(new Vertex().setPositionXYZ(1, 0, dz).setColorRGB(1, 1, 1));\n  var d = m.addVertex(new Vertex().setPositionXYZ(-1, 0, dz).setColorRGB(1, 1, 1));\n  m.addTriangle(a, d, c);\n  m.addTriangle(a, b, d);\n  m.addTriangle(a, c, b);\n  m.addTriangle(b, c, d);\n  return m;\n};\n\n/**\n * Creates an eight-faced shape with a vertex at 1 and -1 on every axis.\n * @returns {RigidModel}\n */\nRigidModel.createOctahedron = function() {\n  var m = new RigidModel();\n  function v(x, y, z) {\n    return m.addVertex(new Vertex().setPositionXYZ(x, y, z).setColorRGB(1, 1, 1));\n  }\n  var a = v(1, 0, 0);\n  var b = v(-1, 0, 0);\n  var c = v(0, 1, 0);\n  var d = v(0, -1, 0);\n  var e = v(0, 0, 1);\n  var f = v(0, 0, -1);\n  m.addTriangle(c, e, a);\n  m.addTriangle(c, a, f);\n  m.addTriangle(c, f, b);\n  m.addTriangle(c, b, e);\n  m.addTriangle(d, e, b);\n  m.addTriangle(d, a, e);\n  m.addTriangle(d, f, a);\n  m.addTriangle(d, b, f);\n  return m;\n};\n\n\n/* ---- js/webgl/screen.js ---- */\n\n\n/**\n * Abstract base class for an object that can listen for events, and draw to the canvas.\n * The details of canvas and renderer initilization and setting are up to the subclasses.\n * @constructor\n */\nfunction Screen() {\n}\n\n/**\n * @param {boolean} listening Whether to listen for events or not.\n */\nScreen.prototype.setScreenListening = function(listening) {\n};\n\n/**\n * Do physics and drawing, optionally lazily initializing first.\n * @param {number} visibility from 0 to 1\n */\nScreen.prototype.drawScreen = function(visibility) {\n};\n\n/**\n * Unload resources that cannot garbage-collect themselves, like WebGL data.\n */\nScreen.prototype.destroyScreen = function() {\n};\n\n\n/* ---- js/webgl/trianglebufferbuilder.js ---- */\n\n\nfunction TriangleBufferBuilder(gl) {\n  this.gl = gl;\n  this.pos = [];\n  this.color = [];\n  this.count = 0;\n}\n\nTriangleBufferBuilder.prototype.addRect = function(pos, pz, rectRad, red, green, blue, alpha) {\n  // Two triangles form a rect.\n  this.pos.push(\n      pos.x-rectRad.x, pos.y-rectRad.y, pz,\n      pos.x-rectRad.x, pos.y+rectRad.y, pz,\n      pos.x+rectRad.x, pos.y+rectRad.y, pz,\n\n      pos.x+rectRad.x, pos.y+rectRad.y, pz,\n      pos.x+rectRad.x, pos.y-rectRad.y, pz,\n      pos.x-rectRad.x, pos.y-rectRad.y, pz);\n  for (var i = 0; i < 6; i++) {\n    this.color.push(red, green, blue, alpha);\n  }\n  this.count += 2;\n};\n\nTriangleBufferBuilder.prototype.getTriangleCount = function() {\n  return this.count;\n};\n\nTriangleBufferBuilder.prototype.createPositionBuff = function() {\n  return createStaticGlBuff(this.gl, this.pos);\n};\n\nTriangleBufferBuilder.prototype.createColorBuff = function() {\n  return createStaticGlBuff(this.gl, this.color);\n};\n\n\n/* ---- js/webgl/vertex.js ---- */\n\n\n/**\n * @constructor\n */\nfunction Vertex() {\n  this.position = new Vec4();\n  this.color = new Vec4();\n  this.group = 0;\n}\n\nVertex.prototype.setPositionXYZ = function(x, y, z) {\n  this.position.setXYZ(x, y, z);\n  return this;\n};\n\nVertex.prototype.setPositionArray = function(xyz) {\n  this.setPositionXYZ(xyz[0], xyz[1], xyz[2]);\n  return this;\n};\n\nVertex.prototype.setColorRGB = function(r, g, b) {\n  this.color.setXYZ(r, g, b);\n  return this;\n};\n\nVertex.prototype.setColorArray = function(rgb) {\n  this.setColorRGB(rgb[0], rgb[1], rgb[2]);\n  return this;\n};\n\nVertex.prototype.setGroup = function(g) {\n  this.group = g;\n  return this;\n};\n\n/**\n * @returns {Vertex} a deep copy of this vertex\n */\nVertex.prototype.copy = function() {\n  var copy = new Vertex();\n  copy.position.set(this.position);\n  copy.color.set(this.color);\n  copy.group = this.group;\n  return copy;\n};\n\n/**\n * @param {Matrix44} matrix\n * @return {Vertex} this\n */\nVertex.prototype.transformPosition = function(matrix) {\n  this.position.transform(matrix);\n  return this;\n};\n\n/**\n * @param {Matrix44} matrix\n * @return {Vertex} this\n */\nVertex.prototype.transformColor = function(matrix) {\n  this.color.transform(matrix);\n  return this;\n};\n\n\n\n/* ---- js/webgl/webglutil.js ---- */\n\n\n/**\n * Gets a WebGL context from a canvas\n * @param canvas\n * @param paramObj\n * @return {WebGLRenderingContext}\n */\nfunction getWebGlContext(canvas, paramObj) {\n  if (paramObj) {\n    return canvas.getContext('experimental-webgl', paramObj) || canvas.getContext('webgl', paramObj);\n  } else {\n    return canvas.getContext('experimental-webgl') || canvas.getContext('webgl');\n  }\n}\n\n/**\n * Creates and compiles a shader.\n * @param {!WebGLRenderingContext} gl\n * @param {string} shaderSource The GLSL source code for the shader.\n * @param {number} shaderType The type of shader, gl.VERTEX_SHADER or\n *     gl.FRAGMENT_SHADER.\n * @return {!WebGLShader} The shader.\n */\nfunction compileShader(gl, shaderSource, shaderType) {\n  var shader = gl.createShader(shaderType);\n  gl.shaderSource(shader, shaderSource);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n  }\n  return shader;\n}\n\n/**\n * Creates a program from 2 shaders.\n * @param {!WebGLRenderingContext} gl\n * @param {!WebGLShader} vertexShader\n * @param {!WebGLShader} fragmentShader\n * @return {!WebGLProgram}\n */\nfunction createProgram(gl, vertexShader, fragmentShader) {\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    throw 'program filed to link:' + gl.getProgramInfoLog(program);\n  }\n  return program;\n}\n\n/**\n * @param {!WebGLRenderingContext} gl\n * @param values\n * @returns {WebGLBuffer}\n */\nfunction createStaticGlBuff(gl, values) {\n  var buff = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buff);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(values), gl.STATIC_DRAW);\n  return buff;\n}\n\n// Make WebStorm 8 happy\nif (!'WebGLRenderingContext' in window) {\n  throw 'WebGLRenderingContext undefined!';\n  (function(){\n    var f = function(){};\n    window.WebGLRenderingContext = {\n      LINK_STATUS: 1,\n      COMPILE_STATUS: 1,\n      VERTEX_SHADER: 1,\n      FRAGMENT_SHADER: 1,\n      DEPTH_TEST: 1,\n      SRC_ALPHA: 1,\n      BLEND: 1,\n      LESS: 1,\n      ONE: 1,\n      TRUE: 1,\n      FALSE: 1,\n      COLOR_BUFFER_BIT: 1,\n      DEPTH_BUFFER_BIT: 1,\n      FLOAT: 1,\n      UNSIGNED_SHORT: 1,\n      TRIANGLES: 1,\n      TRIANGLE_STRIP: 1,\n      TRIANGLE_FAN: 1,\n      STATIC_DRAW: 1,\n      DYNAMIC_DRAW: 1,\n      STREAM_DRAW: 1,\n      ARRAY_BUFFER: 1,\n      ELEMENT_ARRAY_BUFFER: 1,\n      WebGLBuffer: {}\n    };\n    window.WebGLShader = f;\n    window.WebGLProgram = f;\n  })();\n}\n\n\n\n// --------------------- PHYSICS -----------------------\n\n\n\n\n/* ---- js/physics/body.js ---- */\n\n\n/**\n * This has all the information about a physical body that the collision detector needs,\n * and enough of an API for a Spirit to manipulate a body.\n *\n * @constructor\n */\nfunction Body() {\n  this.pathStartPos = new Vec2d();\n  this.vel = new Vec2d();\n\n  // The pathStartTime is guaranteed to get updated in this amount of time,\n  // so do not add events for this path beyond pathStartTime + pathDurationMax.\n  // Most spirits will accelerate their bodies at a fixed frequency, so this value\n  // will not usually change during a body's lifetime unless its spirit changes.\n  this.pathDurationMax = Infinity;\n\n  this.rectRad = new Vec2d();\n\n  this.freezePathStartPos = new Vec2d();\n  this.freezeVel = new Vec2d();\n\n  this.reset();\n}\n\nBody.Shape = {\n  CIRCLE: 1,\n  RECT: 2\n};\n\nBody.pool = [];\n\nBody.alloc = function() {\n  if (Body.pool.length) {\n    return Body.pool.pop().reset();\n  }\n  return new Body();\n};\n\nBody.prototype.free = function() {\n  Body.pool.push(this);\n};\n\nBody.prototype.reset = function() {\n  this.id = 0;\n  this.spiritId = 0;\n  this.pathId = 0;\n\n  // The time at which the body was at pathStartPos\n  this.pathStartTime = 0;\n  this.pathStartPos.reset();\n  this.vel.reset();\n\n  // The World's map of Body objects that need to have their paths validated.\n  this.invalidBodyIds = null;\n\n  this.shape = Body.Shape.CIRCLE;\n\n  // circle radius\n  this.rad = 1;\n\n  // half-width and half-height, for rects\n  this.rectRad.reset(1, 1);\n\n  // This controls which other bodies and rayscans should be tested for collisions.\n  this.hitGroup = 0;\n\n  // data for the basic \"bounce\" collision response\n  this.mass = 1;\n  this.elasticity = 1;\n\n  // cache for rayscan freeze-unfreeze\n  this.freezePathStartPos.reset();\n  this.freezeVel.reset();\n  this.freezePathStartTime = 0;\n  this.freezePathDurationMax = 0;\n\n  return this;\n};\n\nBody.SCHEMA = {\n  0: 'id',\n  1: 'spiritId',\n  2: 'pathStartTime',\n  3: 'pathStartPos',\n  4: 'vel',\n  5: 'pathDurationMax',\n  6: 'shape',\n  7: 'rad',\n  8: 'rectRad',\n  9: 'hitGroup',\n  10: 'mass',\n  11: 'elasticity'\n};\n\nBody.getJsoner = function() {\n  if (!Body.jsoner) {\n    Body.jsoner = new Jsoner(Body.SCHEMA);\n  }\n  return Body.jsoner;\n};\n\nBody.prototype.toJSON = function() {\n  return Body.getJsoner().toJSON(this);\n};\n\nBody.prototype.setFromJSON = function(json) {\n  Body.getJsoner().setFromJSON(json, this);\n};\n\n/**\n * @param {number} t\n * @param {Vec2d} out\n * @returns {Vec2d}\n */\nBody.prototype.getPosAtTime = function(t, out) {\n  return out.set(this.vel).scale(t - this.pathStartTime).add(this.pathStartPos);\n};\n\n/**\n * @param {number} t\n * @param {=Rect} opt_out\n * @returns {Rect}\n */\nBody.prototype.getBoundingRectAtTime = function(t, opt_out) {\n  var out = opt_out || new Rect();\n  this.getPosAtTime(t, out.pos);\n  if (this.shape == Body.Shape.CIRCLE) {\n    out.setRadXY(this.rad, this.rad);\n  } else if (this.shape == Body.Shape.RECT) {\n    out.setRad(this.rectRad);\n  }\n  return out;\n};\n\n/**\n * @returns {Number}\n */\nBody.prototype.getArea = function() {\n  if (this.shape == Body.Shape.CIRCLE) {\n    return Math.PI * this.rad * this.rad;\n  } else {\n    return this.rectRad.x * this.rectRad.y;\n  }\n};\n\nBody.prototype.invalidatePath = function() {\n  if (this.invalidBodyIds && this.id) {\n    this.invalidBodyIds[this.id] = true;\n  }\n};\n\n/**\n * Shifts the path so it intersects the new position at the new time,\n * without changing the velocity. Teleportation, basically.\n * @param pos\n * @param t\n */\nBody.prototype.setPosAtTime = function(pos, t) {\n  this.invalidatePath();\n  this.pathStartTime = t;\n  this.pathStartPos.set(pos);\n};\n\n/**\n * Shifts the path so it intersects the new position at the new time,\n * without changing the velocity. Teleportation, basically.\n * @param x\n * @param y\n * @param t\n */\nBody.prototype.setPosXYAtTime = function(x, y, t) {\n  this.invalidatePath();\n  this.pathStartTime = t;\n  this.pathStartPos.setXY(x, y);\n};\n\n/**\n * Shifts the path so that it intersects the same position at time t that it used to,\n * but it arrives with a new velocity (and therefore is coming from and going to new places.)\n * @param vel\n * @param t\n */\nBody.prototype.setVelAtTime = function(vel, t) {\n  this.invalidatePath();\n  this.moveToTime(t);\n  this.vel.set(vel);\n};\n\n/**\n * Shifts the path so that it intersects the same position at time t that it used to,\n * but it arrives with a new velocity (and therefore is coming from and going to new places.)\n * @param x\n * @param y\n * @param t\n */\nBody.prototype.setVelXYAtTime = function(x, y, t) {\n  this.invalidatePath();\n  this.moveToTime(t);\n  this.vel.setXY(x, y);\n};\n\n/**\n * Without invalidating the path, this sets the pathStartTime to t, and adjusts the pathStartPos.\n * @param {number} t\n */\nBody.prototype.moveToTime = function(t) {\n  if (this.pathStartTime === t) return;\n  var temp = this.getPosAtTime(t, Vec2d.alloc());\n  this.pathStartPos.set(temp);\n  this.pathStartTime = t;\n  temp.free();\n};\n\nBody.prototype.getPathEndTime = function() {\n  return this.pathStartTime + this.pathDurationMax;\n};\n\n/**\n * Freezes a body at a certain time, so it can be rayscanned.\n * @param time\n */\nBody.prototype.freezeAtTime = function(time) {\n  this.freezePathStartPos.set(this.pathStartPos);\n  this.freezeVel.set(this.vel);\n  this.freezePathStartTime = this.pathStartTime;\n  this.freezePathDurationMax = this.pathDurationMax;\n\n  // update pathStartTime and pathStartPos\n  this.moveToTime(time);\n  // stop in place\n  this.vel.setXY(0, 0);\n  // rayscans have a pathDurationMax of 1, so this doesn't need anything higher.\n  this.pathDurationMax = 1;\n};\n\nBody.prototype.unfreeze = function() {\n  this.pathStartPos.set(this.freezePathStartPos);\n  this.vel.set(this.freezeVel);\n  this.pathStartTime = this.freezePathStartTime;\n  this.pathDurationMax = this.freezePathDurationMax;\n};\n\n\n\n\n/* ---- js/physics/cell.js ---- */\n\n\n/**\n * A world grid cell, holding pathIds by hitGroup.\n * It is a compact array of groups, indexed by hitGroup number.\n * Each group is a set of pathIds.\n * @constructor\n */\nfunction Cell(groupCount) {\n  this.groups = [];\n  this.reset(groupCount);\n}\n\nCell.prototype.reset = function(groupCount) {\n  for (var i = 0; i < groupCount; i++) {\n    if (!this.groups[i]) {\n      this.groups[i] = ArraySet.alloc();\n    } else {\n      this.groups[i].reset();\n    }\n  }\n  while (this.groups.length > groupCount) {\n    this.groups.pop().free();\n  }\n};\n\nPoolify(Cell);\n\nCell.prototype.addPathIdToGroup = function(pathId, groupId) {\n  this.groups[groupId].put(pathId);\n};\n\nCell.prototype.removePathIdFromGroup = function(pathId, groupId) {\n  this.groups[groupId].remove(pathId);\n};\n\n/**\n * Returns the internal ArraySet.\n * @param groupId\n * @returns {ArraySet}\n */\nCell.prototype.getPathIdsForGroup = function(groupId) {\n  return this.groups[groupId];\n};\n\nCell.prototype.isEmpty = function() {\n  for (var i = 0; i < this.groups.length; i++) {\n    if (!this.groups[i].isEmpty()) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/* ---- js/physics/cellrange.js ---- */\n\n\n/**\n * A rectangular range of cells in a grid.\n * @constructor\n */\nfunction CellRange() {\n  this.p0 = new Vec2d();\n  this.p1 = new Vec2d();\n  this.reset();\n}\n\nCellRange.prototype.reset = function() {\n  this.p0.setXY(0, 0);\n  this.p1.setXY(-1, -1);\n};\n\n/**\n * @param {CellRange} that\n */\nCellRange.prototype.set = function(that) {\n  this.p0.set(that.p0);\n  this.p1.set(that.p1);\n};\n\nPoolify(CellRange);\n\n\n/* ---- js/physics/hitdetector.js ---- */\n\n\n/**\n * Creates WorldEvents for collisions between bodies.\n * @constructor\n */\nfunction HitDetector() {\n  this.xOverlap = [0, 0];\n  this.yOverlap = [0, 0];\n  this.overlap = [0, 0, null]; // start, end, axis if any\n}\n\nHitDetector.prototype.calcHit = function(now, b0, b1, eventOut) {\n  if (b0.vel.equals(b1.vel)) {\n    return null;\n  }\n  var hit = null;\n  if (b0.shape == Body.Shape.RECT) {\n    if (b1.shape == Body.Shape.RECT) {\n      hit = this.calcHitRectRect(now, b0, b1, eventOut);\n    } else {\n      hit = this.calcHitRectCircle(now, b0, b1, eventOut);\n    }\n  } else if (b1.shape == Body.Shape.RECT) {\n    hit = this.calcHitRectCircle(now, b1, b0, eventOut);\n  } else {\n    hit = this.calcHitCircleCircle(now, b0, b1, eventOut);\n  }\n  return hit;\n};\n\n/**\n * @param {number} now\n * @param {Body} b0 Rectangluar body\n * @param {Body} b1 Rectangluar body\n * @param {WorldEvent} eventOut Pre-allocated output param.\n * @returns {?WorldEvent} Event if hit, or null.\n */\nHitDetector.prototype.calcHitCircleCircle = function(now, b0, b1, eventOut) {\n  var p0 = b0.getPosAtTime(now, Vec2d.alloc());\n  var p1 = b1.getPosAtTime(now, Vec2d.alloc());\n\n  // For most of the computations, we shift times left so \"now\" is zero.\n  var maxDuration = Math.min(b0.getPathEndTime(), b1.getPathEndTime()) - now;\n\n  // Normalize as if b0 is holding still at 0, 0.\n  var overlap = this.circleOriginOverlapTime(\n      p1.x - p0.x,\n      p1.y - p0.y,\n      b1.vel.x - b0.vel.x,\n      b1.vel.y - b0.vel.y,\n      b0.rad + b1.rad);\n  p0.free();\n  p1.free();\n  var e = null;\n  if (overlap && 0 < overlap[0] && overlap[0] <= maxDuration) {\n    e = eventOut;\n    e.type = WorldEvent.TYPE_HIT;\n    e.time = now + overlap[0];\n    e.pathId0 = b0.pathId;\n    e.pathId1 = b1.pathId;\n    e.collisionVec.set(b1.getPosAtTime(e.time, p1)).subtract(b0.getPosAtTime(e.time, p0));\n  }\n  return e;\n};\n\n/**\n * @param {number} now\n * @param {Body} rect Rectangluar body\n * @param {Body} circ Circular body\n * @param {WorldEvent} eventOut Pre-allocated output param.\n * @returns {?WorldEvent} Event if hit, or null.\n */\nHitDetector.prototype.calcHitRectCircle = function(now, rect, circ, eventOut) {\n  var e = null;\n  var posRect = rect.getPosAtTime(now, Vec2d.alloc());\n  var posCirc = circ.getPosAtTime(now, Vec2d.alloc());\n  var maxDuration = Math.min(rect.getPathEndTime(), circ.getPathEndTime()) - now;\n\n  // bounding rect check\n  var brectOverlap = this.rectOverlapTime(\n      posRect, rect.vel, rect.rectRad.x, rect.rectRad.y,\n      posCirc, circ.vel, circ.rad, circ.rad);\n  // If the brects don't overlap, or *finish* before 0, or start after max, then there's no legal hit.\n  if (!brectOverlap || brectOverlap[1] <= 0 || maxDuration < brectOverlap[0]) {\n    posRect.free();\n    posCirc.free();\n    return null;\n  }\n\n  // Put the circle at 0, 0, holding still. x, y, dx, and dy are for the rect.\n  // Tricky - re-use the allocated vecs. Free pos and vel before returning.\n  var pos = posRect.subtract(posCirc);\n  var vel = posCirc.set(rect.vel).subtract(circ.vel);\n  var vSign = Vec2d.alloc().set(vel).sign();\n\n  // Check leading edges. If a hit is found, return immediately,\n  // because an edge hit is always earlier than a corner hit.\n  // TODO more efficient special-purpose point vs aa-segment code.\n  var edgePos = Vec2d.alloc();\n  var edgeRad = Vec2d.alloc();\n  var compassPos = Vec2d.alloc();\n  for (var i = 0; i < 2 && !e; i++) {\n    var axis = Vec2d.AXES[i];\n    if (vSign[axis]) {\n      edgePos.set(pos);\n      edgePos[axis] += rect.rectRad[axis] * vSign[axis];\n      edgeRad.set(rect.rectRad);\n      edgeRad[axis] = 0;\n\n      compassPos[axis] = -vSign[axis] * circ.rad;\n      var edgeOverlapTime = this.rectOverlapTime(\n          edgePos, vel, edgeRad.x, edgeRad.y,\n          compassPos, Vec2d.ZERO, 0, 0);\n      compassPos[axis] = 0;\n      if (edgeOverlapTime && 0 < edgeOverlapTime[0] && edgeOverlapTime[0] <= maxDuration) {\n        e = eventOut;\n        e.type = WorldEvent.TYPE_HIT;\n        e.time = now + edgeOverlapTime[0];\n        e.pathId0 = rect.pathId;\n        e.pathId1 = circ.pathId;\n        e.collisionVec.setXY(0, 0)[axis] = 1; // I guess?\n      }\n    }\n  }\n  edgePos.free();\n  edgeRad.free();\n  compassPos.free();\n  if (e) {\n    // There was an edge hit.\n    pos.free();\n    vel.free();\n    vSign.free();\n    return e;\n  }\n\n  // Now find the earliest hit time, even if it's outside the legal range, because it will be\n  // the actual shape-to-shape hit time. Save the range check for last.\n\n  // Check rect's leading corners, as point-circles, against the circle at 0, 0.\n  // The bounding rects hit, so the rect is definitely approaching the circle.\n  var t = maxDuration + 1;\n  var cornerPos = Vec2d.alloc();\n  var hitCorner = Vec2d.alloc();\n  var overlap;\n  if (vSign.x && vSign.y) {\n    // Diagonal motion. Check leading corner and two trailing corners.\n    // A trailing corner might hit before a lead corner, so check them all.\n    // TODO: Don't check a trailing corner if it starts in 1D overlap with circle.\n\n    // lead corner\n    cornerPos.set(rect.rectRad).multiply(vSign).add(pos);\n    overlap = this.circleOriginOverlapTime(\n        cornerPos.x, cornerPos.y, vel.x, vel.y, circ.rad);\n    if (overlap) {\n      t = overlap[0];\n      hitCorner.set(cornerPos);\n    }\n    // corner above/below lead\n    overlap = this.circleOriginOverlapTime(\n        cornerPos.x, pos.y - vSign.y * rect.rectRad.y,\n        vel.x, vel.y, circ.rad);\n    if (overlap && overlap[0] < t) {\n      t = overlap[0];\n      hitCorner.setXY(cornerPos.x, pos.y - vSign.y * rect.rectRad.y);\n    }\n    // corner right/left of lead\n    overlap = this.circleOriginOverlapTime(\n        pos.x - vSign.x * rect.rectRad.x, cornerPos.y,\n        vel.x, vel.y, circ.rad);\n    if (overlap && overlap[0] < t) {\n      t = overlap[0];\n      hitCorner.setXY(pos.x - vSign.x * rect.rectRad.x, cornerPos.y);\n    }\n  } else {\n    // Axis-aligned motion.\n    // Check the two leading corners.\n    // CornerPos starts in the middle of the lead edge,\n    // then we shift it to the corners.\n    var shift = Vec2d.alloc().set(vSign).rot90Right().multiply(rect.rectRad);\n    var edgeCenter = Vec2d.alloc().set(rect.rectRad).multiply(vSign).add(pos);\n    for (var i = 0; i < 2; i++) {\n      cornerPos.set(edgeCenter).add(shift);\n      overlap = this.circleOriginOverlapTime(\n          cornerPos.x, cornerPos.y, vel.x, vel.y, circ.rad);\n      if (overlap && overlap[0] < t) {\n        t = overlap[0];\n        hitCorner.set(cornerPos);\n      }\n      shift.scale(-1);\n    }\n    shift.free();\n    edgeCenter.free();\n  }\n  if (0 < t && t <= maxDuration) {\n    e = eventOut;\n    e.type = WorldEvent.TYPE_HIT;\n    e.time = now + t;\n    e.pathId0 = rect.pathId;\n    e.pathId1 = circ.pathId;\n\n    // Slide the hit corner to the edge of the circle.\n    e.collisionVec.set(vel).scale(t).add(hitCorner);\n  }\n  hitCorner.free();\n  cornerPos.free();\n  vSign.free();\n  vel.free();\n  pos.free();\n  return e;\n};\n\n/**\n * @param {number} now\n * @param {Body} b0 Rectangluar body\n * @param {Body} b1 Rectangluar body\n * @param {WorldEvent} eventOut Pre-allocated output param.\n * @returns {?WorldEvent} Event if hit, or null.\n */\nHitDetector.prototype.calcHitRectRect = function(now, b0, b1, eventOut) {\n  var pos0 = b0.getPosAtTime(now, Vec2d.alloc());\n  var pos1 = b1.getPosAtTime(now, Vec2d.alloc());\n\n  // For most of the computations, we shift times left so \"now\" is zero.\n  var maxDuration = Math.min(b0.getPathEndTime(), b1.getPathEndTime()) - now;\n  var overlap = this.rectOverlapTime(\n      pos0, b0.vel, b0.rectRad.x, b0.rectRad.y,\n      pos1, b1.vel, b1.rectRad.x, b1.rectRad.y);\n\n  pos0.free();\n  pos1.free();\n  var e = null;\n  if (overlap && 0 < overlap[0] && overlap[0] <= maxDuration) {\n    e = eventOut;\n    e.type = WorldEvent.TYPE_HIT;\n    e.time = now + overlap[0];\n    e.pathId0 = b0.pathId;\n    e.pathId1 = b1.pathId;\n    e.collisionVec.setXY(0, 0)[overlap[2]] = 1;\n  }\n  return e;\n};\n\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} dx\n * @param {number} dy\n * @param {number} rad\n * @returns {?Array} null for no overlap, or a two element array [start time, end time]\n */\nHitDetector.prototype.circleOriginOverlapTime = function(x, y, dx, dy, rad) {\n  // quadratic equation\n  var a = dx * dx + dy * dy; // not zero, because vels are not equal\n  if (a == 0) return null;\n  var b = 2 * (x * dx + y * dy);\n  var c = x * x + y * y - rad * rad;\n  var b2_4ac = b * b - 4 * a * c;\n  if (b2_4ac < 0) return null;\n  var sqrtb2_4ac = Math.sqrt(b2_4ac);\n\n  var t = (-b + sqrtb2_4ac) / (2 * a);\n  var t2 = (-b - sqrtb2_4ac) / (2 * a);\n  this.overlap[0] = Math.min(t, t2);\n  this.overlap[1] = Math.max(t, t2);\n  return this.overlap;\n};\n\n\n/**\n * @param {Vec2d} pos0\n * @param {Vec2d} vel0\n * @param {number} rad0x\n * @param {number} rad0y\n * @param {Vec2d} pos1\n * @param {Vec2d} vel1\n * @param {number} rad1x\n * @param {number} rad1y\n * @returns {?Array} null for no overlap, or a two element array [start time, end time]\n */\nHitDetector.prototype.rectOverlapTime = function(\n    pos0, vel0, rad0x, rad0y,\n    pos1, vel1, rad1x, rad1y) {\n  var count;\n  count = this.overlapTime1D(\n      pos0.x, vel0.x, rad0x,\n      pos1.x, vel1.x, rad1x,\n      this.xOverlap);\n  if (count == 0) return null;\n  count = this.overlapTime1D(\n      pos0.y, vel0.y, rad0y,\n      pos1.y, vel1.y, rad1y,\n      this.yOverlap);\n  if (count == 0) return null;\n\n  var overlapStart; // max of overlap starts\n  if (this.xOverlap[0] < this.yOverlap[0]) {\n    overlapStart = this.yOverlap[0];\n    this.overlap[2] = Vec2d.Y;\n  } else {\n    overlapStart = this.xOverlap[0];\n    this.overlap[2] = Vec2d.X;\n  }\n  var overlapEnd = Math.min(this.xOverlap[1], this.yOverlap[1]);\n  if (overlapEnd < overlapStart) return null;\n  this.overlap[0] = overlapStart;\n  this.overlap[1] = overlapEnd;\n  return this.overlap;\n};\n\n/**\n * One-dimensional overlap timespan.\n * @param p0 position\n * @param v0 velocity\n * @param r0 radius\n * @param p1 position\n * @param v1 velocity\n * @param r1 radius\n * @param out output array. Zero, one, or two time values may be returned.\n * @returns {number} number of collisions returned on the output array\n */\nHitDetector.prototype.overlapTime1D = function(p0, v0, r0, p1, v1, r1, out) {\n  var v = v1 - v0;\n  var p = p1 - p0;\n  var r = r0 + r1;\n  if (!v) {\n    // forever, or never?\n    if (Math.abs(p) < r) {\n      // forever\n      out[0] = -Infinity;\n      out[1] = Infinity;\n      return 2;\n    } else {\n      // never\n      return 0;\n    }\n  }\n  out[0] = (-p - r) / v;\n  out[1] = (-p + r) / v;\n  if (out[0] > out[1]) {\n    var tmp = out[0];\n    out[0] = out[1];\n    out[1] = tmp;\n  }\n  return 2;\n};\n\n\n/* ---- js/physics/hitresolver.js ---- */\n\n\n/**\n * Accelerates colliding bodies.\n * @constructor\n */\nfunction HitResolver() {\n  this.defaultElasticity = 0.99;\n}\n\n/**\n * @param {number} time\n * @param {Vec2d} collisionVec\n * @param {Body} b0\n * @param {Body} b1\n */\nHitResolver.prototype.resolveHit = function(time, collisionVec, b0, b1) {\n  if (b0.mass == Infinity && b1.mass == Infinity) return;\n  var pos0 = b0.getPosAtTime(time, Vec2d.alloc());\n  var pos1 = b1.getPosAtTime(time, Vec2d.alloc());\n\n  // Shift b0 to the origin, holding still.\n  var vel = Vec2d.alloc().set(b1.vel).subtract(b0.vel);\n\n  // Calculate accel needed for inelastic resolution.\n  // Calc accel along the collision vector by enough to cancel velocity along that direction.\n  var accel = Vec2d.alloc().set(vel).projectOnto(collisionVec);\n  // Add onto that for elastic collision.\n  accel.scale(-1 - this.defaultElasticity);\n  if (accel.equals(Vec2d.ZERO)) {\n    accel.free();\n    pos0.free();\n    pos1.free();\n    return;\n  }\n//  if (accel.magnitudeSquared() < 0.1 * 0.1) {\n//    accel.scaleToLength(0.1);\n//  }\n\n  // Use masses to decide which body gets accelerated by how much.\n  if (b0.mass == Infinity) {\n    b1.setVelAtTime(accel.add(b1.vel), time);\n  } else if (b1.mass == Infinity) {\n    b0.setVelAtTime(accel.scale(-1).add(b0.vel), time);\n  } else {\n    var work = Vec2d.alloc();\n    var massTotal = b0.mass + b1.mass;\n\n    var frac0 = b1.mass / massTotal;\n    work.set(accel).scale(-frac0).add(b0.vel);\n    b0.setVelAtTime(work, time);\n\n    var frac1 = b0.mass / massTotal;\n    work.set(accel).scale(frac1).add(b1.vel);\n    b1.setVelAtTime(work, time);\n    work.free();\n  }\n  accel.free();\n  pos0.free();\n  pos1.free();\n};\n\n\n/* ---- js/physics/overlapdetector.js ---- */\n\n\n/**\n * This only has static methods, but the constructor gives it a namespace. Meh.\n * @constructor\n */\nfunction OverlapDetector() {\n}\n\nOverlapDetector.isBodyOverlappingBodyAtTime = function(b0, b1, t) {\n  var overlap;\n  var p0 = b0.getPosAtTime(t, Vec2d.alloc());\n  var p1 = b1.getPosAtTime(t, Vec2d.alloc());\n  if (b0.shape == Body.Shape.CIRCLE && b1.shape == Body.Shape.CIRCLE) {\n    overlap = OverlapDetector.isCircleOverlappingCircle(p0, b0.rad, p1, b1.rad);\n  } else if (b0.shape == Body.Shape.RECT && b1.shape == Body.Shape.RECT) {\n    overlap = OverlapDetector.isRectOverlappingRect(p0, b0.rectRad, p1, b1.rectRad);\n  } else if (b0.shape == Body.Shape.RECT) {\n    overlap = OverlapDetector.isRectOverlappingCircle(p0, b0.rectRad, p1, b1.rad);\n  } else {\n    overlap = OverlapDetector.isRectOverlappingCircle(p1, b1.rectRad, p0, b0.rad);\n  }\n  p0.free();\n  p1.free();\n  return overlap;\n};\n\nOverlapDetector.isCircleOverlappingCircle = function(v0, r0, v1, r1) {\n  var r = r0 + r1;\n  return v0.distanceSquared(v1) <= r * r;\n};\n\nOverlapDetector.isRectOverlappingRect = function(p0, rectRad0, p1, rectRad1) {\n  var rx = rectRad0.x + rectRad1.x;\n  var ry = rectRad0.y + rectRad1.y;\n  var dx = Math.abs(p0.x - p1.x);\n  var dy = Math.abs(p0.y - p1.y);\n  return dx <= rx && dy <= ry;\n};\n\nOverlapDetector.isRectOverlappingCircle = function(rectPos, rectRad, circPos, radius) {\n  var nearCorner = Vec2d.alloc(rectPos.x, rectPos.y).subtract(circPos).abs().subtract(rectRad);\n  var overlap =\n      // rect covers origin?\n      (nearCorner.x <= 0 && nearCorner.y <= 0) ||\n      // rect overlaps vertical axis of circle?\n      (nearCorner.x <= 0 && nearCorner.y <= radius) ||\n      // rect overlaps horizontal axis of circle?\n      (nearCorner.y <= 0 && nearCorner.x <= radius) ||\n      // rect corner inside circle?\n      nearCorner.magnitudeSquared() <= radius * radius;\n  nearCorner.free();\n  return overlap;\n};\n\n\n/* ---- js/physics/scanrequest.js ---- */\n\n\n/**\n * Rayscan Request.\n * A rayscan is like a body that travels from pos to pos+vel, instantly,\n * reporting back on the first thing it hits.\n * @constructor\n */\nfunction ScanRequest() {\n  this.pos = new Vec2d();\n  this.vel = new Vec2d();\n  this.rectRad = new Vec2d();\n  this.reset();\n}\n\nScanRequest.prototype.reset = function() {\n  this.hitGroup = -1;\n  this.pos.reset();\n  this.vel.reset();\n  this.shape = Body.Shape.CIRCLE;\n  this.rad = 1;\n  this.rectRad.reset();\n};\n\nPoolify(ScanRequest);\n\n\n/* ---- js/physics/scanresponse.js ---- */\n\n\n/**\n * A ScanResponse holds the result of a World.rayscan.\n * @constructor\n */\nfunction ScanResponse() {\n  this.collisionVec = new Vec2d();\n  this.reset();\n}\n\nScanResponse.prototype.reset = function() {\n  this.timeOffset = 0; // zero to one\n  this.pathId = 0;\n  this.collisionVec.reset();\n};\n\nPoolify(ScanResponse);\n\n\n/* ---- js/physics/spirit.js ---- */\n\n\n/**\n * Base class for an entity in the world that does stuff, like manipulating bodies.\n * @param id\n * @constructor\n */\nfunction Spirit(id) {\n  this.id = id;\n}\n\n/**\n * Every spirit has this called when that spirit enters the world, or when the world first starts up.\n * At this point, a spirit ought to set up an onTimeout, to get its event loop started.\n * @param {World} world\n */\nSpirit.prototype.onStart = function(world) {\n};\n\n/**\n * Called when the Clock advances to the time of the Timeout.\n * @param {World} world\n * @param {Timeout} timeout  the timeout that the spirit sent to the world.\n */\nSpirit.prototype.onTimeout = function(world, timeout) {\n};\n\n/**\n * When a Body is hit, the world informs its Spirit, if any.\n * @param {World} world\n * @param {Body} thisBody\n * @param {Body} thatBody\n * @param {WorldEvent} hit\n */\nSpirit.prototype.onHit = function(world, thisBody, thatBody, hit) {\n};\n\n/**\n * Optional function called on every frame draw.\n * @param {World} world\n * @param {Renderer} renderer\n */\nSpirit.prototype.onDraw = function(world, renderer) {\n};\n\n\n/* ---- js/physics/world.js ---- */\n\n\n/**\n * Handles spirits and bodies.\n *\n * @param {=number} opt_cellSize The world-space size of each cell in the collision-detection grid.\n * If it's too small, time is wasted as things enter and exit cells. If it's too big,\n * we suffer from O(n^2) collision detection speed within each cell.\n * If falsey, this defaults to 15.\n *\n * @param {=number} opt_groupCount The number of collision groups in each cell.\n * If falsey, this defaults to 1.\n *\n * @param {=Array} opt_groupPairs An array of 2-element arrays, defining all the group pairs\n * that can collide with each other. The two IDs in a pair may be the same, to make\n * a group's members collide with each other.\n * If falsey, this defaults to one group, \"0\", which collides with itself.\n *\n * @constructor\n */\nfunction World(opt_cellSize, opt_groupCount, opt_groupPairs) {\n  this.cellSize = opt_cellSize || World.DEFAULT_CELL_SIZE;\n  this.groupCount = opt_groupCount || 1;\n  this.groupPairs = opt_groupPairs || [[0, 0]];\n  this.groupHitsGroups = [];\n  for (var i = 0; i < this.groupPairs.length; i++) {\n    var pair = this.groupPairs[i];\n    for (var a = 0; a < 2; a++) {\n      var b = (a + 1) % 2;\n      var list = this.groupHitsGroups[pair[a]];\n      if (!list) {\n        list = this.groupHitsGroups[pair[a]] = [];\n      }\n      if (list.indexOf(pair[b]) < 0) {\n        list.push(pair[b]);\n      }\n    }\n  }\n\n  // spiritId to Spirit\n  this.spirits = {};\n\n  // bodyId to Body\n  this.bodies = {};\n\n  // pathId to Body. Obsolete pathIds might still point to their old Bodies, so check the body's pathId.\n  this.paths = {};\n\n  // bodyId to \"true\". Holds IDs of body objects that need to have their paths processed by the collider\n  // before time can move forward. This includes newly-added bodies.\n  // Bodies can be invalid for a time, so that they can be manipulated while time is standing still,\n  // without having to recompute collisions every time.\n  this.invalidBodyIds = {};\n\n  this.nextId = 10;\n\n  this.grid = {};\n\n  this.queue = new SkipQueue(World.SKIP_QUEUE_BASE,\n      SkipQueue.getRecommendedMaxLevel(100, World.SKIP_QUEUE_BASE));\n\n  this.now = 1;\n\n  this.hitDetector = new HitDetector();\n  this.hitTimePadding = 0.01;\n\n  // cache for rayscans and overlap scans.\n  this.scannedBodyIds = new ObjSet();\n}\n\nWorld.SKIP_QUEUE_BASE = 2;\n\n// 5% fudge factor when deciding what cells an object is in.\nWorld.BRECT_FUDGE_FACTOR = 0.05;\n\nWorld.GRID_HUGENESS = 10000;\n\n/**\n * The width and height of grid cells.\n * The cell at index 0, 0 has its center at 0, 0.\n * The cell at index -1, 1 has its center at -CELL_SIZE, CELL_SIZE.\n */\nWorld.DEFAULT_CELL_SIZE = 15;\n\nWorld.prototype.cellCoord = function(worldCoord) {\n  return Math.round(worldCoord / this.cellSize);\n};\n\nWorld.prototype.gridIndexForCellCoords = function(ix, iy) {\n  return World.GRID_HUGENESS * ix + iy;\n};\n\nWorld.prototype.getCell = function(ix, iy) {\n  return this.grid[this.gridIndexForCellCoords(ix, iy)];\n};\n\nWorld.prototype.setCell = function(cell, ix, iy) {\n  this.grid[this.gridIndexForCellCoords(ix, iy)] = cell;\n  return cell;\n};\n\nWorld.prototype.removeCell = function(ix, iy) {\n  var index = this.gridIndexForCellCoords(ix, iy);\n  var cell = this.grid[index];\n  if (cell) {\n    delete this.grid[index];\n    cell.free();\n  }\n};\n\n/**\n * @returns {number}\n */\nWorld.prototype.newId = function() {\n  return this.nextId++;\n};\n\n/**\n * Assigns an ID and adds the spirit.\n * @return {number} the new spirit ID.\n */\nWorld.prototype.addSpirit = function(spirit) {\n  spirit.id = this.newId();\n  // If spirit loading gets more complicated, then call loadSpirit instead of inlining.\n  this.spirits[spirit.id] = spirit;\n  return spirit.id;\n};\n\n/**\n * Adds the spirit using the ID it already has.\n */\nWorld.prototype.loadSpirit = function(spirit) {\n  if (this.spirits[spirit.id]) throw Error(\"Spirit with id '\" + spirit.id + \"' already exists!\");\n  this.spirits[spirit.id] = spirit;\n  this.nextId = Math.max(this.nextId, spirit.id + 1);\n};\n\nWorld.prototype.removeSpiritId = function(id) {\n  var spirit = this.spirits[id];\n  if (spirit) {\n    delete this.spirits[id];\n    if (spirit.free) {\n      spirit.free();\n    }\n  }\n};\n\n/**\n * Assigns an ID and adds the body.\n * @returns {number} the new body ID\n */\nWorld.prototype.addBody = function(body) {\n  body.id = this.newId();\n  this.loadBody(body);\n  return body.id;\n};\n\n/**\n * Adds the body using the ID it already has.\n */\nWorld.prototype.loadBody = function(body) {\n  if (this.bodies[body.id]) throw Error(\"Body with id '\" + body.id + \"' already exists!\");\n  // Add it to the bodies index and to the invalid bodies index.\n  // The next time the clock moves forward, the invalid body will be addressed.\n  this.bodies[body.id] = body;\n  this.nextId = Math.max(this.nextId, body.id + 1);\n\n  // Hook the path invalidator into the body. A wee bit hacky.\n  body.invalidBodyIds = this.invalidBodyIds;\n  body.invalidatePath();\n};\n\n/**\n * Removes the body and frees the body from the class pool.\n * @param bodyId\n */\nWorld.prototype.removeBodyId = function(bodyId) {\n  var body = this.bodies[bodyId];\n  if (body) {\n    var rect = Rect.alloc();\n    this.getPaddedBodyBoundingRect(body, this.now, rect);\n    var range = CellRange.alloc();\n    this.getCellRangeForRect(rect, range);\n    this.removeBodyFromCellRange(body, range);\n    range.free();\n    rect.free();\n    delete this.bodies[body.id];\n    delete this.paths[body.pathId];\n    delete this.invalidBodyIds[body.id];\n    body.free();\n  } else {\n    console.log(\"couldn't find or remove bodyId \" + bodyId);\n  }\n};\n\nWorld.prototype.removeBodyFromCellRange = function(body, cellRange) {\n  for (var iy = cellRange.p0.y; iy <= cellRange.p1.y; iy++) {\n    for (var ix = cellRange.p0.x; ix <= cellRange.p1.x; ix++) {\n      var cell = this.getCell(ix, iy);\n      if (cell) {\n        cell.removePathIdFromGroup(body.pathId, body.hitGroup);\n        if (cell.isEmpty()) {\n          this.removeCell(ix, iy);\n        }\n      }\n    }\n  }\n};\n\nWorld.prototype.getBody = function(bodyId) {\n  this.validateBodies();\n  return this.bodies[bodyId];\n};\n\n/**\n * Also purges obsolete pathIds from the index.\n * @param pathId\n * @returns {*}\n */\nWorld.prototype.getBodyByPathId = function(pathId) {\n  this.validateBodies();\n  var body = this.paths[pathId];\n  if (body && body.pathId != pathId) {\n    delete this.paths[pathId];\n    body = null;\n  }\n  if (body && !this.bodies[body.id]) {\n    console.warn(\"getBodyByPathId is writing checks that bodies cannot cash. pathId\", pathId, \"body.id:\", body.id);\n  }\n  return body;\n};\n\nWorld.prototype.validateBodies = function() {\n  for (var bodyId in this.invalidBodyIds) {\n    delete this.invalidBodyIds[bodyId];\n    var body = this.bodies[bodyId];\n    if (!body) continue;\n    if (body.pathId) {\n      delete this.paths[body.pathId];\n    }\n\n    // Update path\n    body.moveToTime(this.now);\n    body.pathId = this.newId();\n    this.paths[body.pathId] = body;\n\n    // Add initial set of events.\n    this.addPathToGrid(body);\n    this.addFirstGridEvent(body, WorldEvent.TYPE_GRID_ENTER, Vec2d.X);\n    this.addFirstGridEvent(body, WorldEvent.TYPE_GRID_ENTER, Vec2d.Y);\n    this.addFirstGridEvent(body, WorldEvent.TYPE_GRID_EXIT, Vec2d.X);\n    this.addFirstGridEvent(body, WorldEvent.TYPE_GRID_EXIT, Vec2d.Y);\n  }\n};\n\nWorld.prototype.getCellRangeForRect = function(rect, range) {\n  range.p0.setXY(\n      this.cellCoord(rect.pos.x - rect.rad.x),\n      this.cellCoord(rect.pos.y - rect.rad.y));\n  range.p1.setXY(\n      this.cellCoord(rect.pos.x + rect.rad.x),\n      this.cellCoord(rect.pos.y + rect.rad.y));\n  return range;\n};\n\nWorld.prototype.addPathToGrid = function(body) {\n  var brect = this.getPaddedBodyBoundingRect(body, this.now, Rect.alloc());\n  var range = this.getCellRangeForRect(brect, CellRange.alloc());\n  for (var iy = range.p0.y; iy <= range.p1.y; iy++) {\n    for (var ix = range.p0.x; ix <= range.p1.x; ix++) {\n      var cell = this.getCell(ix, iy);\n      if (!cell) {\n        cell = this.setCell(Cell.alloc(this.getGroupCount()), ix, iy);\n      }\n      this.addPathToCell(body, cell);\n    }\n  }\n  range.free();\n  brect.free();\n};\n\nWorld.prototype.getGroupCount = function() {\n  return this.groupCount;\n};\n\nWorld.prototype.addPathToCell = function(body, cell) {\n  var nextEvent = WorldEvent.alloc();\n  var group = body.hitGroup;\n\n  var hitGroups = this.groupHitsGroups[group];\n  for (var gi = 0; gi < hitGroups.length; gi++) {\n    var otherGroup = hitGroups[gi];\n    var pathIdSet = cell.getPathIdsForGroup(otherGroup);\n    var pathIdArray = pathIdSet.vals;\n    for (var pi = 0; pi < pathIdArray.length;) {\n      var pathId = pathIdArray[pi];\n      var otherBody = this.paths[pathId];\n      if (otherBody && otherBody.pathId == pathId) {\n        var hitEvent = this.hitDetector.calcHit(this.now, body, otherBody, nextEvent);\n        if (hitEvent && hitEvent.time < Infinity) {\n          // Pad the collision time to prevent numerical-challenge interpenetration.\n          hitEvent.time = Math.max(hitEvent.time - this.hitTimePadding, this.now);\n          // Add the existing event and allocate the next one.\n          this.queue.add(hitEvent);\n          nextEvent = WorldEvent.alloc();\n        }\n        pi++;\n      } else {\n        pathIdSet.removeIndex(pi);\n      }\n    }\n  }\n  cell.addPathIdToGroup(body.pathId, group);\n  nextEvent.free();\n};\n\n/**\n * Checks to see if the body's path will enter/exit a CellRange\n * before the path expires, and allocates and adds the event if so.\n * @param {Body} body\n * @param {String} eventType WorldEvent TYPE const.\n * @param {String} axis The axis along which the object travels (not the axis it crosses)\n * @param {WorldEvent} eventOut\n * @return {?WorldEvent} if there is an event, or null otherwise.\n */\nWorld.prototype.getFirstGridEvent = function(body, eventType, axis, eventOut) {\n  var v = body.vel;\n  if (!v[axis]) return null;\n  var perp = Vec2d.otherAxis(axis);\n\n  // Calculate the leading/trailing point \"p\" on the moving bounding rect.\n  var rect = body.getBoundingRectAtTime(this.now, Rect.alloc());\n  var vSign = Vec2d.alloc().set(body.vel).sign();\n\n  var p = Vec2d.alloc().set(rect.rad).multiply(vSign);\n  if (eventType === WorldEvent.TYPE_GRID_EXIT) {\n    p.scale(-1);\n  }\n  p.add(rect.pos);\n\n  // c is the center of the cell that p is in.\n  var c = Vec2d.alloc().set(p).roundToGrid(this.cellSize);\n\n  // Calculate crossing times\n  var e = null;\n  var t = this.now + (c[axis] + 0.5 * vSign[axis] * this.cellSize - p[axis]) / v[axis];\n  if (t < this.now) {\n    console.error(\"oh crap, grid event time < now:\", t, this.now);\n  } else if (t <= body.getPathEndTime()) {\n    e = eventOut;\n    e.type = eventType;\n    e.axis = axis;\n    e.time = t;\n    e.pathId = body.pathId;\n\n    // Is the event about entering the next set of cells, or leaving the current one?\n    e.cellRange.p0[axis] = e.cellRange.p1[axis] = this.cellCoord(c[axis]) +\n        (eventType === WorldEvent.TYPE_GRID_ENTER ? vSign[axis] : 0);\n    // The length of the crossing, in cells, depends on the position of the bounding rect at that time.\n    this.getPaddedBodyBoundingRect(body, t, rect);\n    e.cellRange.p0[perp] = this.cellCoord(rect.pos[perp] - rect.rad[perp]);\n    e.cellRange.p1[perp] = this.cellCoord(rect.pos[perp] + rect.rad[perp]);\n  }\n  c.free();\n  p.free();\n  vSign.free();\n  rect.free();\n  return e;\n};\n\n/**\n * Checks to see if the body's path will enter/exit a CellRange\n * before the path expires, and allocates and adds the event if so.\n * @param {Body} body\n * @param {String} eventType WorldEvent TYPE const.\n * @param {String} axis The axis along which the object travels (not the axis it crosses)\n */\nWorld.prototype.addFirstGridEvent = function(body, eventType, axis) {\n  var event = WorldEvent.alloc();\n  if (this.getFirstGridEvent(body, eventType, axis, event)) {\n    this.queue.add(event);\n  } else {\n    event.free();\n  }\n};\n\n/**\n * Checks to see if the body's path will enter/exit a CellRange\n * before the path expires, and allocates and adds the event if so.\n * @param {Body} body\n * @param {WorldEvent} prevEvent The grid event before this one.\n * @param {WorldEvent} eventOut\n * @return {?WorldEvent} if there is an event, or null otherwise.\n */\nWorld.prototype.getSubsequentGridEvent = function(body, prevEvent, eventOut) {\n  var axis = prevEvent.axis;\n  var eventType = prevEvent.type;\n  var v = body.vel;\n  if (!v[axis]) return null;\n  var perp = Vec2d.otherAxis(axis);\n\n  var vSign = Vec2d.alloc().set(v).sign();\n  var nextCellIndex = prevEvent.cellRange.p0[axis] + vSign[axis];\n  // What time will the point reach that cell index?\n  var rad = vSign[axis] * (body.shape == Body.Shape.CIRCLE ? body.rad : body.rectRad[axis]);\n  var dest;\n  if (eventType == WorldEvent.TYPE_GRID_ENTER) {\n    dest = (nextCellIndex - 0.5 * vSign[axis]) * this.cellSize - rad;\n  } else {\n    dest = (nextCellIndex + 0.5 * vSign[axis]) * this.cellSize + rad;\n  }\n  var t = body.pathStartTime + (dest - body.pathStartPos[axis]) / v[axis];\n  var e = null;\n  if (t < this.now) {\n    console.error(\"oh crap\", t, this.now);\n  } else if (t <= body.getPathEndTime()) {\n    e = eventOut;\n    e.type = eventType;\n    e.axis = axis;\n    e.time = t;\n    e.pathId = body.pathId;\n\n    // Is the event about entering the next set of cells, or leaving the current one?\n    e.cellRange.p0[axis] = e.cellRange.p1[axis] = nextCellIndex;\n    // The length of the crossing, in cells, depends on the position of the bounding rect at that time.\n    var rect = Rect.alloc();\n    this.getPaddedBodyBoundingRect(body, t, rect);\n    e.cellRange.p0[perp] = this.cellCoord(rect.pos[perp] - rect.rad[perp]);\n    e.cellRange.p1[perp] = this.cellCoord(rect.pos[perp] + rect.rad[perp]);\n    rect.free();\n  }\n  vSign.free();\n  return e;\n};\n\nWorld.prototype.addSubsequentGridEvent = function(body, prevEvent) {\n  var event = WorldEvent.alloc();\n  if (this.getSubsequentGridEvent(body, prevEvent, event)) {\n    this.queue.add(event);\n  } else {\n    event.free();\n  }\n};\n\n/**\n * Returns the next event in the queue, without dequeueing it.\n */\nWorld.prototype.getNextEvent = function() {\n  this.validateBodies();\n  return this.queue.getFirst();\n};\n\n/**\n * Removes the next event from the queue, and advances the world time to the event time,\n * optionally doing some internal processing.\n */\nWorld.prototype.processNextEvent = function() {\n  this.validateBodies();\n  var e = this.queue.removeFirst();\n  this.now = e.time;\n\n  if (e.type === WorldEvent.TYPE_GRID_ENTER) {\n    var body = this.paths[e.pathId];\n    if (body && body.pathId == e.pathId) {\n      this.addSubsequentGridEvent(body, e);\n      for (var iy = e.cellRange.p0.y; iy <= e.cellRange.p1.y; iy++) {\n        for (var ix = e.cellRange.p0.x; ix <= e.cellRange.p1.x; ix++) {\n          var cell = this.getCell(ix, iy);\n          if (!cell) {\n            cell = this.setCell(Cell.alloc(this.getGroupCount()), ix, iy);\n          }\n          this.addPathToCell(body, cell);\n        }\n      }\n    }\n\n  } else if (e.type === WorldEvent.TYPE_GRID_EXIT) {\n    var body = this.paths[e.pathId];\n    if (body && body.pathId == e.pathId) {\n      this.addSubsequentGridEvent(body, e);\n      this.removeBodyFromCellRange(body, e.cellRange);\n    }\n\n  } else if (e.type === WorldEvent.TYPE_HIT) {\n    // Let the game handle it.\n\n  } else if (e.type === WorldEvent.TYPE_TIMEOUT) {\n    var spirit = this.spirits[e.spiritId];\n    if (spirit) {\n      spirit.onTimeout(this, e);\n    }\n  }\n  e.free();\n};\n\nWorld.prototype.addTimeout = function(time, spiritId, val) {\n  var e = WorldEvent.alloc();\n  e.type = WorldEvent.TYPE_TIMEOUT;\n  e.time = time;\n  e.spiritId = spiritId;\n  e.timeoutVal = val;\n  this.queue.add(e);\n};\n\n/**\n * Adds the timeout to the event queue.\n */\nWorld.prototype.loadTimeout = function(e) {\n  this.addTimeout(e.time, e.spiritId, e.timeoutVal);\n};\n\n// TODO World.prototype.removeTimeout\n\n/**\n * Performs an immediate rayscan. If there's a hit, this will return true,\n * and the response will be populated. Otherwise it will be untouched.\n * @param {ScanRequest} req Input param\n * @param {ScanResponse} resp Output param.\n * @return {boolean} true if there's a hit, false if not.\n */\nWorld.prototype.rayscan = function(req, resp) {\n  this.validateBodies();\n  this.scannedBodyIds.reset();\n  var foundHit = false;\n\n  // Create a Body based on the ScanRequest.\n  var b = Body.alloc();\n  b.hitGroup = req.hitGroup;\n  b.setPosAtTime(req.pos, this.now);\n  b.vel.set(req.vel);\n  b.shape = req.shape;\n  b.rad = req.rad;\n  b.rectRad.set(req.rectRad);\n  b.pathDurationMax = 1;\n\n  // allocs\n  var rect = Rect.alloc();\n  var range = CellRange.alloc();\n  var hitEvent = WorldEvent.alloc();\n  var xEvent = WorldEvent.alloc();\n  var yEvent = WorldEvent.alloc();\n\n  // The hitEvent will always be the earliest hit, because every time a hit is found,\n  // the body's pathDurationMax is ratcheted down to the hit time. So only\n  // earlier hits will be discovered afterwards.\n  hitEvent.time = this.now + b.pathDurationMax + 1; // effective infinity\n\n  // Examine the body's starting cells.\n  b.getBoundingRectAtTime(this.now, rect);\n  this.getCellRangeForRect(rect, range);\n  if (this.getRayscanHit(b, range, hitEvent)) {\n    foundHit = true;\n  }\n\n  // Calc the initial grid-enter events\n  xEvent.time = yEvent.time = this.now + b.pathDurationMax + 1; // effective infinity\n\n  this.getFirstGridEvent(b, WorldEvent.TYPE_GRID_ENTER, Vec2d.X, xEvent);\n  this.getFirstGridEvent(b, WorldEvent.TYPE_GRID_ENTER, Vec2d.Y, yEvent);\n\n  // Process the earliest grid-enter event and generate the next one,\n  // until they're later than the max time.\n  var maxTime = this.now + b.pathDurationMax;\n  var eventOut = WorldEvent.alloc();\n  var tmp;\n  while (xEvent.time <  maxTime || yEvent.time < maxTime) {\n    if (xEvent.time < yEvent.time) {\n      if (this.getRayscanHit(b, xEvent.cellRange, hitEvent)) {\n        foundHit = true;\n      }\n      if (this.getSubsequentGridEvent(b, xEvent, eventOut)) {\n        tmp = xEvent;\n        xEvent = eventOut;\n        eventOut = tmp;\n      } else {\n        // Push event out of range.\n        xEvent.time = maxTime + 1;\n      }\n    } else {\n      if (this.getRayscanHit(b, yEvent.cellRange, hitEvent)) {\n        foundHit = true;\n      }\n      if (this.getSubsequentGridEvent(b, yEvent, eventOut)) {\n        tmp = yEvent;\n        yEvent = eventOut;\n        eventOut = tmp;\n      } else {\n        // Push event out of range.\n        yEvent.time = maxTime + 1;\n      }\n    }\n    // lower maxTime\n    maxTime = this.now + b.pathDurationMax;\n  }\n\n  if (foundHit) {\n    // The request body's pathId is 0, so take the non-zero one.\n    resp.pathId = hitEvent.pathId0 || hitEvent.pathId1;\n    resp.timeOffset = hitEvent.time - this.now;\n    resp.collisionVec.set(hitEvent.collisionVec);\n  }\n  rect.free();\n  range.free();\n  hitEvent.free();\n  xEvent.free();\n  yEvent.free();\n  return foundHit;\n};\n\n/**\n * Gets the earliest hit between a Body and all the bodies in a CellRange.\n * Side effect: The input body's pathDurationMax will shrink to the hit time.\n * @param {Body} body\n * @param {CellRange} range\n * @param {WorldEvent} eventOut\n * @returns {?WorldEvent} eventOut if there was a hit, or null otherwise.\n */\nWorld.prototype.getRayscanHit = function(body, range, eventOut) {\n  var retval = null;\n  for (var iy = range.p0.y; iy <= range.p1.y; iy++) {\n    for (var ix = range.p0.x; ix <= range.p1.x; ix++) {\n      var cell = this.getCell(ix, iy);\n      if (cell) {\n        var hitGroups = this.groupHitsGroups[body.hitGroup];\n        for (var gi = 0; gi < hitGroups.length; gi++) {\n          var otherGroup = hitGroups[gi];\n          var pathIdSet = cell.getPathIdsForGroup(otherGroup);\n          var pathIdArray = pathIdSet.vals;\n          for (var i = 0; i < pathIdArray.length;) {\n            var pathId = pathIdArray[i];\n            var otherBody = this.paths[pathId];\n            if (otherBody && otherBody.pathId == pathId) {\n              if (!this.scannedBodyIds.contains(otherBody.id)) {\n                this.scannedBodyIds.put(otherBody.id);\n                otherBody.freezeAtTime(this.now);\n                if (this.hitDetector.calcHit(this.now, body, otherBody, eventOut)) {\n                  retval = eventOut;\n                  // Tighten the duration max. There's no point in looking for later hits, just earlier ones.\n                  // (This is OK for rayscans, but never do it for other bodies.)\n                  body.pathDurationMax = eventOut.time - this.now;\n                }\n                otherBody.unfreeze();\n              }\n              i++;\n            } else {\n              pathIdSet.removeIndex(i);\n            }\n          }\n        }\n      }\n    }\n  }\n  return retval;\n};\n\n/**\n * Gets the instantaneous overlaps of a body with the objects in the world, at world.now.\n * Takes the body's hitGtoup into account, but not its path duration.\n * @param {Body} body  the query, as a Body.\n * @return {Array.<String>} body IDs\n */\nWorld.prototype.getOverlaps = function(body) {\n  var retval = [];\n  this.validateBodies();\n  this.scannedBodyIds.reset();\n  var brect = this.getPaddedBodyBoundingRect(body, this.now, Rect.alloc());\n  var range = this.getCellRangeForRect(brect, CellRange.alloc());\n  for (var iy = range.p0.y; iy <= range.p1.y; iy++) {\n    for (var ix = range.p0.x; ix <= range.p1.x; ix++) {\n      var cell = this.getCell(ix, iy);\n      if (cell) {\n        var hitGroups = this.groupHitsGroups[body.hitGroup];\n        for (var gi = 0; gi < hitGroups.length; gi++) {\n          var otherGroup = hitGroups[gi];\n          var pathIdSet = cell.getPathIdsForGroup(otherGroup);\n          var pathIdArray = pathIdSet.vals;\n          for (var pi = 0; pi < pathIdArray.length;) {\n            var pathId = pathIdArray[pi];\n            var otherBody = this.paths[pathId];\n            if (otherBody && otherBody.pathId == pathId) {\n              if (!this.scannedBodyIds.contains(otherBody.id)) {\n                this.scannedBodyIds.put(otherBody.id);\n                if (OverlapDetector.isBodyOverlappingBodyAtTime(body, otherBody, this.now)) {\n                  retval.push(otherBody.id);\n                }\n              }\n              pi++;\n            } else {\n              // opportunistically erase obsolete path from cell\n              pathIdSet.removeIndex(pi);\n            }\n          }\n        }\n      }\n    }\n  }\n  brect.free();\n  range.free();\n  return retval;\n};\n\nWorld.prototype.getPaddedBodyBoundingRect = function(body, time, rectOut) {\n  return body.getBoundingRectAtTime(time, rectOut).pad(this.cellSize * World.BRECT_FUDGE_FACTOR)\n}\n\n\n/* ---- js/physics/worldevent.js ---- */\n\n\n/**\n * A union of all the world event types and their fields, as a SkipList node.\n * @constructor\n */\nfunction WorldEvent() {\n  this.next = [];\n  this.cellRange = new CellRange(0, 0, -1, -1);\n\n  // This is a vector along which collision acceleration should be applied,\n  // for default elastic collision resolution.\n  this.collisionVec = new Vec2d();\n  this.reset();\n}\n\n// Only for TYPE_TIMEOUT events so far.\nWorldEvent.SCHEMA = {\n  0: 'time',\n  1: 'type',\n  2: 'spiritId',\n  3: 'timeoutVal'\n};\n\nWorldEvent.getJsoner = function() {\n  if (!WorldEvent.jsoner) {\n    WorldEvent.jsoner = new Jsoner(WorldEvent.SCHEMA);\n  }\n  return WorldEvent.jsoner;\n};\n\nWorldEvent.prototype.toJSON = function() {\n  return WorldEvent.getJsoner().toJSON(this);\n};\n\nWorldEvent.prototype.setFromJSON = function(json) {\n  WorldEvent.getJsoner().setFromJSON(json, this);\n};\n\nWorldEvent.TYPE_TIMEOUT = 'timeout';\nWorldEvent.TYPE_GRID_ENTER = 'enter';\nWorldEvent.TYPE_GRID_EXIT = 'exit';\nWorldEvent.TYPE_HIT = 'hit';\n\nWorldEvent.prototype.reset = function() {\n  // SkipQueue node stuff\n  this.time = 0;\n  this.next.length = 0;\n\n  // Which kind of event is it? One of the TYPE constants.\n  this.type = 0;\n\n  // timeout fields\n  this.spiritId = 0;\n  this.timeoutVal = null;\n\n  // grid enter/exit cell range\n  this.axis = null; // one of Vec2d.X or Vec2d.Y\n  this.pathId = 0;\n  this.cellRange.reset();\n\n  // hit fields\n  this.pathId0 = 0;\n  this.pathId1 = 0;\n  this.collisionVec.reset();\n  // this.axis, if set, means there was a hit on a side of a rectangle. X means it was east or west, Y is N or S.\n\n  return this;\n};\n\nWorldEvent.pool = [];\n\nWorldEvent.alloc = function() {\n  if (WorldEvent.pool.length) {\n    return WorldEvent.pool.pop().reset();\n  }\n  return new WorldEvent();\n};\n\nWorldEvent.prototype.free = function() {\n  WorldEvent.pool.push(this);\n};\n\nWorldEvent.prototype.toString = function() {\n  var s = [];\n  s.push('{time: ', this.time, ', type: ', this.type);\n  if (this.type === WorldEvent.TYPE_TIMEOUT) {\n    s.push(', spiritId: ', this.spiritId, ', timeoutVal: ', this.timeoutVal);\n  } else if (this.type === WorldEvent.TYPE_GRID_ENTER || this.type === WorldEvent.TYPE_GRID_EXIT) {\n    s.push(', pathId: ', this.pathId, ', axis: ' + this.axis, ', cellRange: ' + JSON.stringify(this.cellRange));\n  } else if (this.type === WorldEvent.TYPE_HIT) {\n    s.push(', pathId0: ', this.pathId0, ', pathId1: ', this.pathId1);\n  }\n  s.push('}');\n  return s.join('');\n};\n\n\n// --------------------- SOUND -----------------------\n\n\n\n/* ---- js/sound/soundfx.js ---- */\n\n\n/**\n * Utils for producing sound effects positioned in 3D.\n * @param {=AudioContext} opt_audioContext\n * @constructor\n */\nfunction SoundFx(opt_audioContext) {\n  this.ctx = opt_audioContext || SoundFx.getAudioContext();\n  if (this.ctx) {\n    if (!(this.ctx.createGain || this.ctx.createGainNode) || !this.ctx.createOscillator) {\n      this.ctx = null;\n    }\n  }\n  if (this.ctx) {\n    this.masterGain = this.createGain();\n    this.masterGain.connect(this.ctx.destination);\n  }\n}\n\nSoundFx.audioContext = null;\n\nSoundFx.getAudioContext = function() {\n  if (SoundFx.audioContext != null) {\n    return SoundFx.audioContext;\n  } else if (typeof AudioContext !== 'undefined') {\n    SoundFx.audioContext = new AudioContext();\n  } else if (typeof webkitAudioContext !== 'undefined') {\n    SoundFx.audioContext = new webkitAudioContext();\n  }\n  return SoundFx.audioContext;\n};\n\nSoundFx.prototype.createGain = function() {\n  if (this.ctx.createGain) {\n    return this.ctx.createGain();\n  }\n  if (this.ctx.createGainNode) {\n    return this.ctx.createGainNode();\n  }\n  return null;\n};\n\nSoundFx.prototype.setListenerXYZ = function(x, y, z) {\n  if (!this.ctx) return;\n  this.ctx.listener.setPosition(x, y, z);\n};\n\nSoundFx.prototype.getMasterGain = function() {\n  return this.masterGain;\n};\n\n/**\n * Make a simple one-shot sound.\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @param {number} vol\n * @param {number} attack\n * @param {number} sustain\n * @param {number} decay\n * @param {number} freq1\n * @param {number} freq2\n * @param {String} type Wave type string (square, sine, etc)\n */\nSoundFx.prototype.sound = function(x, y, z, vol, attack, sustain, decay, freq1, freq2, type, opt_delay) {\n  if (!this.ctx) return;\n  var delay = opt_delay || 0;\n  var c = this.ctx;\n  var t0 = c.currentTime + delay;\n  var t1 = t0 + attack + sustain + decay;\n  var gain = this.createGain();\n  if (attack) {\n    gain.gain.setValueAtTime(0.001, t0);\n    gain.gain.exponentialRampToValueAtTime(vol, t0 + attack);\n  }\n  gain.gain.setValueAtTime(vol, t0 + attack);\n  if (sustain) {\n    gain.gain.setValueAtTime(vol, t0 + attack + sustain);\n  }\n  if (decay) {\n    gain.gain.exponentialRampToValueAtTime(0.01, t0 + attack + sustain + decay);\n  }\n\n  var osc = c.createOscillator();\n  osc.frequency.setValueAtTime(freq1, t0);\n  osc.frequency.exponentialRampToValueAtTime(freq2, t0 + attack + sustain + decay);\n  osc.type = type;\n  if (osc.start) {\n    osc.start(t0);\n  } else if (osc.noteOn) {\n    osc.noteOn(t0);\n  }\n  if (osc.stop) {\n    osc.stop(t1);\n  } else if (osc.noteOff) {\n    osc.noteOff(t1);\n  }\n\n  var panner = c.createPanner();\n  panner.setPosition(x, y, z);\n\n  osc.connect(gain);\n  gain.connect(panner);\n  panner.connect(this.masterGain);\n};\n\n/**\n * Makes a sound with no attack, decay, or frequency changes.\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @param {number} vol\n * @param {number} sustain\n * @param {number} freq\n * @param {String} opt_type Wave type string (square, sine, etc). Default is sine\n */\nSoundFx.prototype.note = function(x, y, z, vol, sustain, freq, opt_type) {\n  var type = opt_type || 'sine';\n  this.sound(x, y, z, vol, 0, sustain, 0, freq, freq, type);\n}\n\nSoundFx.prototype.disconnect = function() {\n  if (this.masterGain) {\n    this.masterGain.gain = 0;\n    this.masterGain.disconnect();\n    this.masterGain = null;\n  }\n};\n\n\n\n// ---------- TOUCH/TRIGGER/POINTER EVENTS -----------\n\n\n\n/* ---- js/controls/pointerevent.js ---- */\n\n\n/**\n * @constructor\n */\nfunction PointerEvent() {\n  this.pos = new Vec2d();\n  this.reset();\n}\n\n/** touch start, and mouse down */\nPointerEvent.TYPE_DOWN = 1;\n\n/** touch move and mouse move */\nPointerEvent.TYPE_MOVE = 2;\n\n/** touch end+cancel+leave, and mouse up */\nPointerEvent.TYPE_UP = 3;\n\nPointerEvent.prototype.reset = function() {\n  this.type = null;\n  this.pointerId = null;\n  this.time = 0;\n  this.pos.reset();\n  return this;\n};\n\nPointerEvent.pool = [];\n\nPointerEvent.alloc = function() {\n  if (PointerEvent.pool.length) {\n    return PointerEvent.pool.pop().reset();\n  }\n  return new PointerEvent();\n};\n\nPointerEvent.prototype.free = function() {\n  PointerEvent.pool.push(this);\n};\n\n\n/* ---- js/controls/multipointer.js ---- */\n\n\n/**\n * Multiple pointer handler, blending mouse and touch on a canvas.\n * Each frame it provides before and after snapshots, and a\n * log of all the events in between.\n * If queueing is on, be sure to call clearEventQueue() after handling event data, and before waiting until the next\n * frame, because mouse and touch events only arrive when no other JS is running.\n * @param canvas\n * @param {Matrix44} viewMatrix\n * @param {boolean} queueing\n *\n * @constructor\n */\nfunction MultiPointer(canvas, viewMatrix, queueing) {\n  this.canvas = canvas;\n  this.inverseViewMatrix = new Matrix44();\n  this.setViewMatrix(viewMatrix);\n\n  // Maps from IDs to Vec2d()s.\n  this.eventCoords = {};\n  this.oldPositions = {};\n  this.positions = {};\n\n  // Queue of PointerEvent objects. There are usually only a few per frame,\n  // so 100 is grossly overkill, I hope.\n  this.queue = queueing ? new CircularQueue(100) : null;\n\n  this.mat44 = new Matrix44;\n  this.vec4 = new Vec4();\n  this.canvasToClip = new Matrix44();\n\n  var self = this;\n\n  this.touchStartListener = function(e) {\n    self.onTouchStart(e);\n  };\n  this.touchMoveListener = function(e) {\n    self.onTouchMove(e);\n  };\n  this.touchEndListener = function(e) {\n    self.onTouchEnd(e);\n  };\n  this.mouseDownListener = function(e) {\n    self.onMouseDown(e);\n  };\n  this.mouseMoveListener = function(e) {\n    self.onMouseMove(e);\n  };\n  this.mouseUpListener = function(e) {\n    self.onMouseUp(e);\n  };\n\n  this.domEventListeners = new ArraySet();\n\n  this.listening = false;\n}\n\nMultiPointer.MOUSE_ID = 'mouse';\n\nMultiPointer.prototype.startListening = function() {\n  if (!this.listening) {\n    document.body.addEventListener('mousedown', this.mouseDownListener);\n    document.body.addEventListener('mousemove', this.mouseMoveListener);\n    document.body.addEventListener('mouseup', this.mouseUpListener);\n    document.body.addEventListener('touchstart', this.touchStartListener);\n    document.body.addEventListener('touchmove', this.touchMoveListener);\n    document.body.addEventListener('touchend', this.touchEndListener);\n    document.body.addEventListener('touchcancel', this.touchEndListener);\n    document.body.addEventListener('touchleave', this.touchEndListener);\n    this.listening = true;\n  }\n  return this;\n};\n\nMultiPointer.prototype.stopListening = function() {\n  if (this.listening) {\n    document.body.removeEventListener('mousedown', this.mouseDownListener);\n    document.body.removeEventListener('mousemove', this.mouseMoveListener);\n    document.body.removeEventListener('mouseup', this.mouseUpListener);\n    document.body.removeEventListener('touchstart', this.touchStartListener);\n    document.body.removeEventListener('touchmove', this.touchMoveListener);\n    document.body.removeEventListener('touchend', this.touchEndListener);\n    document.body.removeEventListener('touchcancel', this.touchEndListener);\n    document.body.removeEventListener('touchleave', this.touchEndListener);\n    this.listening = false;\n    this.clearEventQueue();\n    for (var id in this.positions) {\n      delete this.positions[id];\n    }\n    for (var id in this.oldPositions) {\n      delete this.oldPositions[id];\n    }\n    for (var id in this.eventCoords) {\n      delete this.eventCoords[id];\n    }\n  }\n  return this;\n};\n\n/**\n * Adds a function that will be called as part of the read DOM event handler stack,\n * so it will be able to do things like toggle fullscreen or pointer events.\n * The function will be called with a PointerEvent, the same one that gets added to\n * the internal queue.\n * @param {Function} fn\n */\nMultiPointer.prototype.addListener = function(fn) {\n  this.domEventListeners.put(fn);\n};\n\n/**\n * @param {Function} fn\n */\nMultiPointer.prototype.removeListener = function(fn) {\n  this.domEventListeners.remove(fn);\n};\n\nMultiPointer.prototype.getQueueSize = function() {\n  return this.queue ? this.queue.size() : 0;\n};\n\n/**\n * @param index Zero is the oldest event, and getQueueSize-1 is the newest.\n * @returns {PointerEvent}\n */\nMultiPointer.prototype.getPointerEventFromTail = function(index) {\n  return this.queue.getFromTail(index);\n};\n\nMultiPointer.prototype.setViewMatrix = function(viewMatrix) {\n  viewMatrix.getInverse(this.inverseViewMatrix);\n  if (!this.listening) return;\n\n  // Effectively, every point has moved, so create a move event for them.\n  for (var id in this.positions) {\n    var e = PointerEvent.alloc();\n    e.type = PointerEvent.TYPE_MOVE;\n    e.pointerId = id;\n    e.time = Date.now();\n    e.pos.set(this.eventCoords[id]);\n    this.transformCanvasToWorld(e.pos);\n    this.enqueue(e);\n\n    this.positions[id].set(e.pos);\n  }\n};\n\n/**\n * Flips the old and new position snapshots, and clears the queue\n */\nMultiPointer.prototype.clearEventQueue = function() {\n  if (!this.queue) return;\n  // Delete obsolete oldPos entries\n  for (var id in this.oldPositions) {\n    if (!(id in this.positions)) {\n      this.oldPositions[id].free();\n      delete this.oldPositions[id];\n    }\n  }\n  for (id in this.positions) {\n    if (!(id in this.oldPositions)) {\n      this.oldPositions[id] = Vec2d.alloc();\n    }\n    this.oldPositions[id].set(this.positions[id]);\n  }\n  while (!this.queue.isEmpty()) {\n    this.queue.dequeue();\n  }\n};\n\nMultiPointer.prototype.isPointerLocked = function() {\n  return document.pointerLockElement ||\n         document.mozPointerLockElement ||\n         document.webkitPointerLockElement;\n};\n\nMultiPointer.prototype.onMouseDown = function(e) {\n  if (!this.isPointerLocked()) {\n    this.down(MultiPointer.MOUSE_ID, e.clientX, e.clientY);\n  }\n};\n\nMultiPointer.prototype.onMouseMove = function(e) {\n  this.move(MultiPointer.MOUSE_ID, e.clientX, e.clientY);\n};\n\nMultiPointer.prototype.onMouseUp = function(e) {\n  this.up(MultiPointer.MOUSE_ID, e.clientX, e.clientY);\n};\n\nMultiPointer.prototype.onTouchStart = function(e) {\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    this.down(touch.identifier, touch.pageX, touch.pageY);\n  }\n};\n\nMultiPointer.prototype.onTouchMove = function(e) {\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    this.move(touch.identifier, touch.pageX, touch.pageY);\n  }\n};\n\nMultiPointer.prototype.onTouchEnd = function(e) {\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    this.up(touch.identifier, touch.pageX, touch.pageY);\n  }\n};\n\nMultiPointer.prototype.down = function(id, x, y) {\n  var e = PointerEvent.alloc();\n  e.type = PointerEvent.TYPE_DOWN;\n  e.pointerId = id;\n  e.time = Date.now();\n  e.pos.setXY(x, y);\n  this.transformCanvasToWorld(e.pos);\n  this.enqueue(e);\n\n  if (!(id in this.positions)) {\n    this.positions[id] = Vec2d.alloc();\n  }\n  this.positions[id].set(e.pos);\n\n  if (!(id in this.eventCoords)) {\n    this.eventCoords[id] = Vec2d.alloc();\n  }\n  this.eventCoords[id].setXY(x, y);\n  this.callListeners(e);\n};\n\nMultiPointer.prototype.move = function(id, x, y) {\n  if (id in this.positions) {\n    var e = PointerEvent.alloc();\n    e.type = PointerEvent.TYPE_MOVE;\n    e.pointerId = id;\n    e.time = Date.now();\n    e.pos.setXY(x, y);\n    this.transformCanvasToWorld(e.pos);\n    this.enqueue(e);\n\n    this.positions[id].set(e.pos);\n    this.eventCoords[id].setXY(x, y);\n    this.callListeners(e);\n  }\n};\n\nMultiPointer.prototype.enqueue = function(e) {\n  if (this.queue) {\n    this.queue.enqueue(e);\n  }\n};\n\nMultiPointer.prototype.up = function(id, x, y) {\n  if (id in this.positions) {\n    var e = PointerEvent.alloc();\n    e.type = PointerEvent.TYPE_UP;\n    e.pointerId = id;\n    e.time = Date.now();\n    e.pos.setXY(x, y);\n    this.transformCanvasToWorld(e.pos);\n    this.enqueue(e);\n\n    this.positions[id].free();\n    delete this.positions[id];\n\n    this.eventCoords[id].free();\n    delete this.eventCoords[id];\n    this.callListeners(e);\n  }\n};\n\nMultiPointer.prototype.callListeners = function(e) {\n  var listeners = this.domEventListeners.vals;\n  for (var i = 0; i < listeners.length; i++) {\n    listeners[i](e);\n  }\n};\n\n/**\n * Transforms a vec2d in place using this current matrix44\n * @param {Vec2d} vec2d\n * @returns {Vec2d}\n */\nMultiPointer.prototype.transformCanvasToWorld = function(vec2d) {\n  // canvas to clip\n  this.canvasToClip.toScaleOpXYZ(2 / this.canvas.width, -2 / this.canvas.height, 1);\n  this.canvasToClip.multiply(this.mat44.toTranslateOpXYZ(-this.canvas.width / 2, -this.canvas.height / 2, 0));\n  this.vec4.setXYZ(vec2d.x, vec2d.y, 0).transform(this.canvasToClip);\n\n  // clip to world\n  this.vec4.transform(this.inverseViewMatrix);\n\n  vec2d.setXY(this.vec4.v[0], this.vec4.v[1]);\n  return vec2d;\n};\n\n\n/* ---- js/controls/key.js ---- */\n\n\n/**\n * @param {string} name\n * @param {number} keyCode\n * @constructor\n */\nfunction Key(name, keyCode) {\n  this.name = name;\n  this.keyCode = keyCode;\n}\n\n/**\n * Names of keys that don't always have a\n * readable single character representation.\n * @enum {string}\n */\nKey.Name = {\n  UP: 'up',\n  DOWN: 'down',\n  LEFT: 'left',\n  RIGHT: 'right',\n  BACKSPACE: 'backspace',\n  DELETE: 'delete',\n  SPACE: 'space',\n  SEMICOLON: ';',\n  BACKSLASH: '\\\\',\n  ESC: 'esc'\n};\n\n\n/* ---- js/controls/keys.js ---- */\n\n\n/**\n * Associates numeric keycodes with programmer-friendly names.\n * @constructor\n */\nfunction Keys() {\n  // Index the keys by both fields.\n  this.byKeyCode = {};\n  this.byName = {};\n  this.initialized = false;\n}\n\nKeys.prototype.getKeyCodeForName = function(name) {\n  if (!this.initialized) this.initKeys();\n  var key = this.byName[name];\n  return key ? key.keyCode : null;\n};\n\nKeys.prototype.getNameForKeyCode = function(keyCode) {\n  if (!this.initialized) this.initKeys();\n  var key = this.byKeyCode[keyCode];\n  return key ? key.name : null;\n};\n\n/**\n *  Add all letters, numbers, and Key.Name values to byKeyCode and byName indexes.\n */\nKeys.prototype.initKeys = function() {\n  var self = this;\n\n  function addKey(name, keyCode) {\n    var key = new Key(name, keyCode);\n    self.byName[name] = key;\n    self.byKeyCode[keyCode] = key;\n  }\n\n  function addKeySequence(firstChar, firstKeyCode, lastChar) {\n    var firstCharCode = firstChar.charCodeAt(0);\n    var lastCharCode = lastChar.charCodeAt(0);\n    if (firstCharCode > lastCharCode) throw Error(firstChar + ' > ' + lastChar);\n    var keyCode = firstKeyCode;\n    for (var charCode = firstCharCode; charCode <= lastCharCode; charCode++) {\n      addKey(String.fromCharCode(charCode), keyCode);\n      keyCode++;\n    }\n  }\n  addKeySequence('a', 65, 'z');\n  addKeySequence('0', 48, '9');\n\n  addKey(Key.Name.LEFT, 37);\n  addKey(Key.Name.UP, 38);\n  addKey(Key.Name.RIGHT, 39);\n  addKey(Key.Name.DOWN, 40);\n\n  addKey(Key.Name.BACKSPACE, 8);\n  addKey(Key.Name.DELETE, 46);\n  addKey(Key.Name.SPACE, 32);\n\n  addKey(Key.Name.SEMICOLON, 186);\n  addKey(Key.Name.BACKSLASH, 220);\n\n  addKey(Key.Name.ESC, 27);\n\n  this.initialized = true;\n};\n\n\n\n/* ---- js/controls/trackball.js ---- */\n\n\n\n/**\n * Control trackball base class\n * @constructor\n */\nfunction Trackball() {\n  this.val = new Vec2d();\n  this.friction = 0.05;\n  this.touched = false;\n}\n\nTrackball.prototype.setFriction = function(f) {\n  this.friction = f;\n  return this;\n};\n\n/**\n * @param {Vec2d} out\n * @return {Vec2d} out\n */\nTrackball.prototype.getVal = function(out) {\n  return out.set(this.val);\n};\n\n/**\n * Resets the delta between the old position and the new. Use in the event loop\n * after everyone's had a chance to read the trackball val, to prepare\n * to accumulate delta events before the next iteration.\n */\nTrackball.prototype.reset = function() {console.log(\"reset unimplimented\")};\n\nTrackball.prototype.isTouched = function() {\n  return this.touched;\n};\n\nTrackball.prototype.startListening = function() {console.log(\"startListening unimplimented\")};\nTrackball.prototype.stopListening = function() {console.log(\"stopListening unimplimented\")};\n\n\n\n/* ---- js/controls/touchdetector.js ---- */\n\n\n\n/**\n * Detects that the user is using touch (vs keys/mouse), so we can decide to show touch UI, or not.\n * @constructor\n */\nfunction TouchDetector() {\n  this.listening = false;\n  this.score = 0;\n\n  var self = this;\n  this.touchListener = function() {\n    self.score = Math.min(5, self.score + 0.1);\n  };\n}\n\nTouchDetector.prototype = new Trigger();\nTouchDetector.prototype.constructor = TouchDetector;\n\nTouchDetector.prototype.startListening = function() {\n  document.body.addEventListener('touchstart', this.touchListener);\n  document.body.addEventListener('touchmove', this.touchListener);\n  document.body.addEventListener('touchend', this.touchListener);\n  document.body.addEventListener('touchcancel', this.touchListener);\n  return this;\n};\n\nTouchDetector.prototype.stopListening = function() {\n  document.body.removeEventListener('touchstart', this.touchListener);\n  document.body.removeEventListener('touchmove', this.touchListener);\n  document.body.removeEventListener('touchend', this.touchListener);\n  document.body.removeEventListener('touchcancel', this.touchListener);\n  this.val = 0;\n  return this;\n};\n\n\nTouchDetector.prototype.decrease = function() {\n  this.score = Math.max(0, this.score - 0.01);\n};\n\nTouchDetector.prototype.getVal = function() {\n  return Math.max(0, Math.min(1, this.score));\n};\n\n\n\n/* ---- js/controls/mousepointer.js ---- */\n\n\n\n/**\n * Mouse pointer wrapped in my silly start/stopListening & pubsub & queueing stuff.\n * Each frame it provides before and after snapshots, in world coordinates.\n *\n * If queueing is on, it provides a log of all events since the last clearEventQueue().\n * When queueing is on, be sure to call clearEventQueue() after handling event data,\n * before waiting for the next animation frame, because events only arrive when no other JS is running.\n * @param canvas  used to map mouse coords to world coords\n * @param {Matrix44} viewMatrix  from world to clipspace, also used to map mousecoords to world coords\n * @param {boolean} queueing  true if this should retain a log of all events that happened between frames.\n *\n * @constructor\n */\nfunction MousePointer(canvas, viewMatrix, queueing) {\n  this.canvas = canvas;\n  this.inverseViewMatrix = new Matrix44();\n  this.oldViewMatrix = new Matrix44();\n  this.setViewMatrix(viewMatrix);\n\n  this.eventCoords = new Vec2d();\n  this.oldPosition = new Vec2d();\n  this.position = new Vec2d();\n\n  // Queue of PointerEvent objects. There are usually only a few per frame,\n  // so 100 is grossly overkill, I hope.\n  this.queue = queueing ? new CircularQueue(100) : null;\n\n  this.mat44 = new Matrix44;\n  this.vec4 = new Vec4();\n  this.canvasToClip = new Matrix44();\n\n  var self = this;\n  this.mouseDownListener = function(e) {\n    self.onMouseDown(e);\n  };\n  this.mouseMoveListener = function(e) {\n    self.onMouseMove(e);\n  };\n  this.mouseUpListener = function(e) {\n    self.onMouseUp(e);\n  };\n\n  this.domEventListeners = new ArraySet();\n\n  this.listening = false;\n}\n\nMousePointer.MOUSE_ID = 'mouse';\n\nMousePointer.prototype.startListening = function() {\n  if (!this.listening) {\n    this.canvas.addEventListener('mousedown', this.mouseDownListener);\n    this.canvas.addEventListener('mousemove', this.mouseMoveListener);\n    this.canvas.addEventListener('mouseup', this.mouseUpListener);\n    this.listening = true;\n  }\n  return this;\n};\n\nMousePointer.prototype.stopListening = function() {\n  if (this.listening) {\n    this.canvas.removeEventListener('mousedown', this.mouseDownListener);\n    this.canvas.removeEventListener('mousemove', this.mouseMoveListener);\n    this.canvas.removeEventListener('mouseup', this.mouseUpListener);\n    this.listening = false;\n    this.clearEventQueue();\n  }\n  return this;\n};\n\n/**\n * Adds a function that will be called as part of the read DOM event handler stack,\n * so it will be able to do things like toggle fullscreen or pointer events.\n * The function will be called with a PointerEvent, the same one that gets added to\n * the internal queue.\n * @param {Function} fn\n */\nMousePointer.prototype.addListener = function(fn) {\n  this.domEventListeners.put(fn);\n};\n\n/**\n * @param {Function} fn\n */\nMousePointer.prototype.removeListener = function(fn) {\n  this.domEventListeners.remove(fn);\n};\n\nMousePointer.prototype.getQueueSize = function() {\n  return this.queue ? this.queue.size() : 0;\n};\n\n/**\n * @param index Zero is the oldest event, and getQueueSize-1 is the newest.\n * @returns {PointerEvent}\n */\nMousePointer.prototype.getPointerEventFromTail = function(index) {\n  return this.queue.getFromTail(index);\n};\n\nMousePointer.prototype.setViewMatrix = function(viewMatrix) {\n  if (this.oldViewMatrix.equals(viewMatrix)) return;\n  this.oldViewMatrix.set(viewMatrix);\n  viewMatrix.getInverse(this.inverseViewMatrix);\n  if (!this.listening) return;\n\n  var e = PointerEvent.alloc();\n  e.type = PointerEvent.TYPE_MOVE;\n  e.pointerId = MousePointer.MOUSE_ID;\n  e.time = Date.now();\n  e.pos.set(this.eventCoords);\n  this.transformCanvasToWorld(e.pos);\n  this.enqueue(e);\n\n  this.position.set(e.pos);\n};\n\n/**\n * Flips the old and new position snapshots, and clears the queue\n */\nMousePointer.prototype.clearEventQueue = function() {\n  if (!this.queue) return;\n  this.oldPosition.set(this.position);\n  while (!this.queue.isEmpty()) {\n    this.queue.dequeue();\n  }\n};\n\nMousePointer.prototype.isPointerLocked = function() {\n  return document.pointerLockElement ||\n         document.mozPointerLockElement ||\n         document.webkitPointerLockElement;\n};\n\nMousePointer.prototype.onMouseDown = function(e) {\n  if (!this.isPointerLocked()) {\n    this.down(e.clientX, e.clientY);\n  }\n};\n\nMousePointer.prototype.onMouseMove = function(e) {\n  this.move(e.clientX, e.clientY);\n};\n\nMousePointer.prototype.onMouseUp = function(e) {\n  this.up(e.clientX, e.clientY);\n};\n\nMousePointer.prototype.down = function(x, y) {\n  var e = PointerEvent.alloc();\n  e.type = PointerEvent.TYPE_DOWN;\n  e.pointerId = MousePointer.MOUSE_ID;\n  e.time = Date.now();\n  e.pos.setXY(x, y);\n  this.transformCanvasToWorld(e.pos);\n  this.enqueue(e);\n\n  this.position.set(e.pos);\n  this.eventCoords.setXY(x, y);\n\n  this.callListeners(e);\n};\n\nMousePointer.prototype.move = function(x, y) {\n  var e = PointerEvent.alloc();\n  e.type = PointerEvent.TYPE_MOVE;\n  e.pointerId = MousePointer.MOUSE_ID;\n  e.time = Date.now();\n  e.pos.setXY(x, y);\n  this.transformCanvasToWorld(e.pos);\n  this.enqueue(e);\n\n  this.position.set(e.pos);\n  this.eventCoords.setXY(x, y);\n\n  this.callListeners(e);\n};\n\nMousePointer.prototype.enqueue = function(e) {\n  if (this.queue) {\n    this.queue.enqueue(e);\n  }\n};\n\nMousePointer.prototype.up = function(x, y) {\n  var e = PointerEvent.alloc();\n  e.type = PointerEvent.TYPE_UP;\n  e.pointerId = MousePointer.MOUSE_ID;\n  e.time = Date.now();\n  e.pos.setXY(x, y);\n  this.transformCanvasToWorld(e.pos);\n  this.enqueue(e);\n\n  this.position.set(e.pos);\n  this.eventCoords.setXY(x, y);\n\n  this.callListeners(e);\n};\n\nMousePointer.prototype.callListeners = function(e) {\n  var listeners = this.domEventListeners.vals;\n  for (var i = 0; i < listeners.length; i++) {\n    listeners[i](e);\n  }\n};\n\n/**\n * Transforms a vec2d in place using this current matrix44\n * @param {Vec2d} vec2d\n * @returns {Vec2d}\n */\nMousePointer.prototype.transformCanvasToWorld = function(vec2d) {\n  this.vec4.setXYZ(vec2d.x, vec2d.y, 0);\n\n  // canvas to clip\n  this.canvasToClip.toIdentity();\n  this.canvasToClip.multiply(this.mat44.toScaleOpXYZ(2 / this.canvas.width, -2 / this.canvas.height, 1));\n  this.canvasToClip.multiply(this.mat44.toTranslateOpXYZ(-this.canvas.width / 2, -this.canvas.height / 2, 0));\n  this.vec4.transform(this.canvasToClip);\n\n  // clip-space to world-space\n  this.vec4.transform(this.inverseViewMatrix);\n\n  vec2d.setXY(this.vec4.v[0], this.vec4.v[1]);\n  return vec2d;\n}; \n\n\n\n/* ---- js/controls/mousepointertrigger.js ---- */\n\n\n\n/**\n * A control Trigger using a mouse pointer.\n * @constructor\n * @extends {Trigger}\n */\nfunction MousePointerTrigger(opt_elem) {\n  Trigger.call(this);\n  this.listening = false;\n  this.hovered = false;\n  this.elem = opt_elem || document.body;\n\n  this.startZoneFn = function(x, y) {\n    return true;\n  };\n\n  var self = this;\n  this.mouseDownListener = function(e) {\n    return self.onMouseDown(e);\n  };\n  this.mouseMoveListener = function(e) {\n    return self.onMouseMove(e);\n  };\n  this.mouseUpListener = function(e) {\n    return self.onMouseUp(e);\n  };\n}\n\nMousePointerTrigger.prototype = new Trigger();\nMousePointerTrigger.prototype.constructor = MousePointerTrigger;\n\n/**\n * @param {function} fn  A function that takes screen coords (x, y) and returns true if the coords are\n * within the trigger start zone.\n * @returns {MousePointerTrigger}\n */\nMousePointerTrigger.prototype.setStartZoneFunction = function(fn) {\n  this.startZoneFn = fn;\n  return this;\n};\n\nMousePointerTrigger.prototype.startListening = function() {\n  this.elem.addEventListener('mousedown', this.mouseDownListener);\n  this.elem.addEventListener('mousemove', this.mouseMoveListener);\n  this.elem.addEventListener('mouseup', this.mouseUpListener);\n  return this;\n};\n\nMousePointerTrigger.prototype.stopListening = function() {\n  this.elem.removeEventListener('mousedown', this.mouseDownListener);\n  this.elem.removeEventListener('mousemove', this.mouseMoveListener);\n  this.elem.removeEventListener('mouseup', this.mouseUpListener);\n  this.val = false;\n  this.hovered = false;\n  return this;\n};\n\nMousePointerTrigger.prototype.onMouseDown = function(e) {\n  e = e || window.event;\n  if (this.startZoneFn(e.pageX, e.pageY)) {\n    this.val = true;\n    this.publishTriggerDown(e);\n\n    // For LayeredEventDistributor\n    return false;\n  }\n};\n\nMousePointerTrigger.prototype.onMouseMove = function(e) {\n  e = e || window.event;\n  this.hovered = this.startZoneFn(e.pageX, e.pageY);\n};\n\nMousePointerTrigger.prototype.onMouseUp = function(e) {\n  e = e || window.event;\n  if (this.val) {\n    this.val = false;\n    this.publishTriggerUp(e);\n\n    // For LayeredEventDistributor\n    return false;\n  }\n};\n\n\n\n/* ---- js/controls/stick.js ---- */\n\n\n\n/**\n * Control stick base class\n * @constructor\n */\nfunction Stick() {\n  this.val = new Vec2d();\n}\n\n/**\n * @param {Vec2d} out\n * @return {Vec2d} out\n */\nStick.prototype.getVal = function(out) {\n  return out.set(this.val);\n};\n\n/**\n * If the stick value is greater than one, scale it down to one.\n * @return {Vec2d}\n */\nStick.prototype.clip = function() {\n  return this.val.clipToMaxLength(1);\n};\n\n\n/* ---- js/controls/keystick.js ---- */\n\n\n/**\n * A control stick based on a keyboard.\n * @constructor\n * @extends {Stick}\n */\nfunction KeyStick() {\n  Stick.call(this);\n  this.codeToDir = {};\n  this.codeToState = {};\n  this.keys = new Keys();\n\n  var self = this;\n  this.downListener = function(e) {\n    if (!e) e = window.event;\n    if (self.codeToDir[e.keyCode]) {\n      self.codeToState[e.keyCode] = true;\n    }\n  };\n  this.upListener = function(e) {\n    if (!e) e = window.event;\n    if (self.codeToDir[e.keyCode]) {\n      self.codeToState[e.keyCode] = false;\n    }\n  };\n}\n\nKeyStick.prototype = new Stick();\nKeyStick.prototype.constructor = KeyStick;\n\nKeyStick.UP = new Vec2d(0, 1);\nKeyStick.RIGHT = new Vec2d(1, 0);\nKeyStick.DOWN = new Vec2d(0, -1);\nKeyStick.LEFT = new Vec2d(-1, 0);\n\nKeyStick.prototype.setByKeyCode = function(keyCode, vec) {\n  this.codeToDir[keyCode] = vec;\n  return this;\n};\n\nKeyStick.prototype.setByName = function(name, vec) {\n  var keyCode = this.keys.getKeyCodeForName(name);\n  this.setByKeyCode(keyCode, vec);\n  return this;\n};\n\nKeyStick.prototype.setUpRightDownLeftByName = function(up, right, down, left) {\n  this.setByName(up, KeyStick.UP);\n  this.setByName(right, KeyStick.RIGHT);\n  this.setByName(down, KeyStick.DOWN);\n  this.setByName(left, KeyStick.LEFT);\n  return this;\n};\n\nKeyStick.prototype.startListening = function() {\n  document.addEventListener('keydown', this.downListener);\n  document.addEventListener('keyup', this.upListener);\n  return this;\n};\n\nKeyStick.prototype.stopListening = function() {\n  document.removeEventListener('keydown', this.downListener);\n  document.removeEventListener('keyup', this.upListener);\n  return this;\n};\n\nKeyStick.prototype.getVal = function(out) {\n  this.val.reset();\n  for (var code in this.codeToState) {\n    if (this.codeToState[code]) {\n      this.val.add(this.codeToDir[code]);\n    }\n  }\n  this.clip();\n  return out.set(this.val);\n};\n\nKeyStick.prototype.isAnyKeyPressed = function() {\n  for (var code in this.codeToState) {\n    if (this.codeToState[code]) {\n      return true;;\n    }\n  }\n  return false;\n};\n\n\n/* ---- js/controls/keytrackball.js ---- */\n\n\n/**\n * A control trackball using up/down/left/right keys.\n * @constructor\n * @extends {Trackball}\n */\nfunction KeyTrackball(keyStick) {\n  Trackball.call(this);\n  this.keyStick = keyStick;\n  this.needsValChange = true;\n  this.accel = 0.3;\n  this.wasTouched = false;\n}\nKeyTrackball.prototype = new Trackball();\nKeyTrackball.prototype.constructor = KeyTrackball;\n\n\nKeyTrackball.prototype.setAccel = function(a) {\n  this.accel = a;\n  return this;\n};\n\n/**\n * @param {Vec2d} out\n * @return {Vec2d} out\n */\nKeyTrackball.prototype.getVal = function(out) {\n  if (!this.wasTouched) {\n    this.val.reset();\n  } else if (this.needsValChange) {\n    this.needsValChange = false;\n    this.keyStick.getVal(out);\n    if (out.isZero() && this.isTouched()) {\n      // Opposite keys are touched. Slam the brakes.\n      this.val.scale(0.5);\n    } else {\n      this.val.scale(0.95).add(out.scale(this.accel));\n    }\n  }\n  this.wasTouched = this.isTouched();\n  return out.set(this.val);\n};\n\nKeyTrackball.prototype.reset = function() {\n  if (!this.isTouched()) {\n    this.val.scale(1 - this.friction);\n  }\n  this.needsValChange = true;\n};\n\nKeyTrackball.prototype.isTouched = function() {\n  var touched = this.keyStick.isAnyKeyPressed();\n  if (!touched) this.wasTouched = false;\n  return touched;\n};\n\nKeyTrackball.prototype.startListening = function() {\n  this.keyStick.startListening();\n};\n\nKeyTrackball.prototype.stopListening = function() {\n  this.keyStick.stopListening();\n};\n\n\n/* ---- js/controls/mousetrackball.js ---- */\n\n\n/**\n * A control trackball for a mouse or trackpad.\n * This is intended for use with pointerlock, but it does not handle pointer lock itself.\n * @constructor\n * @extends {Trackball}\n */\nfunction MouseTrackball(opt_elem) {\n  Trackball.call(this);\n\n  this.elem = opt_elem || document.body;\n  var self = this;\n  this.listening = false;\n  this.mouseMotion = new Vec2d();\n  this.touched = false;\n  this.speed = 0.05;\n  this.mouseMoveListener = function(e) {\n    self.onMouseMove(e);\n  };\n  this.mouseDownListener = function(e) {\n    self.onMouseDown(e);\n  };\n}\n\nMouseTrackball.prototype = new Trackball();\nMouseTrackball.prototype.constructor = MouseTrackball;\n\nMouseTrackball.prototype.startListening = function() {\n  this.elem.addEventListener('mousemove', this.mouseMoveListener);\n  this.elem.addEventListener('mousedown', this.mouseDownListener);\n  this.listening = true;\n  return this;\n};\n\nMouseTrackball.prototype.stopListening = function() {\n  this.elem.removeEventListener('mousemove', this.mouseMoveListener);\n  this.elem.removeEventListener('mousedown', this.mouseDownListener);\n  this.listening = false;\n  return this;\n};\n\nMouseTrackball.prototype.reset = function() {\n  if (!this.touched) {\n    this.val.scale(1 - this.friction);\n  }\n  this.mouseMotion.reset();\n  this.touched = false;\n};\n\nMouseTrackball.prototype.onMouseMove = function(e) {\n  var dx = e.movementX || e.mozMovementX || e.webkitMovementX || 0;\n  var dy = e.movementY || e.mozMovementY || e.webkitMovementY || 0;\n  this.mouseMotion.addXY(dx * this.speed, dy * this.speed);\n  this.val.set(this.mouseMotion);\n  this.touched = true;\n};\n\nMouseTrackball.prototype.onMouseDown = function(e) {\n  this.val.reset();\n  this.touched = true;\n};\n\n\n/* ---- js/controls/touchtrackball.js ---- */\n\n\n/**\n * A control trackball using a touchscreen.\n * @constructor\n * @extends {Trackball}\n */\nfunction TouchTrackball(opt_elem) {\n  Trackball.call(this);\n  this.elem = opt_elem || document.body;\n  this.oldPagePos = new Vec2d();\n  this.touched = false;\n\n  this.pixelMultiplier = 0.2;\n\n  this.dirtyVal = false;\n  this.startZoneFn = function(x, y) {\n    return true;\n  };\n\n  var self = this;\n\n  // When this is null, we're not tracking a touch.\n  this.touchId = null;\n\n  this.touchStartListener = function(e) {\n    self.onTouchStart(e);\n  };\n  this.touchMoveListener = function(e) {\n    self.onTouchMove(e);\n  };\n  this.touchEndListener = function(e) {\n    self.onTouchEnd(e);\n  };\n}\n\nTouchTrackball.prototype = new Trackball();\nTouchTrackball.prototype.constructor = TouchTrackball;\n\nTouchTrackball.prototype.setStartZoneFunction = function(fn) {\n  this.startZoneFn = fn;\n  return this;\n};\n\nTouchTrackball.prototype.startListening = function() {\n  this.elem.addEventListener('touchstart', this.touchStartListener);\n  this.elem.addEventListener('touchmove', this.touchMoveListener);\n  this.elem.addEventListener('touchend', this.touchEndListener);\n  this.elem.addEventListener('touchcancel', this.touchEndListener);\n  return this;\n};\n\nTouchTrackball.prototype.stopListening = function() {\n  this.elem.removeEventListener('touchstart', this.touchStartListener);\n  this.elem.removeEventListener('touchmove', this.touchMoveListener);\n  this.elem.removeEventListener('touchend', this.touchEndListener);\n  this.elem.removeEventListener('touchcancel', this.touchEndListener);\n  this.touchId = null;\n  return this;\n};\n\nTouchTrackball.prototype.onTouchStart = function(e) {\n  if (this.touchId !== null) return;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (this.startZoneFn(touch.pageX, touch.pageY)) {\n      // Start tracking this one.\n      this.touchId = touch.identifier;\n      this.val.reset();\n      this.oldPagePos.setXY(touch.pageX, touch.pageY);\n      this.touched = true;\n      break;\n    }\n  }\n};\n\nTouchTrackball.prototype.onTouchMove = function(e) {\n  if (this.touchId === null) return;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (touch.identifier == this.touchId) {\n      // Keep tracking this one.\n      if (this.dirtyVal) {\n        this.val.reset();\n        this.dirtyVal = false;\n      }\n      var velocity = Vec2d.alloc(touch.pageX - this.oldPagePos.x, touch.pageY - this.oldPagePos.y)\n          .scale(this.pixelMultiplier);\n      this.val.add(velocity);\n      this.oldPagePos.setXY(touch.pageX, touch.pageY);\n      break;\n    }\n  }\n};\n\nTouchTrackball.prototype.onTouchEnd = function(e) {\n  if (this.touchId === null) return;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (touch.identifier == this.touchId) {\n      this.touchId = null;\n      this.touched = false;\n      break;\n    }\n  }\n};\n\nTouchTrackball.prototype.reset = function() {\n  if (!this.touched) {\n    this.val.scale(1 - this.friction);\n  } else {\n    if (this.dirtyVal) {\n      // Touched, but there were no events in the last iteration.\n      // Tap the brakes.\n      this.val.scale(0.5);\n    }\n  }\n  this.dirtyVal = true;\n};\n\n\n/* ---- js/controls/multitrackball.js ---- */\n\n\n/**\n * A control trackball that combines other trackball inputs into one.\n * @constructor\n * @extends {Trackball}\n */\nfunction MultiTrackball() {\n  Trackball.call(this);\n  this.trackballs = [];\n  this.temp = new Vec2d();\n}\nMultiTrackball.prototype = new Trackball();\nMultiTrackball.prototype.constructor = MultiTrackball;\n\nMultiTrackball.prototype.addTrackball = function(t) {\n  this.trackballs.push(t);\n  return this;\n};\n\nMultiTrackball.prototype.startListening = function() {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].startListening();\n  }\n};\n\nMultiTrackball.prototype.stopListening = function() {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].stopListening();\n  }\n};\n\nMultiTrackball.prototype.setFriction = function(f) {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].setFriction(f);\n  }\n  return this;\n};\n\nMultiTrackball.prototype.getVal = function(out) {\n  this.val.reset();\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].getVal(this.temp);\n    this.val.add(this.temp);\n  }\n  return out.set(this.val);\n};\n\nMultiTrackball.prototype.reset = function() {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    this.trackballs[i].reset();\n  }\n};\n\nMultiTrackball.prototype.isTouched = function() {\n  for (var i = 0; i < this.trackballs.length; i++) {\n    if (this.trackballs[i].isTouched()) return true;\n  }\n  return false;\n};\n\n\n/* ---- js/controls/trigger.js ---- */\n\n\n/**\n * Control trigger base class\n * @constructor\n */\nfunction Trigger() {\n  this.val = false;\n  this.downPubSub = new PubSub();\n  this.upPubSub = new PubSub();\n}\n\n/**\n * @return {boolean}\n */\nTrigger.prototype.getVal = function() {\n  return this.val;\n};\n\nTrigger.prototype.startListening = function() {console.log(\"startListening unimplimented\")};\nTrigger.prototype.stopListening = function() {console.log(\"stopListening unimplimented\")};\n\n\nTrigger.prototype.addTriggerDownListener = function(fn) {\n  this.downPubSub.subscribe(fn);\n};\n\nTrigger.prototype.removeTriggerDownListener = function(fn) {\n  this.downPubSub.unsubscribe(fn);\n};\n\n\nTrigger.prototype.addTriggerUpListener = function(fn) {\n  this.upPubSub.subscribe(fn);\n};\nTrigger.prototype.removeTriggerUpListener = function(fn) {\n  this.upPubSub.unsubscribe(fn);\n};\n\n\nTrigger.prototype.publishTriggerDown = function(e) {\n  this.downPubSub.publish(e);\n};\n\nTrigger.prototype.publishTriggerUp = function(e) {\n  this.upPubSub.publish(e);\n};\n\n\n/* ---- js/controls/keytrigger.js ---- */\n\n\n/**\n * A single control Trigger, using keyboard keys.\n * @constructor\n * @extends {Trigger}\n */\nfunction KeyTrigger() {\n  Trigger.call(this);\n\n  this.keys = new Keys();\n  this.triggerKeyCodes = {};\n  this.codeToState = {};\n\n  var self = this;\n  this.downListener = function(e) {\n    if (!e) e = window.event;\n    if (self.triggerKeyCodes[e.keyCode]) {\n      var oldVal = self.getVal();\n      self.codeToState[e.keyCode] = true;\n      if (!oldVal) self.publishTriggerDown(e);\n    }\n  };\n  this.upListener = function(e) {\n    if (!e) e = window.event;\n    if (self.triggerKeyCodes[e.keyCode]) {\n      var oldVal = self.getVal();\n      self.codeToState[e.keyCode] = false;\n      if (oldVal && !self.getVal()) self.publishTriggerUp(e);\n    }\n  };\n}\n\nKeyTrigger.prototype = new Trigger();\nKeyTrigger.prototype.constructor = KeyTrigger;\n\nKeyTrigger.prototype.addTriggerKeyByCode = function(keyCode) {\n  this.triggerKeyCodes[keyCode] = true;\n  return this;\n};\n\nKeyTrigger.prototype.addTriggerKeyByName = function(name) {\n  var keyCode = this.keys.getKeyCodeForName(name);\n  return this.addTriggerKeyByCode(keyCode);\n};\n\nKeyTrigger.prototype.startListening = function() {\n  document.addEventListener('keydown', this.downListener);\n  document.addEventListener('keyup', this.upListener);\n  return this;\n};\n\nKeyTrigger.prototype.stopListening = function() {\n  document.removeEventListener('keydown', this.downListener);\n  document.removeEventListener('keyup', this.upListener);\n  for (var code in this.codeToState) {\n    this.codeToState[code] = false;\n  }\n  return this;\n};\n\nKeyTrigger.prototype.getVal = function() {\n  for (var code in this.codeToState) {\n    if (this.codeToState[code]) return true;\n  }\n};\n\n\n/* ---- js/controls/mousebuttontrigger.js ---- */\n\n\n/**\n * A single control Trigger, using the left mouse button.\n * @constructor\n * @extends {Trigger}\n */\nfunction MouseButtonTrigger(elem) {\n  Trigger.call(this);\n  this.elem = elem || document;\n  var self = this;\n  this.downListener = function(e) {\n    if (!e) e = window.event;\n    if (MouseButtonTrigger.isLeftButton(e)) {\n      self.val = true;\n      self.publishTriggerDown(e);\n\n      // For LayeredEventDistributor\n      return false;\n    }\n  };\n  this.upListener = function(e) {\n    if (!e) e = window.event;\n    if (MouseButtonTrigger.isLeftButton(e)) {\n      self.val = false;\n      self.publishTriggerUp(e);\n\n      // For LayeredEventDistributor\n      return false;\n    }\n  };\n}\n\nMouseButtonTrigger.prototype = new Trigger();\nMouseButtonTrigger.prototype.constructor = MouseButtonTrigger;\n\nMouseButtonTrigger.isLeftButton = function(e) {\n  if (e.buttons) {\n    return !!(e.buttons & 1);\n  } else if ((typeof e.button) != 'undefined') {\n    return e.button == 0;\n  } else {\n    return e.which == 1;\n  }\n};\n\nMouseButtonTrigger.prototype.startListening = function() {\n  this.elem.addEventListener('mousedown', this.downListener);\n  this.elem.addEventListener('mouseup', this.upListener);\n  return this;\n};\n\nMouseButtonTrigger.prototype.stopListening = function() {\n  this.elem.removeEventListener('mousedown', this.downListener);\n  this.elem.removeEventListener('mouseup', this.upListener);\n  this.val = false;\n  return this;\n};\n\nMouseButtonTrigger.prototype.getVal = function() {\n  return this.val;\n};\n\n\n/* ---- js/controls/touchtrigger.js ---- */\n\n\n/**\n * A control Trigger using a touchscreen.\n * @constructor\n * @extends {Trigger}\n */\nfunction TouchTrigger(opt_elem) {\n  Trigger.call(this);\n  this.listening = false;\n  this.elem = opt_elem || document.body;\n\n  this.startZoneFn = function(x, y) {\n    return true;\n  };\n  this.touchId = null;\n\n  var self = this;\n  this.touchStartListener = function(e) {\n    return self.onTouchStart(e);\n  };\n  this.touchEndListener = function(e) {\n    return self.onTouchEnd(e);\n  };\n}\n\nTouchTrigger.prototype = new Trigger();\nTouchTrigger.prototype.constructor = TouchTrigger;\n\n/**\n * @param {function} fn  A function that takes screen coords (x, y) and returns true if the coords are\n * within the touch trigger start zone.\n * @returns {TouchTrigger}\n */\nTouchTrigger.prototype.setStartZoneFunction = function(fn) {\n  this.startZoneFn = fn;\n  return this;\n};\n\nTouchTrigger.prototype.startListening = function() {\n  this.elem.addEventListener('touchstart', this.touchStartListener);\n  this.elem.addEventListener('touchend', this.touchEndListener);\n  this.elem.addEventListener('touchcancel', this.touchEndListener);\n  return this;\n};\n\nTouchTrigger.prototype.stopListening = function() {\n  this.elem.removeEventListener('touchstart', this.touchStartListener);\n  this.elem.removeEventListener('touchend', this.touchEndListener);\n  this.elem.removeEventListener('touchcancel', this.touchEndListener);\n  this.touchId = null;\n  this.val = false;\n  return this;\n};\n\nTouchTrigger.prototype.onTouchStart = function(e) {\n  if (this.touchId !== null) return;\n  e = e || window.event;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (this.startZoneFn(touch.pageX, touch.pageY)) {\n      // Start tracking this one.\n      this.touchId = touch.identifier;\n      this.val = true;\n      this.publishTriggerDown(e);\n\n      // For LayeredEventDistributor\n      return false;\n    }\n  }\n};\n\nTouchTrigger.prototype.onTouchEnd = function(e) {\n  if (this.touchId === null) return;\n  e = e || window.event;\n  var touches = e.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    if (touch.identifier == this.touchId) {\n      this.touchId = null;\n      this.val = false;\n      this.publishTriggerUp(e);\n\n      // Never claim to have handled a touchEnd, because touch events contain multiple\n      // touches, and if a trigger touch and a world touch end at the same time, then\n      // the LayeredEventDistributor will refuse to tell the world touch about the end.\n      return true;\n    }\n  }\n};\n\n\n/* ---- js/controls/touchtrigger.js ---- */\n\n\n/**\n * A round control Trigger using a touchscreen.\n * Use setCanvas() and setXYR() to set it up, then just read its value.\n *\n * @deprecated Use TriggerWidget instead\n *\n * @constructor\n * @extends {TouchTrigger}\n */\nfunction RoundTouchTrigger(canvas) {\n  TouchTrigger.call(this, canvas);\n\n  this.px = 0.5;\n  this.py = 0.5;\n  this.rx = 0.05;\n  this.ry = 0.05;\n  this.canvas = canvas;\n\n  var self = this;\n  this.setStartZoneFunction(function(x, y) {\n    if (self.canvas == null) return false;\n    return Vec2d.distance(x, y, self.getX(), self.getY()) <= self.getRad();\n  });\n}\n\nRoundTouchTrigger.prototype = new TouchTrigger();\nRoundTouchTrigger.prototype.constructor = RoundTouchTrigger;\n\n/**\n * @param xFraction a fraction (0-1) of the canvas width\n * @param yFraction  a fraction (0-1) of the canvas height\n */\nRoundTouchTrigger.prototype.setPosFractionXY = function(xFraction, yFraction) {\n  this.px = xFraction;\n  this.py = yFraction;\n  return this;\n};\n\n/**\n * The radius of the button is the xFraction * canvas.width + yFraction * canvas.height\n * @param xFraction a fraction (0-1) of the canvas width\n * @param yFraction a fraction (0-1) of the canvas height\n */\nRoundTouchTrigger.prototype.setRadCoefsXY = function(xFraction, yFraction) {\n  this.rx = xFraction;\n  this.ry = yFraction;\n  return this;\n};\n\nRoundTouchTrigger.prototype.getX = function() {\n  return this.px * this.canvas.width;\n};\n\nRoundTouchTrigger.prototype.getY = function() {\n  return this.py * this.canvas.height;\n};\n\nRoundTouchTrigger.prototype.getRad = function() {\n  return this.rx * this.canvas.width + this.ry * this.canvas.height;\n};\n\n\n/* ---- js/controls/multitrigger.js ---- */\n\n\n/**\n * A control trigger that combines other trigger inputs into one.\n * @constructor\n * @extends {Trigger}\n */\nfunction MultiTrigger() {\n  Trigger.call(this);\n  this.triggers = [];\n  this.oldVal = false;\n\n  var self = this;\n  this.downListener = function(e) {\n    if (!self.oldVal && self.getVal()) {\n      self.publishTriggerDown(e);\n      self.oldVal = true;\n    }\n  };\n  this.upListener = function(e) {\n    if (self.oldVal && !self.getVal()) {\n      self.publishTriggerUp(e);\n      self.oldVal = false;\n    }\n  };\n}\nMultiTrigger.prototype = new Trigger();\nMultiTrigger.prototype.constructor = MultiTrigger;\n\nMultiTrigger.prototype.addTrigger = function(t) {\n  this.triggers.push(t);\n  t.addTriggerDownListener(this.downListener);\n  t.addTriggerUpListener(this.upListener);\n  return this;\n};\n\nMultiTrigger.prototype.startListening = function() {\n  for (var i = 0; i < this.triggers.length; i++) {\n    this.triggers[i].startListening();\n  }\n};\n\nMultiTrigger.prototype.stopListening = function() {\n  for (var i = 0; i < this.triggers.length; i++) {\n    this.triggers[i].stopListening();\n  }\n};\n\nMultiTrigger.prototype.getVal = function() {\n  for (var i = 0; i < this.triggers.length; i++) {\n    if (this.triggers[i].getVal()) return true;\n  }\n  return false;\n};\n\nMultiTrigger.prototype.addTriggerDownListener = function(fn) {\n  this.downPubSub.subscribe(fn);\n};\n\nMultiTrigger.prototype.removeTriggerDownListener = function(fn) {\n  this.downPubSub.unsubscribe(fn);\n};\n\n\nMultiTrigger.prototype.addTriggerUpListener = function(fn) {\n  this.upPubSub.subscribe(fn);\n};\nMultiTrigger.prototype.removeTriggerUpListener = function(fn) {\n  this.upPubSub.unsubscribe(fn);\n};\n\n\nMultiTrigger.prototype.publishTriggerDown = function(e) {\n  this.downPubSub.publish(e);\n};\n\nMultiTrigger.prototype.publishTriggerUp = function(e) {\n  this.upPubSub.publish(e);\n};\n\n\n\n/* ---- js/widgets/triggerwidget.js ---- */\n\n\n\n/**\n * A visible on-screen trigger that can handle touch, mouse buttons, and keyboard keys.\n * @constructor\n */\nfunction TriggerWidget(elem) {\n  this.elem = elem;\n\n  this.modelMatrix = new Matrix44();\n  this.mat44 = new Matrix44();\n\n  this.trigger = new MultiTrigger();\n  this.touchTrigger = null;\n  this.mousePointerTrigger = null;\n  this.stamp = null;\n\n  this.pressedColorVec4 = new Vec4().setXYZ(0.8, 0.8, 0.8);\n  this.releasedColorVec4 = new Vec4().setXYZ(0.5, 0.5, 0.5);\n\n  this.canvasPos = new Vec2d(0, 0);\n  this.canvasScale = new Vec2d(1, 1);\n\n  this.keyboardTipModelMatrix = new Matrix44();\n  this.keyboardTipOffset = new Vec2d(0, 0);\n  this.keyboardTipScale = new Vec2d(1, 1);\n  this.keyboardTipStamp = null;\n  this.keyboardTipColorVec4 = new Vec4().setRGBA(0.5, 0.5, 0.5, 0.5);\n\n  // Time at which the keyboard tip will stop being rendered\n  this.keyboardTipUntilTimeMs = -Infinity;\n\n  this.updateModelMatrix();\n}\n\nTriggerWidget.prototype.addTriggerKeyByName = function(keyName) {\n  this.trigger.addTrigger((new KeyTrigger()).addTriggerKeyByName(keyName));\n  return this;\n};\n\nTriggerWidget.prototype.listenToMouseButton = function() {\n  this.trigger.addTrigger(new MouseButtonTrigger(this.elem));\n  return this;\n};\n\nTriggerWidget.prototype.listenToTouch = function() {\n  if (!this.touchTrigger) {\n    this.touchTrigger = new TouchTrigger(this.elem).startListening();\n    this.trigger.addTrigger(this.touchTrigger);\n    this.updateStartZone();\n  }\n  return this;\n};\n\nTriggerWidget.prototype.listenToMousePointer = function() {\n  if (!this.mousePointerTrigger) {\n    this.mousePointerTrigger = new MousePointerTrigger(this.elem).startListening();\n    this.trigger.addTrigger(this.mousePointerTrigger);\n    this.updateStartZone();\n  }\n  return this;\n};\n\nTriggerWidget.prototype.setStamp = function(stamp) {\n  this.stamp = stamp;\n  return this;\n};\n\nTriggerWidget.prototype.setKeyboardTipStamp = function(stamp) {\n  this.keyboardTipStamp = stamp;\n  return this;\n};\n\nTriggerWidget.prototype.setPressedColorVec4 = function(vec4) {\n  this.pressedColorVec4.set(vec4);\n  return this;\n};\n\nTriggerWidget.prototype.setReleasedColorVec4 = function(vec4) {\n  this.releasedColorVec4.set(vec4);\n  return this;\n};\n\nTriggerWidget.prototype.setCanvasPositionXY = function(x, y) {\n  this.canvasPos.setXY(x, y);\n  this.updateStartZone();\n  this.updateModelMatrix();\n  return this;\n};\n\nTriggerWidget.prototype.setCanvasScaleXY = function(x, y) {\n  this.canvasScale.setXY(x, y);\n  this.updateStartZone();\n  this.updateModelMatrix();\n  return this;\n};\n\nTriggerWidget.prototype.setKeyboardTipOffsetXY = function(x, y) {\n  this.keyboardTipOffset.setXY(x, y);\n  this.updateModelMatrix();\n  return this;\n};\n\nTriggerWidget.prototype.setKeyboardTipScaleXY = function(x, y) {\n  this.keyboardTipScale.setXY(x, y);\n  this.updateModelMatrix();\n  return this;\n};\n\nTriggerWidget.prototype.setKeyboardTipColorVec4 = function(vec4) {\n  this.keyboardTipColorVec4.set(vec4);\n  return this;\n};\n\n/**\n * Sets the absolute time, in ms, at which the keyboard tip will stop being rendered.\n * @param {Number} timeMs\n */\nTriggerWidget.prototype.setKeyboardTipTimeoutMs = function(timeMs) {\n  this.keyboardTipUntilTimeMs = timeMs;\n  return this;\n};\n\nTriggerWidget.prototype.startListening = function() {\n  this.trigger.startListening();\n  return this;\n};\n\nTriggerWidget.prototype.stopListening = function() {\n  this.trigger.stopListening();\n  return this;\n};\n\nTriggerWidget.prototype.getVal = function() {\n  return this.trigger.getVal();\n};\n\nTriggerWidget.prototype.addTriggerDownListener = function(fn) {\n  this.trigger.addTriggerDownListener(fn);\n  return this;\n};\n\nTriggerWidget.prototype.removeTriggerDownListener = function(fn) {\n  this.trigger.removeTriggerDownListener(fn);\n  return this;\n};\n\nTriggerWidget.prototype.addTriggerUpListener = function(fn) {\n  this.trigger.addTriggerUpListener(fn);\n  return this;\n};\n\nTriggerWidget.prototype.removeTriggerUpListener = function(fn) {\n  this.trigger.removeTriggerUpListener(fn);\n  return this;\n};\n\nTriggerWidget.prototype.draw = function(renderer) {\n  if (this.stamp) {\n    renderer\n        .setColorVector(this.getVal() ? this.pressedColorVec4 : this.releasedColorVec4)\n        .setStamp(this.stamp)\n        .setModelMatrix(this.modelMatrix)\n        .drawStamp();\n  }\n  if (this.keyboardTipStamp && Date.now() < this.keyboardTipUntilTimeMs) {\n    renderer\n        .setColorVector(this.keyboardTipColorVec4)\n        .setStamp(this.keyboardTipStamp)\n        .setModelMatrix(this.keyboardTipModelMatrix)\n        .drawStamp();\n  }\n  return this;\n};\n\nTriggerWidget.prototype.isMouseHovered = function() {\n  return this.mousePointerTrigger && this.mousePointerTrigger.hovered;\n};\n\nTriggerWidget.prototype.updateStartZone = function() {\n  var self = this;\n  if (this.touchTrigger) {\n    this.touchTrigger.setStartZoneFunction(function (x, y) {\n      return Math.abs(x - self.canvasPos.x) <= Math.abs(self.canvasScale.x) &&\n          Math.abs(y - self.canvasPos.y) <= Math.abs(self.canvasScale.y);\n    });\n  }\n  if (this.mousePointerTrigger) {\n    this.mousePointerTrigger.setStartZoneFunction(function (x, y) {\n      return Math.abs(x - self.canvasPos.x) <= Math.abs(self.canvasScale.x) &&\n          Math.abs(y - self.canvasPos.y) <= Math.abs(self.canvasScale.y);\n    });\n  }\n  return this;\n};\n\nTriggerWidget.prototype.updateModelMatrix = function() {\n  this.modelMatrix.toTranslateOpXYZ(this.canvasPos.x, this.canvasPos.y, -0.99)\n      .multiply(this.mat44.toScaleOpXYZ(this.canvasScale.x, this.canvasScale.y, 1));\n  this.keyboardTipModelMatrix.toTranslateOpXYZ(\n      this.canvasPos.x + this.keyboardTipOffset.x,\n      this.canvasPos.y + this.keyboardTipOffset.y,\n      -0.99)\n      .multiply(this.mat44.toScaleOpXYZ(this.keyboardTipScale.x, this.keyboardTipScale.y, 0.01));\n  return this;\n};\n\n\n\n/* ---- js/widgets/modemenuwidget.js ---- */\n\n\n\n/**\n * An on-scren menu grid that supports touch, the mouse pointer, and keyboard keys.\n * Items are organized into an ordered list of groups, and within each group they are ordered by rank.\n * @param {Element} elem  DOM element to listen to\n * @param {Glyphs} glyphs from which to draw keyboard shortcut models\n * @constructor\n */\nfunction ModeMenuWidget(elem, glyphs) {\n  this.elem = elem;\n  this.glyphs = glyphs;\n\n  // Array of rank-arrays of items.\n  this.groups = [];\n\n  this.mat44 = new Matrix44();\n\n  // for interpreting keypresses.\n  this.keyNameToGroup = {};\n\n  // for drawing keyboard shortcuts\n  this.groupNumToKeyStamp = [];\n\n  this.matrixesValid = false;\n  this.stampsValid = false;\n\n  // single stamp for the entire set of items\n  this.menuStamp = null;\n  this.menuMatrix = new Matrix44();\n  this.menuColor = new Vec4(1, 1, 1, 0.5);\n\n  // selection indicator, like a box around the selection\n  this.indicatorStamp = null;\n  this.indicatorMatrix = new Matrix44();\n  this.indicatorColor = new Vec4(1, 1, 1, 0.6);\n\n  // keyboard tips, for people who like that sort of thing\n  this.keyTipsStamp = null;\n  this.keyTipsMatrix = new Matrix44();\n  this.keyTipsColor = new Vec4(1, 1, 1, 0.5);\n\n  // center of the group-0, rank-0 item\n  this.menuPos = new Vec2d(0, 0);\n\n  this.itemPosMatrix = new Matrix44();\n  this.inverseItemPosMatrix = new Matrix44();\n\n  // How to map from page coords to (group, rank) coords.\n  this.pageToItemMatrix = new Matrix44();\n\n  // scale to apply to individual items\n  this.itemScale = new Vec2d(1, -1);\n\n  // scale to apply to keyboard tips\n  this.keyTipsScale = new Vec2d(0.5, -0.5);\n\n  // scale to apply to keyboard tips\n  this.keyTipsOffset = new Vec2d(0, -1);\n\n  // time after which the keyboard tips will stop being rendered\n  this.keyTipsUntilTimeMs = -Infinity;\n\n  // what is selected?\n  this.selectedGroup = 0;\n  this.selectedRank = 0;\n\n  this.keys = new Keys();\n\n  var self = this;\n  this.keyDownListener = function(e) {\n    if (!e) e = window.event;\n    var keyName = self.keys.getNameForKeyCode(e.keyCode);\n    if (keyName in self.keyNameToGroup) {\n      var newGroup = self.keyNameToGroup[keyName];\n      var newRank = self.selectedRank;\n      if (newGroup == self.selectedGroup) {\n        // advance rank\n        newRank = (newRank + 1) % self.groups[newGroup].length;\n      } else {\n        newRank = 0;\n      }\n      self.setSelectedGroupAndRank(newGroup, newRank);\n    }\n  };\n  this.touchStartListener = function(e) {\n    if (!e) e = window.event;\n    var touches = e.changedTouches;\n    for (var i = 0; i < touches.length; i++) {\n      var touch = touches[i];\n      if (self.maybeSelectPageXY(touch.pageX, touch.pageY)) {\n        // for layer thing\n        return false;\n      }\n    }\n  };\n  this.mouseDownListener = function(e) {\n    if (!e) e = window.event;\n    if (self.maybeSelectPageXY(e.clientX, e.clientY)) {\n      // for layer thing\n      return false;\n    }\n  };\n}\n\n////////////\n// Public //\n////////////\n\nModeMenuWidget.prototype.setItem = function(group, rank, name, model) {\n  if (!this.groups[group]) this.groups[group] = [];\n  this.groups[group][rank] = {\n    name: name,\n    model: model\n  };\n  return this;\n};\n\nModeMenuWidget.prototype.addKeyboardShortcut = function(groupNum, keyName) {\n  this.keyNameToGroup[keyName] = groupNum;\n  return this;\n};\n\n/**\n * Sets the absolute time, in ms, at which the keyboard tip will stop being rendered.\n * @param {Number} timeMs\n */\nModeMenuWidget.prototype.setKeyboardTipTimeoutMs = function(timeMs) {\n  this.keyTipsUntilTimeMs = timeMs;\n  return this;\n};\n\n/**\n * Set the position of the zero-group, zero-rank item\n * @param {Vec2d} pos\n * @returns {ModeMenuWidget}\n */\nModeMenuWidget.prototype.setPosition = function(pos) {\n  if (!this.menuPos.equals(pos)) {\n    this.menuPos.set(pos);\n    this.invalidateMatrixes();\n  }\n  return this;\n};\n\n/**\n * Sets the matrix for transforming an item <group. rank> to a\n * screen-offset for the center of that item, relative to the menu position.\n * This is also used to calculate the selection-indicator position.\n * @param {Matrix44} m\n * @returns {ModeMenuWidget}\n */\nModeMenuWidget.prototype.setItemPositionMatrix = function(m) {\n  if (!this.itemPosMatrix.equals(m)) {\n    this.itemPosMatrix.set(m);\n    this.itemPosMatrix.getInverse(this.inverseItemPosMatrix);\n    this.invalidateStamps();\n    this.invalidateMatrixes();\n  }\n  return this;\n};\n\n/**\n * Used to help draw an item stamp, after the item position has been computed.\n * @param {Vec2d} scale\n * @returns {ModeMenuWidget}\n */\nModeMenuWidget.prototype.setItemScale = function(scale) {\n  if (!this.itemScale.equals(scale)) {\n    this.itemScale.set(scale);\n    this.invalidateStamps();\n  }\n  return this;\n};\n\n/**\n * Stamp for the selection indicator.\n * @param {ModelStamp} stamp\n * @returns {ModeMenuWidget}\n */\nModeMenuWidget.prototype.setIndicatorStamp = function(stamp) {\n  this.indicatorStamp = stamp;\n  return this;\n};\n\nModeMenuWidget.prototype.startListening = function() {\n  document.addEventListener('keydown', this.keyDownListener);\n  this.elem.addEventListener('touchstart', this.touchStartListener);\n  this.elem.addEventListener('mousedown', this.mouseDownListener);\n  return this;\n};\n\nModeMenuWidget.prototype.stopListening = function() {\n  document.removeEventListener('keydown', this.keyDownListener);\n  this.elem.removeEventListener('touchstart', this.touchStartListener);\n  this.elem.removeEventListener('mousedown', this.mouseDownListener);\n  return this;\n};\n\nModeMenuWidget.prototype.draw = function(renderer) {\n  this.validateStamps(renderer.gl);\n  this.validateMatrixes();\n\n  if (this.menuStamp) {\n    renderer\n        .setColorVector(this.menuColor)\n        .setStamp(this.menuStamp)\n        .setModelMatrix(this.menuMatrix)\n        .drawStamp();\n  }\n  if (this.indicatorStamp && this.getSelectedName()) {\n    renderer\n        .setColorVector(this.indicatorColor)\n        .setStamp(this.indicatorStamp)\n        .setModelMatrix(this.indicatorMatrix)\n        .drawStamp();\n  }\n  if (Date.now() < this.keyTipsUntilTimeMs && this.keyTipsStamp) {\n    renderer\n        .setColorVector(this.keyTipsColor)\n        .setStamp(this.keyTipsStamp)\n        .setModelMatrix(this.keyTipsMatrix)\n        .drawStamp();\n  }\n  return this;\n};\n\nModeMenuWidget.prototype.getSelectedName = function() {\n  var g = this.groups[this.selectedGroup];\n  var r = g && g[this.selectedRank];\n  return r && r.name;\n};\n\n/////////////\n// Private //\n/////////////\n\nModeMenuWidget.prototype.invalidateMatrixes = function() {\n  this.matrixesValid = false;\n};\n\nModeMenuWidget.prototype.invalidateStamps = function() {\n  this.stampsValid = false;\n  // indicator stamp is unaffected\n};\n\nModeMenuWidget.prototype.validateStamps = function(gl) {\n  if (!this.stampsValid) {\n    if (this.menuStamp) {\n      this.menuStamp.dispose(gl);\n    }\n    this.menuStamp = null;\n\n    if (this.keyTipsStamp) {\n      this.keyTipsStamp.dispose(gl);\n    }\n    this.keyTipsStamp = null;\n  }\n  if (!this.menuStamp) {\n    var menuModel = new RigidModel();\n    var itemOffset = Vec4.alloc();\n    for (var g = 0; g < this.groups.length; g++) {\n      var group = this.groups[g];\n      for (var r = 0; r < group.length; r++) {\n        var item = group[r];\n        this.getItemOffset(g, r, itemOffset);\n        var itemModel = new RigidModel()\n            .addRigidModel(item.model)\n            .transformPositions(this.mat44.toScaleOpXYZ(this.itemScale.x, this.itemScale.y, 1))\n            .transformPositions(this.mat44.toTranslateOpXYZ(itemOffset.getX(), itemOffset.getY(), 0));\n        menuModel.addRigidModel(itemModel);\n      }\n    }\n    itemOffset.free();\n    this.menuStamp = menuModel.createModelStamp(gl);\n  }\n\n  if (!this.keyTipsStamp) {\n    // TODO key tip stamp\n  }\n  this.stampsValid = true;\n};\n\nModeMenuWidget.prototype.validateMatrixes = function() {\n  if (this.matrixesValid) return;\n  this.menuMatrix.toTranslateOpXYZ(this.menuPos.x, this.menuPos.y, -0.9);\n  var indicatorOffset = this.getItemOffset(this.selectedGroup, this.selectedRank, Vec4.alloc());\n  this.indicatorMatrix.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(\n          this.menuPos.x + indicatorOffset.getX(),\n          this.menuPos.y + indicatorOffset.getY(),\n          -0.9))\n      .multiply(this.mat44.toScaleOpXYZ(this.itemScale.x, this.itemScale.y, 1));\n  this.matrixesValid = true;\n  indicatorOffset.free();\n};\n\nModeMenuWidget.prototype.getItemOffset = function(group, rank, vec4Out) {\n  vec4Out.setXYZ(group, rank, 0);\n  vec4Out.transform(this.itemPosMatrix);\n  return vec4Out;\n};\n\nModeMenuWidget.prototype.maybeSelectPageXY = function(pageX, pageY) {\n  var selected = false;\n  var pos = Vec4.alloc().setXYZ(pageX - this.menuPos.x, pageY - this.menuPos.y, 0);\n  pos.transform(this.inverseItemPosMatrix);\n  var group = Math.round(pos.getX());\n  var rank = Math.round(pos.getY());\n  if (this.groups[group] && this.groups[group][rank]) {\n    this.setSelectedGroupAndRank(group, rank);\n    selected = true;\n  }\n  pos.free();\n  return selected;\n};\n\nModeMenuWidget.prototype.setSelectedGroupAndRank = function(group, rank) {\n  if (this.selectedGroup != group || this.selectedRank != rank) {\n    this.selectedGroup = group;\n    this.selectedRank = rank;\n    this.invalidateMatrixes();\n  }\n};\n \n\n\n/* ---- js/widgets/layeredeventdistributor.js ---- */\n\n\n\n/**\n * Listens for mouse and touch events on a canvas, and distributes them\n * to one layer of listeners at a time, in layer order.\n * If any listener in a layer reports that the event was handled, by returning \"false\",\n * then that event will not be distributed to the next layer.\n * @param canvas\n * @param layerCount\n * @constructor\n */\nfunction LayeredEventDistributor(canvas, layerCount) {\n  this.canvas = canvas;\n  this.layerCount = layerCount;\n\n  this.layers = [];\n  for (var i = 0; i < layerCount; i++) {\n    // Each layer is a map from event name to an ArraySet of listeners.\n    this.layers[i] = this.createLayer(i);\n  }\n\n  this.listening = false;\n\n  this.canvasListeners = {};\n  for (var i = 0; i < LayeredEventDistributor.EVENT_NAMES.length; i++) {\n    var name = LayeredEventDistributor.EVENT_NAMES[i];\n    this.canvasListeners[name] = this.createListenerFn(name);\n  }\n}\n\nLayeredEventDistributor.EVENT_NAMES = [\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'touchcancel',\n  'mousedown',\n  'mousemove',\n  'mouseup'\n];\n\nLayeredEventDistributor.prototype.startListening = function() {\n  if (this.listening) return;\n  for (var i = 0; i < LayeredEventDistributor.EVENT_NAMES.length; i++) {\n    var name = LayeredEventDistributor.EVENT_NAMES[i];\n    Events.addListener(this.canvas, name, this.canvasListeners[name]);\n  }\n  this.listening = true;\n};\n\nLayeredEventDistributor.prototype.stopListening = function() {\n  if (!this.listening) return;\n  for (var i = 0; i < LayeredEventDistributor.EVENT_NAMES.length; i++) {\n    var name = LayeredEventDistributor.EVENT_NAMES[i];\n    Events.removeListener(this.canvas, name, this.canvasListeners[name]);\n  }\n  this.listening = false;\n};\n\nLayeredEventDistributor.prototype.addEventListenerToLayer = function(eventName, listenerFn, layerNum) {\n  var layer = this.layers[layerNum];\n  if (!layer[eventName]) {\n    layer[eventName] = new ArraySet();\n  }\n  layer[eventName].put(listenerFn);\n};\n\nLayeredEventDistributor.prototype.removeEventListenerFromLayer = function(eventName, listenerFn, layerNum) {\n  var layer = this.layers[layerNum];\n  if (layer[eventName]) {\n    layer[eventName].remove(listenerFn);\n  }\n};\n\nLayeredEventDistributor.prototype.getFakeLayerElement = function(layerNum) {\n  return this.layers[layerNum];\n};\n\n/**\n * Iterates through every layer, calling all the\n * @param name\n * @param e\n */\nLayeredEventDistributor.prototype.handleEvent = function(name, e) {\n  var stop = false;\n  for (var layerNum = 0; !stop && layerNum < this.layerCount; layerNum++) {\n    var layer = this.layers[layerNum];\n    var listeners = layer[name];\n    if (listeners) {\n      for (var i = 0; i < listeners.vals.length; i++) {\n        var fn = listeners.vals[i];\n        // Call the function using the canvas element as the \"this\".\n        var result = fn.call(this.canvas, e);\n        if (result === false) {\n          // The handler returned false, so don't distribute the event to any more layers\n          // (but finish this layer).\n          stop = true;\n        }\n      }\n    }\n  }\n};\n\nLayeredEventDistributor.prototype.createLayer = function(num) {\n  var layer = {};\n  var self = this;\n  layer.addEventListener = function(type, listener) {\n    self.addEventListenerToLayer(type, listener, num);\n  };\n  layer.removeEventListener = function(type, listener) {\n    self.removeEventListenerFromLayer(type, listener, num);\n  };\n  return layer;\n};\n\nLayeredEventDistributor.prototype.createListenerFn = function(name) {\n  var self = this;\n  return function(e) {\n    self.handleEvent(name, e);\n  };\n};\n\n\n/* ---- js/editor/editor.js ---- */\n\n\n\n/**\n * Owns the editor's cursor and edit-related triggers, cursor, and camera.\n * Hosted by a Screen that owns the world\n * @constructor\n */\nfunction Editor(host, canvas, renderer, glyphs) {\n  this.host = host;\n  this.canvas = canvas;\n  this.renderer = renderer;\n  this.glyphs = glyphs;\n  this.getStamps();\n\n  this.releasedColorVec4 = new Vec4(1, 1, 1, 0.5);\n  this.pressedColorVec4 = new Vec4(1, 1, 1, 0.9);\n\n  this.addTriggerWidget = new TriggerWidget(this.host.getHudEventTarget())\n      .setReleasedColorVec4(this.releasedColorVec4)\n      .setPressedColorVec4(this.pressedColorVec4)\n      .setStamp(this.addTriggerStamp)\n      .listenToTouch()\n      .addTriggerKeyByName('e')\n      .setKeyboardTipStamp(glyphs.stamps['E'])\n      .startListening();\n\n  this.removeTriggerWidget = new TriggerWidget(this.host.getHudEventTarget())\n      .setReleasedColorVec4(this.releasedColorVec4)\n      .setPressedColorVec4(this.pressedColorVec4)\n      .setStamp(this.removeTriggerStamp)\n      .listenToTouch()\n      .addTriggerKeyByName('q')\n      .setKeyboardTipStamp(glyphs.stamps['Q'])\n      .startListening();\n\n  this.gripTriggerWidget = new TriggerWidget(this.host.getHudEventTarget())\n      .setReleasedColorVec4(this.releasedColorVec4)\n      .setPressedColorVec4(this.pressedColorVec4)\n      .setStamp(this.gripTriggerStamp)\n      .listenToTouch()\n      .addTriggerKeyByName('d')\n      .setKeyboardTipStamp(glyphs.stamps['D'])\n      .startListening();\n\n  this.digTriggerWidget = new TriggerWidget(this.host.getHudEventTarget())\n      .setReleasedColorVec4(this.releasedColorVec4)\n      .setPressedColorVec4(this.pressedColorVec4)\n      .setStamp(this.digTriggerStamp)\n      .listenToTouch()\n      .addTriggerKeyByName('s')\n      .setKeyboardTipStamp(glyphs.stamps['S'])\n      .startListening();\n\n  this.fillTriggerWidget = new TriggerWidget(this.host.getHudEventTarget())\n      .setReleasedColorVec4(this.releasedColorVec4)\n      .setPressedColorVec4(this.pressedColorVec4)\n      .setStamp(this.fillTriggerStamp)\n      .listenToTouch()\n      .addTriggerKeyByName('a')\n      .setKeyboardTipStamp(glyphs.stamps['A'])\n      .startListening();\n\n  this.panTriggerWidget = new TriggerWidget(this.host.getWorldEventTarget())\n      .listenToMouseButton()\n      .addTriggerKeyByName('w')\n      .startListening();\n\n  this.topLeftTriggers = [this.addTriggerWidget, this.removeTriggerWidget];\n  this.bottomLeftTriggers = [this.fillTriggerWidget, this.digTriggerWidget, this.gripTriggerWidget];\n  this.leftTriggers = this.topLeftTriggers.concat(this.bottomLeftTriggers);\n\n  this.oldPanTriggerVal = false;\n  this.oldAddTriggerVal = false;\n  this.cameraVel = new Vec2d();\n\n  // touchscreen trackball, for pointing and panning\n  this.trackball = new TouchTrackball(this.host.getWorldEventTarget())\n      .setStartZoneFunction(function(x, y) {\n        return true;\n      });\n  this.trackball.setFriction(0.02);\n  this.movement = new Vec2d();\n  this.host.addListener(this.trackball);\n\n  // mouse for pointing and panning\n  this.mousePointer = new MousePointer(this.canvas, this.host.getViewMatrix(), false);\n  this.host.addListener(this.mousePointer);\n\n  // arrow keys for panning\n  this.keyStick = new KeyStick().setUpRightDownLeftByName(\n      Key.Name.UP, Key.Name.RIGHT, Key.Name.DOWN, Key.Name.LEFT);\n  this.host.addListener(this.keyStick);\n\n  this.modelMatrix = new Matrix44();\n  this.modelMatrix2 = new Matrix44();\n\n  this.cursorPos = new Vec2d();\n  this.cursorVel = new Vec2d();\n  this.cursorStamp = null; // it'll be a ring\n  this.colorVector = new Vec4();\n  this.cursorRad = 2;\n  this.cursorBody = this.createCursorBody();\n\n  this.indicatedBodyId = null;\n  this.indicatorChangeTime = 0;\n  this.indicatorStamp = null; // it'll be a ring\n  this.indicatorColorVector = new Vec4();\n\n  this.gripPoint = null;\n  this.gripAccelFraction = 0.3;\n  this.gripFriction = 0.2;\n  this.maxGripAccel = 10;\n\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n\n  this.oldMouseEventCoords = new Vec2d();\n\n  this.menu = new ModeMenuWidget(this.host.getHudEventTarget(), this.glyphs)\n      .setIndicatorStamp(this.addMenuIndicatorStamp)\n      .startListening();\n\n  this.updateHudLayout();\n}\n\nEditor.KEYBOARD_TIP_TIMEOUT_MS = 30 * 1000;\n\nEditor.prototype.addMenuItem = function(group, rank, name, model) {\n  this.menu.setItem(group, rank, name, model);\n};\n\nEditor.prototype.addMenuKeyboardShortcut = function(groupNum, keyName) {\n  this.menu.addKeyboardShortcut(groupNum, keyName);\n};\n\nEditor.prototype.getTriggerRad = function() {\n  return Math.min(50, 0.4 * Math.min(this.canvas.height, this.canvas.width*1.3) / this.leftTriggers.length);\n};\n\nEditor.prototype.getMenuItemSize = function() {\n  return Math.min(\n          this.getTriggerRad() * 1.3,\n          (this.canvas.width - this.getTriggerRad() * 2 - 50) / (this.menu.groups.length + 0.5));\n};\n\nEditor.prototype.updateHudLayout = function() {\n  this.triggerRad = this.getTriggerRad();\n  this.triggerSpacing = this.triggerRad * 0.25;\n  var tipOffsetX = this.triggerRad * 0.75;\n  var tipOffsetY = this.triggerRad * 0.7;\n  var tipScale = this.triggerRad * 0.12;\n  var triggerNum;\n  var self = this;\n\n  function triggerY(n) {\n    return 2 * n * self.triggerRad + (n+1) * self.triggerSpacing + self.triggerRad;\n  }\n  triggerNum = 0;\n  for (var i = 0; i < this.bottomLeftTriggers.length; i++) {\n    this.bottomLeftTriggers[i]\n        .setCanvasPositionXY(this.triggerRad, self.canvas.height - triggerY(triggerNum++))\n        .setCanvasScaleXY(this.triggerRad, this.triggerRad)\n        .setKeyboardTipOffsetXY(tipOffsetX, tipOffsetY)\n        .setKeyboardTipScaleXY(tipScale, -tipScale);\n  }\n  triggerNum = 0;\n  for (var i = 0; i < this.topLeftTriggers.length; i++) {\n    this.topLeftTriggers[i]\n        .setCanvasPositionXY(this.triggerRad, triggerY(triggerNum++))\n        .setCanvasScaleXY(this.triggerRad, this.triggerRad)\n        .setKeyboardTipOffsetXY(tipOffsetX, tipOffsetY)\n        .setKeyboardTipScaleXY(tipScale, -tipScale);\n  }\n  this.panTriggerWidget.setCanvasPositionXY(-1, -1).setCanvasScaleXY(0, 0);\n\n  var menuItemSize = this.getMenuItemSize();\n  this.menu.setItemPositionMatrix(new Matrix44().toScaleOpXYZ(menuItemSize, menuItemSize, 1));\n  this.menu.setItemScale(new Vec2d(1, -1).scale(menuItemSize * 0.3));\n  this.menu.setPosition(new Vec2d(this.triggerRad * 2 + menuItemSize, this.triggerSpacing + menuItemSize * 0.6));\n};\n\nEditor.prototype.getStamps = function() {\n  var model;\n  if (!this.cursorStamp) {\n    model = RigidModel.createDoubleRing(32).transformPositions(new Matrix44().toScaleOpXYZ(0.9, 0.9, 1));\n    this.cursorStamp = model.createModelStamp(this.renderer.gl);\n  }\n  if (!this.indicatorStamp) {\n    model = RigidModel.createDoubleRing(64);\n    this.indicatorStamp = model.createModelStamp(this.renderer.gl);\n  }\n  if (!this.circleStamp) {\n    model = RigidModel.createCircleMesh(5);\n    this.circleStamp = model.createModelStamp(this.renderer.gl);\n  }\n\n  var triggerBackgroundModel = RigidModel.createSquare().transformPositions(\n      new Matrix44().toTranslateOpXYZ(0, 0, 0.1))\n      .setColorRGB(0.3, 0.3, 0.3);\n\n  if (!this.addTriggerStamp) {\n    model =\n        RigidModel.createSquare().transformPositions(\n            new Matrix44().toScaleOpXYZ(0.65, 0.15, 1))\n            .addRigidModel(RigidModel.createSquare().transformPositions(\n                new Matrix44().toScaleOpXYZ(0.15, 0.65, 1)))\n            .addRigidModel(triggerBackgroundModel);\n    this.addTriggerStamp = model.createModelStamp(this.renderer.gl);\n  }\n\n  if (!this.removeTriggerStamp) {\n    model =\n        RigidModel.createSquare()\n            .transformPositions(new Matrix44().toScaleOpXYZ(0.65, 0.15, 1))\n            .addRigidModel(RigidModel.createSquare().transformPositions(\n                new Matrix44().toScaleOpXYZ(0.15, 0.65, 1)))\n            .transformPositions(new Matrix44().toRotateZOp(Math.PI / 4))\n            .addRigidModel(triggerBackgroundModel);\n    this.removeTriggerStamp = model.createModelStamp(this.renderer.gl);\n  }\n\n  if (!this.gripTriggerStamp) {\n    model =\n        RigidModel.createCircleMesh(3).transformPositions(\n            new Matrix44().toScaleOpXYZ(0.3, 0.3, 1))\n            .addRigidModel(RigidModel.createRingMesh(4, 0.8).transformPositions(\n                new Matrix44().toScaleOpXYZ(0.6, 0.6, 1)))\n            .addRigidModel(triggerBackgroundModel);\n    for (var i = 0; i < 4; i++) {\n      model.addRigidModel(RigidModel.createTriangle().transformPositions(\n          new Matrix44()\n              .multiply(new Matrix44().toRotateZOp(i * Math.PI / 2))\n              .multiply(new Matrix44().toTranslateOpXYZ(0, 0.76, 0))\n              .multiply(new Matrix44().toScaleOpXYZ(0.06, 0.06, 1))\n      ));\n    }\n    this.gripTriggerStamp = model.createModelStamp(this.renderer.gl);\n  }\n\n  var cursorIconRad = 0.43;\n\n  if (!this.digTriggerStamp) {\n    model = new RigidModel();\n    for (var x = -7.5; x <= 7.5; x++) {\n      var indent = 0;\n      if (Math.abs(x) < 2) indent = 4/8;\n      else if (Math.abs(x) < 3) indent = 3/8;\n      else if (Math.abs(x) < 4) indent = 2/8;\n      model.addRigidModel(RigidModel.createSquare().transformPositions(\n              new Matrix44()\n                  .multiply(new Matrix44().toTranslateOpXYZ(x/8, -1, 0.05))\n                  .multiply(new Matrix44().toScaleOpXYZ(1/16, 0.5 * (1 - indent), 1))\n                  .multiply(new Matrix44().toTranslateOpXYZ(0, 1, 0))));\n    }\n    model.addRigidModel(RigidModel.createRingMesh(5, 0.8).transformPositions(\n        new Matrix44()\n            .multiply(new Matrix44().toScaleOpXYZ(cursorIconRad, cursorIconRad, 1)))\n        .setColorRGB(1, 1, 1));\n    model.addRigidModel(triggerBackgroundModel);\n    this.digTriggerStamp = model.createModelStamp(this.renderer.gl);\n  }\n\n  if (!this.fillTriggerStamp) {\n    model = new RigidModel();\n    for (var x = -7.5; x <= 7.5; x++) {\n      var outdent = 0;\n      if (Math.abs(x) < 2) outdent = 4/8;\n      else if (Math.abs(x) < 3) outdent = 3/8;\n      else if (Math.abs(x) < 4) outdent = 2/8;\n      model.addRigidModel(RigidModel.createSquare().transformPositions(\n          new Matrix44()\n              .multiply(new Matrix44().toTranslateOpXYZ(x/8, -1, 0.05))\n              .multiply(new Matrix44().toScaleOpXYZ(1/16, 0.5 * (1 + outdent), 1))\n              .multiply(new Matrix44().toTranslateOpXYZ(0, 1, 0))));\n    }\n    model.addRigidModel(RigidModel.createRingMesh(5, 0.8).transformPositions(\n        new Matrix44()\n            .multiply(new Matrix44().toScaleOpXYZ(cursorIconRad, cursorIconRad, 1)))\n        .setColorRGB(0.5, 0.5, 0.5));\n    model.addRigidModel(triggerBackgroundModel);\n    this.fillTriggerStamp = model.createModelStamp(this.renderer.gl);\n  }\n\n  if (!this.addMenuIndicatorStamp) {\n    model = new RigidModel();\n    var size = 1.5;\n    var brightness = 0.5;\n\n    var thickness = 0.3;\n    var length = 0.5 + thickness;\n    for (var i = 0; i < 4; i++) {\n      model\n          .addRigidModel(RigidModel.createSquare().transformPositions(\n              new Matrix44()\n                  .multiply(new Matrix44().toScaleOpXYZ(size, size, 1))\n                  .multiply(new Matrix44().toRotateZOp(i * Math.PI/2))\n                  .multiply(new Matrix44().toTranslateOpXYZ(-1 + length/2 - thickness, -1 - thickness/2, 0))\n                  .multiply(new Matrix44().toScaleOpXYZ(length/2, thickness/2, 1))\n          ))\n          .addRigidModel(RigidModel.createSquare().transformPositions(\n              new Matrix44()\n                  .multiply(new Matrix44().toScaleOpXYZ(size, size, 1))\n                  .multiply(new Matrix44().toRotateZOp(i * Math.PI/2))\n                  .multiply(new Matrix44().toTranslateOpXYZ(-1 - thickness/2, -1 + length/2 - thickness, 0))\n                  .multiply(new Matrix44().toScaleOpXYZ(thickness/2, length/2, 1))\n          ));\n    }\n    model.setColorRGB(brightness, brightness, brightness);\n\n\n//    model\n//        .addRigidModel(\n//            RigidModel.createRingMesh(4, 0.9)\n//                .transformPositions(new Matrix44().multiply(new Matrix44().toScaleOpXYZ(size, size, 1)))\n//                .setColorRGB(brightness * 1.5, brightness * 1.5, brightness * 1.5))\n//        .addRigidModel(\n//            RigidModel.createCircleMesh(3)\n//                .transformPositions(new Matrix44().toScaleOpXYZ(size, size, 1))\n//                .setColorRGB(brightness, brightness, brightness));\n\n//    model\n//        .addRigidModel(RigidModel.createSquare().transformPositions(\n//            new Matrix44()\n//                .multiply(new Matrix44().toScaleOpXYZ(size, size, 1))\n//        ))\n//        .setColorRGB(brightness, brightness, brightness);\n\n\n    this.addMenuIndicatorStamp = model.createModelStamp(this.renderer.gl);\n  }\n\n  return [this.cursorStamp, this.indicatorStamp, this.circleStamp,\n    this.addTriggerStamp, this.gripTriggerStamp, this.digTriggerStamp, this.fillTriggerStamp,\n    this.addMenuIndicatorStamp];\n};\n\nEditor.prototype.createCursorBody = function() {\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.rad = this.cursorRad;\n  b.hitGroup = this.host.getCursorHitGroup();\n  return b;\n};\n\nEditor.prototype.handleInput = function() {\n  var oldCursorPos = Vec2d.alloc().set(this.cursorPos);\n  var sensitivity = this.host.getViewDist() * 0.02;\n\n  // touch trackball movement\n  this.trackball.getVal(this.movement);\n  if (this.trackball.isTouched()) {\n    var inertia = 0.75;\n    var newVel = Vec2d.alloc().setXY(this.movement.x, -this.movement.y).scale(sensitivity);\n    this.cursorVel.scale(inertia).add(newVel.scale(1 - inertia));\n    newVel.free();\n  }\n  this.trackball.reset();\n\n  // mouse pointer movement\n  this.mousePointer.setViewMatrix(this.host.getViewMatrix());\n  if (!this.mousePointer.eventCoords.equals(this.oldMouseEventCoords) || this.panTriggerWidget.getVal()) {\n    var timeout = Date.now() + Editor.KEYBOARD_TIP_TIMEOUT_MS;\n    for (var i = 0; i < this.leftTriggers.length; i++) {\n      this.leftTriggers[i].setKeyboardTipTimeoutMs(timeout);\n    }\n    this.cursorVel.reset();\n    if (this.panTriggerWidget.getVal() && this.oldPanTriggerVal) {\n      // panning\n      this.cameraVel.set(this.cursorPos).subtract(this.mousePointer.position);\n    } else if (this.panTriggerWidget.getVal()) {\n      // halt\n      this.cameraVel.reset();\n    } else {\n      // pointing\n      this.cursorPos.set(this.mousePointer.position);\n    }\n  }\n  this.oldMouseEventCoords.set(this.mousePointer.eventCoords);\n  this.oldPanTriggerVal = this.panTriggerWidget.getVal();\n\n  // arrow key panning\n  this.keyStick.getVal(this.movement);\n  if (!this.movement.isZero()) {\n    this.cameraVel.add(this.movement.scale(0.1));\n  }\n\n  if (!this.cursorVel.isZero()) {\n    this.cursorPos.add(this.cursorVel);\n    // Increase friction at low speeds, to help make smaller movements.\n    var slowness = Math.max(0, (1 - this.cursorVel.magnitude()/sensitivity));\n\n    this.host.camera.follow(this.cursorPos);\n    this.host.updateViewMatrix();\n    this.mousePointer.setViewMatrix(this.host.getViewMatrix());\n\n    this.cursorVel.scale(0.95 - 0.2 * slowness);\n  }\n\n  if (!this.cameraVel.isZero()) {\n    this.host.camera.add(this.cameraVel);\n    this.host.updateViewMatrix();\n    this.mousePointer.setViewMatrix(this.host.getViewMatrix());\n\n    if (!this.panTriggerWidget.getVal()) {\n      // The camera is making the world drift beneath the mouse.\n      this.cursorPos.set(this.mousePointer.position);\n    }\n    this.cameraVel.scale(0.94);\n  }\n\n  if (this.gripTriggerWidget.getVal() && this.indicatedBodyId) {\n    this.dragObject();\n  } else {\n    if (this.gripPoint) {\n      this.gripPoint.free();\n      this.gripPoint = null;\n    }\n    this.doCursorHoverScan();\n  }\n\n  if (this.digTriggerWidget.getVal()) {\n    this.host.drawTerrainPill(oldCursorPos, this.cursorPos, this.cursorRad, 1);\n  } else if (this.fillTriggerWidget.getVal()) {\n    this.host.drawTerrainPill(oldCursorPos, this.cursorPos, this.cursorRad, 0);\n  }\n\n  if (this.addTriggerWidget.getVal() && !this.oldAddTriggerVal) {\n    this.host.addItem(this.menu.getSelectedName(), this.cursorPos);\n  }\n  if (this.removeTriggerWidget.getVal() && this.indicatedBodyId) {\n    this.host.removeByBodyId(this.indicatedBodyId);\n    this.setIndicatedBodyId(null);\n  }\n  this.oldAddTriggerVal = this.addTriggerWidget.getVal();\n\n  oldCursorPos.free();\n};\n\nEditor.prototype.dragObject = function() {\n  var body = this.host.getBodyById(this.indicatedBodyId);\n  var bodyPos = this.host.getBodyPos(body, this.vec2d);\n  if (!this.gripPoint) {\n    // Get a grip.\n    this.gripPoint = Vec2d.alloc()\n        .set(this.cursorPos)\n        .subtract(bodyPos);\n  }\n  // Drag it! Drag it? Drag it!\n  var newVel = Vec2d.alloc()\n      .set(this.cursorPos)\n      .subtract(bodyPos)\n      .subtract(this.gripPoint)\n      .scale(this.gripAccelFraction)\n      .add(body.vel)\n      .scale(1 - this.gripFriction);\n  if (newVel.distance(body.vel) > this.maxGripAccel) {\n    newVel.subtract(body.vel).clipToMaxLength(this.maxGripAccel).add(body.vel);\n  }\n  body.setVelAtTime(newVel, this.host.getWorldTime());\n  newVel.free();\n};\n\nEditor.prototype.doCursorHoverScan = function() {\n  this.cursorBody.setPosAtTime(this.cursorPos, this.host.getWorldTime());\n  var i, hitBody, overlapBodyIds;\n\n  // center pinpoint check\n  this.cursorBody.rad = 0;\n  overlapBodyIds = this.host.getBodyOverlaps(this.cursorBody);\n  var lowestArea = Infinity;\n  var smallestBody = null;\n  for (i = 0; i < overlapBodyIds.length; i++) {\n    hitBody = this.host.getBodyById(overlapBodyIds[i]);\n    if (hitBody) {\n      if (hitBody.hitGroup != this.host.getWallHitGroup() &&\n          hitBody.getArea() < lowestArea) {\n        lowestArea = hitBody.getArea();\n        smallestBody = hitBody;\n      }\n    }\n  }\n  this.setIndicatedBodyId(smallestBody ? smallestBody.id : null);\n};\n\nEditor.prototype.setIndicatedBodyId = function(id) {\n  if (id != this.indicatedBodyId) {\n    this.indicatedBodyId = id;\n    this.indicatorChangeTime = Date.now();\n  }\n};\n\nEditor.prototype.bodyIfInGroup = function(group, b0, b1) {\n  if (b0 && b0.hitGroup == group) return b0;\n  if (b1 && b1.hitGroup == group) return b1;\n  return null;\n};\n\nEditor.prototype.drawScene = function() {\n  this.renderer.setBlendingEnabled(true);\n\n  // highlighted body indicator\n  var indicatedBody = this.host.getBodyById(this.indicatedBodyId);\n  if (indicatedBody) {\n    var bodyPos = this.host.getBodyPos(indicatedBody, this.vec2d);\n    var innerRad = indicatedBody.rad + this.host.getViewDist() * 0.02;\n    var outerRad = indicatedBody.rad + this.host.getViewDist() * 0.03;\n    this.renderer\n        .setStamp(this.indicatorStamp)\n        .setColorVector(this.getIndicatorColorVector());\n    this.modelMatrix.toIdentity()\n        .multiply(this.mat44.toTranslateOpXYZ(bodyPos.x, bodyPos.y, -0.98))\n        .multiply(this.mat44.toScaleOpXYZ(innerRad, innerRad, 1));\n    this.renderer.setModelMatrix(this.modelMatrix);\n    this.modelMatrix2.toIdentity()\n        .multiply(this.mat44.toTranslateOpXYZ(bodyPos.x, bodyPos.y, -0.98))\n        .multiply(this.mat44.toScaleOpXYZ(outerRad, outerRad, 1));\n    this.renderer.setModelMatrix2(this.modelMatrix2);\n    this.renderer.drawStamp();\n  }\n\n  // cursor\n  var gt = this.gripTriggerWidget.getVal();\n  var dt = this.digTriggerWidget.getVal();\n  var ft = this.fillTriggerWidget.getVal();\n  var rt = this.removeTriggerWidget.getVal();\n  var any = ft || dt || gt || rt;\n  var coef = any ? 1 : 0.8;\n  this.renderer\n      .setStamp(this.cursorStamp)\n      .setColorVector(this.colorVector.setRGBA(\n          ft ? 0.5 : coef,\n          dt ? 0.5 : coef,\n          gt ? 0.5 : coef,\n          this.indicatedBodyId && gt && !(dt || ft || rt) ? 0.3 : 0.8));\n  var outerCursorRad = this.cursorRad;\n  var innerCursorRad = this.cursorRad * 0.9;\n  this.modelMatrix.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(this.cursorPos.x, this.cursorPos.y, -0.99))\n      .multiply(this.mat44.toScaleOpXYZ(outerCursorRad, outerCursorRad, 1));\n  this.renderer.setModelMatrix(this.modelMatrix);\n  this.modelMatrix2.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(this.cursorPos.x, this.cursorPos.y, -0.99))\n      .multiply(this.mat44.toScaleOpXYZ(innerCursorRad, innerCursorRad, 1));\n  this.renderer.setModelMatrix2(this.modelMatrix2);\n  this.renderer.drawStamp();\n\n  this.renderer.setBlendingEnabled(false);\n};\n\n/**\n * Draw stuff on screen coords, with 0,0 at the top left and canvas.width, canvas.height at the bottom right.\n */\nEditor.prototype.drawHud = function() {\n  for (var i = 0; i < this.leftTriggers.length; i++) {\n    this.leftTriggers[i].draw(this.renderer);\n  }\n  this.menu.draw(this.renderer);\n};\n\nEditor.prototype.getIndicatorColorVector = function() {\n  this.indicatorColorVector.setRGBA(1, 1, 1, 0.7);\n  return this.indicatorColorVector;\n};\n\nEditor.prototype.getMousePageX = function() {\n  return this.oldMouseEventCoords.x;\n};\n\nEditor.prototype.getMousePageY = function() {\n  return this.oldMouseEventCoords.y;\n};\n\n\n\n/* ---- js/events.js ---- */\n\n\n\nvar Events = {};\n\n/**\n * keycodes for key event.keyCode\n */\nEvents.KEYCODES = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  UP_SAFARI: 63232,\n  DOWN_SAFARI: 63233,\n  LEFT_SAFARI: 63234,\n  RIGHT_SAFARI: 63235,\n  ENTER: 77,\n  RETURN: 13,\n  ESC: 27,\n  DOT: 46,\n  SPACE: 32,\n  C: 67,\n  I: 73,\n  J: 74,\n  K: 75,\n  L: 76,\n  P: 80,\n  S: 83,\n  X: 88,\n  Z: 90,\n  BACKSLASH: 220\n};\n\n/**\n * Adds an event listener.\n * @param {object} element  DOM element to which to attach listener\n * @param {string} eventName  like 'click', without the 'on' part\n * @param {function} fn  listener function to add\n */\nEvents.addListener = function(element, eventName, fn) {\n  if (element.addEventListener) {\n    // DOM Level 2\n    element.addEventListener(eventName, fn, false);\n  } else if (element.attachEvent) {\n    // IE\n    element.attachEvent('on' + eventName, fn);\n  }\n};\n\n\n/**\n * Adds a listener to multiple events.\n * @param {object} element  DOM element to which to attach listener\n * @param {array.<string>} eventNames  like 'click', without the 'on' part\n * @param {function} fn  listener function to add\n */\nEvents.addListenerToEvents = function(element, eventNames, fn) {\n  for (var i = 0; i < eventNames.length; ++i) {\n    Events.addListener(element, eventNames[i], fn);\n  }\n};\n\n\n/**\n * Removes an event listener.\n * @param {object} element  DOM element from which to remove listener\n * @param {string} eventName  like 'click', without the 'on' part\n * @param {function} fn  listener function to remove\n */\nEvents.removeListener = function(element, eventName, fn) {\n  if (element.removeEventListener) {\n    // DOM level 2\n    element.removeEventListener(eventName, fn, false);\n  } else if (element['detatchEvent']) {\n    // IE\n    element['detatchEvent']('on' + eventName, fn);\n  }\n};\n\n\n/**\n * Removes an event listener from multiple events.\n * @param {object} element  DOM element from which to remove listener\n * @param {array.<string>} eventNames  like 'click', without the 'on' part\n * @param {function} fn  listener function to remove\n */\nEvents.removeListenerFromEvents = function(element, eventNames, fn) {\n  for (var i = 0; i < eventNames.length; ++i) {\n    Events.removeListener(element, eventNames[i], fn);\n  }\n};\n\n\n/**\n * Gets the event target from an event object.\n * @param {object} event\n */\nEvents.getTarget = function(event) {\n  return event.target || event.srcElement;\n};\n\n\n/**\n * Gets the related target for a mouseover/mouseout event.\n * @param {object} event  must not be null\n * @return {object} element or null\n */\nEvents.getRelatedTarget = function(event) {\n  // Other\n  if (event.relatedTarget) return event.relatedTarget;\n  // IE\n  switch(event.type) {\n    case 'mouseover': return event.fromElement;\n    case 'mouseout': return event.toElement;\n  }\n  return null;\n};\n\n\n/**\n * For mouseover/mouseout, returns the element that the mouse left.\n * May return null when the mouse is entering from off-window.\n * @param {object} event  must not be null\n * @return {object} element or null\n */\nEvents.getFromElement = function(event) {\n  // IE\n  if (event.fromElement) return event.fromElement;\n  // Other\n  switch(event.type) {\n    case 'mouseover': return event.relatedTarget;\n    case 'mouseout': return event.target;\n  }\n  return null;\n};\n\n\n/**\n * For mouseover/mouseout, returns the element that the mouse entered.\n * May return null when the mouse is leaving the window.\n * @param {object} event  must not be null\n * @return {object} element or null\n */\nEvents.getToElement = function(event) {\n  // IE\n  if (event.toElement) return event.toElement;\n  // Other\n  switch(event.type) {\n    case 'mouseover': return event.target;\n    case 'mouseout': return event.relatedTarget;\n  }\n  return null;\n};\n\n\nEvents.preventDefault = function(event) {\n  if ('preventDefault' in event) {\n    // DOM2\n    event.preventDefault();\n  }\n  if ('returnValue' in event) {\n    event.returnValue = false;\n  }\n  if ('cancelBubble' in event) {\n    event.cancelBubble = true;\n  }\n};\n\nEvents.isRightClick = function(mouseClickEvent) {\n  // see http://www.quirksmode.org/js/events_properties.html#button\n  return mouseClickEvent.button == 2;\n};\n\n\n\n// ---------------------- Mix --------------------------\n\n\n\n/* ---- js/ballspirit.js ---- */\n\n\n\n/**\n * @constructor\n * @extends {Spirit}\n */\nfunction BallSpirit(playScreen) {\n  Spirit.call(this);\n  this.playScreen = playScreen;\n\n  this.type = PlayScreen.SpiritType.BALL;\n  this.id = -1;\n  this.bodyId = -1;\n  this.modelStamp = null;\n  this.color = new Vec4();\n\n  // temps\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.modelMatrix = new Matrix44();\n}\nBallSpirit.prototype = new Spirit();\nBallSpirit.prototype.constructor = BallSpirit;\n\nBallSpirit.SCHEMA = {\n  0: \"type\",\n  1: \"id\",\n  2: \"bodyId\",\n  3: \"color\"\n};\n\nBallSpirit.MEASURE_TIMEOUT = 100;\n\nBallSpirit.getJsoner = function() {\n  if (!BallSpirit.jsoner) {\n    BallSpirit.jsoner = new Jsoner(BallSpirit.SCHEMA);\n  }\n  return BallSpirit.jsoner;\n};\n\nBallSpirit.prototype.setModelStamp = function(modelStamp) {\n  this.modelStamp = modelStamp;\n};\n\nBallSpirit.prototype.setColorRGB = function(r, g, b) {\n  this.color.setXYZ(r, g, b);\n};\n\nBallSpirit.prototype.onDraw = function(world, renderer) {\n  var body = this.getBody(world);\n  var bodyPos = body.getPosAtTime(world.now, this.vec2d);\n  renderer\n      .setStamp(this.modelStamp)\n      .setColorVector(this.color);\n  // Render the smaller ones in front.\n  // TODO: standardize Z\n  this.modelMatrix.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(bodyPos.x, bodyPos.y, -1 + Math.max(0, body.rad / 100)))\n      .multiply(this.mat44.toScaleOpXYZ(body.rad, body.rad, 1));\n\n  renderer.setModelMatrix(this.modelMatrix);\n  renderer.drawStamp();\n};\n\nBallSpirit.prototype.onTimeout = function(world, timeout) {\n  var body = this.getBody(world);\n  if (body) {\n    body.moveToTime(world.now);\n    body.invalidatePath();\n  }\n  world.addTimeout(world.now + BallSpirit.MEASURE_TIMEOUT, this.id, -1);\n};\n\nBallSpirit.prototype.getBody = function(world) {\n  return world.bodies[this.bodyId];\n};\n\n\nBallSpirit.prototype.toJSON = function() {\n  return BallSpirit.getJsoner().toJSON(this);\n};\n\nBallSpirit.prototype.setFromJSON = function(json) {\n  BallSpirit.getJsoner().setFromJSON(json, this);\n};\n\n\n/* ---- js/antspirit.js ---- */\n\n\n\n/**\n * @constructor\n * @extends {Spirit}\n */\nfunction AntSpirit(playScreen) {\n  Spirit.call(this);\n  this.playScreen = playScreen;\n  this.bodyId = -1;\n  this.id = -1;\n  this.modelStamp = null;\n\n  this.type = PlayScreen.SpiritType.ANT;\n  this.color = new Vec4().setRGBA(1, 1, 1, 1);\n  // 0 is up, PI/2 is right\n  this.dir = 0;//Math.random() * Math.PI * 2;\n  this.angVel = 0;\n\n  this.tempBodyPos = new Vec2d();\n  this.vec2d = new Vec2d();\n  this.scanVec = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.modelMatrix = new Matrix44();\n}\nAntSpirit.prototype = new Spirit();\nAntSpirit.prototype.constructor = AntSpirit;\n\nAntSpirit.MEASURE_TIMEOUT = 0.6;\n\nAntSpirit.SCHEMA = {\n  0: \"type\",\n  1: \"id\",\n  2: \"bodyId\",\n  3: \"color\",\n  4: \"dir\",\n  5: \"angVel\"\n};\n\nAntSpirit.getJsoner = function() {\n  if (!AntSpirit.jsoner) {\n    AntSpirit.jsoner = new Jsoner(AntSpirit.SCHEMA);\n  }\n  return AntSpirit.jsoner;\n};\n\nAntSpirit.prototype.toJSON = function() {\n  return AntSpirit.getJsoner().toJSON(this);\n};\n\nAntSpirit.prototype.setFromJSON = function(json) {\n  AntSpirit.getJsoner().setFromJSON(json, this);\n};\n\nAntSpirit.prototype.setModelStamp = function(modelStamp) {\n  this.modelStamp = modelStamp;\n};\n\nAntSpirit.prototype.setColorRGB = function(r, g, b) {\n  this.color.setXYZ(r, g, b);\n};\n\nAntSpirit.prototype.scan = function(pos, rot, dist, rad) {\n  return this.playScreen.scan(\n      PlayScreen.Group.ROCK,\n      pos,\n      this.scanVec.setXY(\n          Math.sin(this.dir + rot) * dist,\n          Math.cos(this.dir + rot) * dist),\n      rad);\n};\n\nAntSpirit.prototype.onTimeout = function(world, event) {\n  var body = this.getBody(world);\n  var pos = body.getPosAtTime(world.now, this.tempBodyPos);\n  var basicThrust = 0.03;\n  var maxTurn = 0.07;\n  var thrust = basicThrust;\n  var friction = 0.08;\n\n  var antennaRot = Math.PI / 3.5;\n  var scanDist = body.rad * 5;\n  var turn = 0;\n  var scanRot = antennaRot * (Math.random() - 0.5);\n  var dist = this.scan(pos, scanRot, scanDist, body.rad/2);\n  if (dist >= 0) {\n    if (scanRot > 0) {\n      turn += maxTurn * (-antennaRot/2 - scanRot) * (1 - dist/2);\n    } else {\n      turn += maxTurn * (antennaRot/2 - scanRot) * (1 - dist/2);\n    }\n    thrust -= basicThrust * (1 - dist);\n  }\n  this.angVel *= 0.90;\n  this.angVel += turn;\n  if (this.angVel > Math.PI/2) this.angVel = Math.PI/2;\n  if (this.angVel < -Math.PI/2) this.angVel = -Math.PI/2;\n  this.dir += this.angVel;\n  var newVel = this.vec2d\n    .set(body.vel).scale(1 - friction)\n    .addXY(Math.sin(this.dir) * thrust, Math.cos(this.dir) * thrust);\n  body.setVelAtTime(newVel, world.now);\n  world.addTimeout(world.now + AntSpirit.MEASURE_TIMEOUT * (Math.random() + 0.5), this.id, -1);\n};\n\nAntSpirit.prototype.onDraw = function(world, renderer) {\n  var body = this.getBody(world);\n  body.getPosAtTime(world.now, this.tempBodyPos);\n  renderer\n      .setStamp(this.modelStamp)\n      .setColorVector(this.vec4.set(this.color));\n  this.modelMatrix.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(this.tempBodyPos.x, this.tempBodyPos.y, 0))\n      .multiply(this.mat44.toScaleOpXYZ(body.rad, body.rad, 1))\n      .multiply(this.mat44.toRotateZOp(-this.dir));\n  renderer.setModelMatrix(this.modelMatrix);\n  renderer.drawStamp();\n};\n\nAntSpirit.prototype.getBody = function(world) {\n  return world.bodies[this.bodyId];\n}; \n\n\n/* ---- js/soundspirit.js ---- */\n\n\n/**\n * @constructor\n * @extends {Spirit}\n */\nfunction SoundSpirit(playScreen) {\n  Spirit.call(this);\n  this.playScreen = playScreen;\n  this.bodyId = -1;\n  this.id = -1;\n  this.modelStamp = null;\n\n  this.type = PlayScreen.SpiritType.SOUND;\n  this.color = new Vec4();\n  this.sounds = [];\n\n  this.tempBodyPos = new Vec2d();\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.modelMatrix = new Matrix44();\n  this.lastSoundTime = -Infinity;\n  this.hard = false;\n}\nSoundSpirit.prototype = new Spirit();\nSoundSpirit.prototype.constructor = SoundSpirit;\n\nSoundSpirit.MEASURE_TIMEOUT = 180;\n\nSoundSpirit.SOUND_MEASURE_TIME = 0;\nSoundSpirit.SOUND_VOLUME = 1;\nSoundSpirit.SOUND_ATTACK = 2;\nSoundSpirit.SOUND_SUSTAIN = 3;\nSoundSpirit.SOUND_DECAY = 4;\nSoundSpirit.SOUND_FREQ1 = 5;\nSoundSpirit.SOUND_FREQ2 = 6;\nSoundSpirit.SOUND_TYPE = 7;\n\nSoundSpirit.SCHEMA = {\n  0: \"type\",\n  1: \"id\",\n  2: \"bodyId\",\n  3: \"color\",\n  4: \"sounds\",\n  5: \"hard\"\n};\n\nSoundSpirit.getJsoner = function() {\n  if (!SoundSpirit.jsoner) {\n    SoundSpirit.jsoner = new Jsoner(SoundSpirit.SCHEMA);\n  }\n  return SoundSpirit.jsoner;\n};\n\nSoundSpirit.prototype.toJSON = function() {\n  return SoundSpirit.getJsoner().toJSON(this);\n};\n\nSoundSpirit.prototype.setFromJSON = function(json) {\n  SoundSpirit.getJsoner().setFromJSON(json, this);\n};\n\n\nSoundSpirit.prototype.setModelStamp = function(modelStamp) {\n  this.modelStamp = modelStamp;\n};\n\nSoundSpirit.prototype.setColorRGB = function(r, g, b) {\n  this.color.setXYZ(r, g, b);\n};\n\nSoundSpirit.prototype.setSounds = function(sounds) {\n  this.sounds = sounds;\n};\n\nSoundSpirit.prototype.onTimeout = function(world, event) {\n  var body = this.getBody(world);\n\n  // Play a sound?\n  var measureTime = event.timeoutVal;\n  var bodyPos = body.getPosAtTime(world.now, this.vec2d);\n  var makesSound = false;\n  for (var i = 0; i < this.sounds.length; i++) {\n    var s = this.sounds[i];\n    if (s[SoundSpirit.SOUND_MEASURE_TIME] == measureTime) {\n      makesSound = true;\n      this.playScreen.sfx.sound(bodyPos.x, bodyPos.y, 0,\n          s[SoundSpirit.SOUND_VOLUME],\n          s[SoundSpirit.SOUND_ATTACK],\n          s[SoundSpirit.SOUND_SUSTAIN],\n          s[SoundSpirit.SOUND_DECAY],\n          s[SoundSpirit.SOUND_FREQ1],\n          s[SoundSpirit.SOUND_FREQ2],\n          s[SoundSpirit.SOUND_TYPE]);\n      this.lastSoundTime = world.now;\n      var newVel = Vec2d.alloc()\n          .set(body.vel).scale(0.9)\n          .addXY(0.1 * (Math.random() - 0.5), 0.1 * (Math.random() - 0.5));\n      body.setVelAtTime(newVel, world.now);\n      newVel.free();\n    }\n  }\n  if (makesSound) {\n    this.vec4.set(this.color).scale1(2);\n    this.playScreen.addNoteSplash(bodyPos.x, bodyPos.y, body.vel.x/3, body.vel.y/3,\n        this.vec4.v[0], this.vec4.v[1], this.vec4.v[2],\n        body.rad * (this.hard ? 1.5 : 1));\n  }\n\n  // TODO: be less dumb\n  var addedTimes = {};\n  if (event.timeoutVal === -1) {\n    // This is the start of a measure. Plan the next measure of sounds.\n    world.addTimeout(world.now + SoundSpirit.MEASURE_TIMEOUT, this.id, -1);\n    addedTimes[0] = true;\n    for (var i = 0; i < this.sounds.length; i++) {\n      var s = this.sounds[i];\n      var timeoutTime = world.now + SoundSpirit.MEASURE_TIMEOUT * s[SoundSpirit.SOUND_MEASURE_TIME];\n      if (!addedTimes[timeoutTime]) {\n        addedTimes[timeoutTime] = true;\n        world.addTimeout(timeoutTime, this.id, s[SoundSpirit.SOUND_MEASURE_TIME]);\n      }\n    }\n  }\n};\n\nSoundSpirit.prototype.onDraw = function(world, renderer) {\n  var body = this.getBody(world);\n  body.getPosAtTime(world.now, this.tempBodyPos);\n  var colorScale = 1+1.5*Math.max(0, Math.min(1, 1 - 6*(world.now - this.lastSoundTime)/SoundSpirit.MEASURE_TIMEOUT));\n  renderer\n      .setStamp(this.modelStamp)\n      .setColorVector(this.vec4.set(this.color).scale1(colorScale));\n  this.modelMatrix.toIdentity()\n      .multiply(this.mat44.toTranslateOpXYZ(this.tempBodyPos.x, this.tempBodyPos.y, 0))\n      .multiply(this.mat44.toScaleOpXYZ(body.rad, body.rad, 1));\n  renderer.setModelMatrix(this.modelMatrix);\n  renderer.drawStamp();\n};\n\nSoundSpirit.prototype.getBody = function(world) {\n  return world.bodies[this.bodyId];\n};\n\n\n/* ---- js/wallspirit.js ---- */\n\n\n/**\n * @constructor\n * @extends {Spirit}\n */\nfunction WallSpirit() {\n  Spirit.call(this);\n  this.bodyId = -1;\n  this.id = -1;\n  this.modelStamp = null;\n  this.color = new Vec4(0, 0.7, 2);\n\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.modelMatrix = new Matrix44();\n}\nWallSpirit.prototype = new Spirit();\nWallSpirit.prototype.constructor = WallSpirit;\n\nWallSpirit.prototype.setModelStamp = function(modelStamp) {\n  this.modelStamp = modelStamp;\n};\n\nWallSpirit.prototype.onDraw = function(world, renderer) {\n  renderer\n      .setStamp(this.modelStamp)\n      .setColorVector(this.color);\n  var b = world.bodies[this.bodyId];\n  b.getPosAtTime(world.now, this.vec2d);\n  this.modelMatrix.toTranslateOpXYZ(this.vec2d.x, this.vec2d.y, 0);\n  this.modelMatrix.multiply(this.mat44.toScaleOpXYZ(b.rectRad.x, b.rectRad.y, 1));\n  renderer.setModelMatrix(this.modelMatrix);\n  renderer.drawStamp();\n};\n\n\n/* ---- js/buttonspirit.js ---- */\n\n\n/**\n * @constructor\n * @extends {Spirit}\n */\nfunction ButtonSpirit() {\n  Spirit.call(this);\n  this.bodyId = -1;\n  this.id = -1;\n  this.modelStamp = null;\n\n  this.color = new Vec4();\n  this.lastSoundMs = 0;\n  this.soundLength = 1;\n  this.onClick = null;\n\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.modelMatrix = new Matrix44();\n}\nButtonSpirit.prototype = new Spirit();\nButtonSpirit.prototype.constructor = ButtonSpirit;\n\nButtonSpirit.POINTER_RADIUS = 0.0;\n\nButtonSpirit.prototype.setModelStamp = function(modelStamp) {\n  this.modelStamp = modelStamp;\n};\n\n/**\n * @param {function} func  A function of (e)\n */\nButtonSpirit.prototype.setOnClick = function(func) {\n  this.onClick = func;\n};\n\nButtonSpirit.prototype.onDraw = function(world, renderer) {\n  var life = 0;\n  if (Date.now() - this.lastSoundMs < this.soundLength) {\n    life = 1 - (Date.now() - this.lastSoundMs) / this.soundLength;\n    var t = Date.now() / 300;\n    this.color.setXYZ(\n            1 + life * Math.sin(t + 0),\n            1 + life * Math.sin(t + 2*Math.PI/3),\n            1 + life * Math.sin(t + 2*2*Math.PI/3));\n  } else {\n    this.color.setXYZ(1, 1, 1);\n  }\n  var body = this.getBody(world);\n  var bodyPos = body.getPosAtTime(world.now, this.vec2d);\n  this.modelMatrix.toTranslateOpXYZ(bodyPos.x, bodyPos.y, 0);\n  renderer\n      .setStamp(this.modelStamp)\n      .setColorVector(this.color)\n      .setModelMatrix(this.modelMatrix)\n      .drawStamp();\n  this.animating = !!life;\n};\n\nButtonSpirit.prototype.getBody = function(world) {\n  return world.bodies[this.bodyId];\n};\n\nButtonSpirit.prototype.isOverlapping = function(world, pointerPos) {\n  var body = this.getBody(world);\n  var bodyPos = body.getPosAtTime(world.now, this.vec2d);\n  return OverlapDetector.isRectOverlappingCircle(\n      bodyPos, body.rectRad, pointerPos, ButtonSpirit.POINTER_RADIUS);\n};\n\n\n\n/* ---- js/basescreen.js ---- */\n\n\n\n/**\n * @constructor\n * @extends {Screen}\n */\nfunction BaseScreen(controller, canvas, renderer, glyphs, stamps, sound) {\n  Screen.call(this);\n  this.controller = controller;\n  this.canvas = canvas;\n  this.renderer = renderer;\n  this.glyphs = glyphs;\n  this.stamps = stamps;\n  this.sfx = sound;\n\n  this.viewMatrix = new Matrix44();\n  this.vec2d = new Vec2d();\n  this.vec4 = new Vec4();\n  this.mat44 = new Matrix44();\n  this.nextButtonNum = 0;\n  this.worldBoundingRect = new Rect();\n\n  this.lastPathRefreshTime = -Infinity;\n  this.visibility = 0;\n  this.listening = false;\n\n  this.resizeFn = this.getResizeFn();\n\n  this.paused = false;\n}\nBaseScreen.prototype = new Screen();\nBaseScreen.prototype.constructor = BaseScreen;\n\nBaseScreen.MS_PER_FRAME = 1000 / 60;\nBaseScreen.CLOCKS_PER_FRAME = 0.5;\nBaseScreen.PATH_DURATION = 0xffff;\n\nBaseScreen.prototype.getResizeFn = function() {\n  var self = this;\n  return function() {\n    self.controller.requestAnimation();\n  }\n};\n\nBaseScreen.prototype.setScreenListening = function(listen) {\n  if (listen == this.listening) return;\n  if (listen) {\n    window.addEventListener('resize', this.resizeFn);\n  } else {\n    window.removeEventListener('resize', this.resizeFn);\n  }\n  this.listening = listen;\n};\n\nBaseScreen.prototype.drawScreen = function(visibility) {\n  this.visibility = visibility;\n  this.lazyInit();\n  this.updateViewMatrix();\n  this.drawScene();\n  if (this.visibility == 1) {\n    this.clock();\n  }\n};\n\nBaseScreen.prototype.drawScene = function() {};\n\nBaseScreen.prototype.destroyScreen = function() {\n  // Unload button models? Need a nice utility for loading, remembering, and unloading models.\n};\n\nBaseScreen.prototype.clock = function() {\n  if (this.paused) return;\n  var endTimeMs = Date.now() + BaseScreen.MS_PER_FRAME;\n  var endClock = this.world.now + BaseScreen.CLOCKS_PER_FRAME;\n\n  if (this.handleInput) {\n    this.handleInput();\n  }\n\n  if (this.lastPathRefreshTime + BaseScreen.PATH_DURATION <= endClock) {\n    this.lastPathRefreshTime = this.world.now;\n    for (var id in this.world.bodies) {\n      var b = this.world.bodies[id];\n      if (b && b.pathDurationMax > BaseScreen.PATH_DURATION && b.pathDurationMax != Infinity) {\n        b.invalidatePath();\n        b.moveToTime(this.world.now);\n      }\n    }\n  }\n\n  var e = this.world.getNextEvent();\n  // Stop if there are no more events to process, or we've moved the game clock far enough ahead\n  // to match the amount of wall-time elapsed since the last frame,\n  // or (worst case) we're out of time for this frame.\n\n  while (e && e.time <= endClock && Date.now() <= endTimeMs) {\n    this.world.processNextEvent();\n    if (e.type == WorldEvent.TYPE_HIT) {\n      this.onHitEvent(e);\n    }\n    e = this.world.getNextEvent();\n  }\n  if (!e || e.time > endClock) {\n    this.world.now = endClock;\n  }\n};\n\nBaseScreen.prototype.onHitEvent = function(e) {}; \n\n\n\n/* ---- js/titlescreen.js ---- */\n\n\n/**\n * @constructor\n * @extends {BaseScreen}\n */\nfunction TitleScreen(controller, canvas, renderer, glyphs, stamps, sound) {\n  BaseScreen.call(this, controller, canvas, renderer, glyphs, stamps, sound);\n}\nTitleScreen.prototype = new BaseScreen();\nTitleScreen.prototype.constructor = TitleScreen;\n\nTitleScreen.prototype.lazyInit = function() {\n  if (!this.world) {\n    this.initWorld();\n  }\n};\n\nTitleScreen.prototype.initWorld = function() {\n  this.world = new World(World.DEFAULT_CELL_SIZE, 2, [[0, 0], [1, 1]]);\n  this.resolver = new HitResolver();\n  this.resolver.defaultElasticity = 0.9;\n  var labelMaker = new LabelMaker(this.glyphs);\n  var controller = this.controller;\n  var sfx = this.sfx;\n  var world = this.world;\n\n  var spiritId;\n\n  var buttonMaker = new ButtonMaker(labelMaker, this.world, null, this.renderer);\n  buttonMaker\n      .setNextCharMatrix(new Matrix44().toTranslateOpXYZ(3, 0, 0))\n      .setPaddingXY(1.5, 0.5);\n\n  // TITLE\n  buttonMaker.setLetterColor([0.75*0.7, 0.25 * 0.7, 1*0.7]).setBlockColor(null).setScale(1);\n  buttonMaker.addButton(0, 12, \"TEST 34\", null);\n  buttonMaker.addButton(0, 5, \"TERRAIN\", null);\n  buttonMaker.addButton(0, 0, \"DRAGGING\", null);\n  buttonMaker.setScale(1);\n\n  // PLAY\n  buttonMaker.setLetterColor([0.75, 0.25, 1]).setBlockColor([0.75*0.5, 0.25*0.5, 1*0.5]);\n  spiritId = buttonMaker.addButton(0, -8, \"START\", function(e) {\n    var freq0 = 100;\n    var freq1 = 5000;\n    var delay = 0;\n    var attack = 0.01;\n    var sustain = 0.1;\n    var decay = 0.04;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.gotoScreen(Test36.SCREEN_PLAY);\n    // controller.requestPointerLock();\n  });\n  this.playSpirit = this.world.spirits[spiritId];\n\n  // FULL SCREEN\n  buttonMaker.setScale(0.75);\n  spiritId = buttonMaker.addButton(0, -8 -6, \"FULL SCREEN\", function(e) {\n    var freq0 = 200;\n    var freq1 = 2200;\n    var delay = 0;\n    var attack = 0.05;\n    var sustain = 0.1;\n    var decay = 0.2;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    // controller.requestFullScreen();\n  });\n  this.fullScreenSpirit = world.spirits[spiritId];\n\n  for (spiritId in this.world.spirits) {\n    var s = this.world.spirits[spiritId];\n    var b = this.world.bodies[s.bodyId];\n    this.worldBoundingRect.coverRect(b.getBoundingRectAtTime(this.world.now));\n  }\n  this.worldBoundingRect.pad(1);\n};\n\nTitleScreen.prototype.onSpaceDown = function() {\n  this.playSpirit.onClick();\n};\n\nTitleScreen.prototype.onPointerDown = function(pageX, pageY) {\n  this.vec2d.setXY(pageX, pageY);\n  this.transformCanvasToWorld(this.vec2d);\n  if (this.playSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.playSpirit.onClick();\n  }\n  if (this.fullScreenSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.fullScreenSpirit.onClick();\n  }\n};\n\nTitleScreen.prototype.updateViewMatrix = function() {\n  var br = this.worldBoundingRect;\n  this.viewMatrix.toIdentity();\n  var ratio = Math.min(this.canvas.height, this.canvas.width) / Math.max(br.rad.x, br.rad.y);\n  this.viewMatrix\n      .multiply(this.mat4.toScaleOpXYZ(\n              ratio / this.canvas.width,\n              ratio / this.canvas.height,\n              0.2));\n\n  // scale\n  var v = this.visibility;\n  this.viewMatrix.multiply(this.mat4.toScaleOpXYZ(3 - v*2, v * v, 1));\n\n  // center\n  this.viewMatrix.multiply(this.mat4.toTranslateOpXYZ(\n      -br.pos.x,\n      -br.pos.y,\n      0));\n\n  this.renderer.setViewMatrix(this.viewMatrix);\n};\n\n\n/* ---- js/playscreen.js ---- */\n\n\n/**\n * @constructor\n * @extends {BaseScreen}\n */\nfunction PlayScreen(controller, canvas, renderer, glyphs, stamps, sfx) {\n  BaseScreen.call(this, controller, canvas, renderer, glyphs, stamps, sfx);\n\n  this.listeners = new ArraySet();\n  this.splasher = new Splasher();\n  this.splash = new Splash();\n\n  this.modelMatrix = new Matrix44();\n  this.modelMatrix2 = new Matrix44();\n  this.hudViewMatrix = new Matrix44();\n\n  this.scanReq = new ScanRequest();\n  this.scanResp = new ScanResponse();\n\n  this.camera = new Camera(0.2, 0.6, 35);\n  this.updateViewMatrix();\n  this.renderer.setViewMatrix(this.viewMatrix);\n\n  var self = this;\n\n  this.eventDistributor = new LayeredEventDistributor(this.canvas, 3);\n  this.addListener(this.eventDistributor);\n\n  this.pauseTriggerWidget = new TriggerWidget(this.getHudEventTarget())\n      .setCanvasScaleXY(20, 20)\n      .setReleasedColorVec4(new Vec4(1, 1, 1, 0.5))\n      .setPressedColorVec4(new Vec4(1, 1, 1, 1))\n      .listenToTouch()\n      .listenToMousePointer()\n      .addTriggerKeyByName(Key.Name.SPACE)\n      .startListening();\n\n  this.pauseDownFn = function(e) {\n    e = e || window.event;\n    self.paused = !self.paused;\n    if (self.paused) {\n\t\t\n      // pause\n      // self.showPausedOverlay();\n\t  \n      self.updateSharableUrl();\n    } else {\n\t\t\n      // resume\n      // self.hidePausedOverlay();\n\t  \n      self.controller.requestAnimation();\n      // TODO: clear the pause button's val\n    }\n    // Stop the flow of mouse-emulation events on touchscreens, so the\n    // mouse events don't cause weird cursors teleports.\n    // See http://www.html5rocks.com/en/mobile/touchandmouse/#toc-together\n    e.preventDefault();\n  };\n\n  this.fullScreenFn = function(e) {\n    e = e || window.event;\n    self.controller.requestFullScreen();\n    e.preventDefault();\n  };\n\n  // for sound throttling\n  this.hitsThisFrame = 0;\n\n  this.world = null;\n  this.tiles = null;\n\n  this.bitSize = 0.5;\n  this.bitGridMetersPerCell = PlayScreen.BIT_SIZE * BitGrid.BITS;\n  this.levelModelMatrix = new Matrix44();\n  this.levelColorVector = new Vec4(1, 1, 1);\n\n  this.levelStamps = [];\n  this.initialized = false;\n}\nPlayScreen.prototype = new BaseScreen();\nPlayScreen.prototype.constructor = PlayScreen;\n\nPlayScreen.BIT_SIZE = 0.5;\nPlayScreen.WORLD_CELL_SIZE = PlayScreen.BIT_SIZE * BitGrid.BITS;\n\nPlayScreen.ANT_RAD = 0.8;\nPlayScreen.ROCK_RAD = 1.4;\n\nPlayScreen.MenuItem = {\n  ROCK: 'rock',\n  RED_ANT: 'red_ant'\n};\n\nPlayScreen.EventLayer = {\n  POPUP: 0,\n  HUD: 1,\n  WORLD: 2\n};\n\nPlayScreen.Group = {\n  EMPTY: 0,\n  WALL: 1,\n  ROCK: 2,\n  CURSOR: 3\n};\n\nPlayScreen.Terrain = {\n  WALL: 0,\n  FLOOR: 1,\n  MIXED: 2\n};\n\nPlayScreen.SpiritType = {\n  BALL: 1,\n  SOUND: 2,\n  ANT: 3\n};\n\nPlayScreen.SplashType = {\n  NOTE: 1\n};\n\nPlayScreen.prototype.initEditor = function() {\n  this.rockModel = RigidModel.createCircleMesh(5);\n  this.rockStamp = this.rockModel.createModelStamp(this.renderer.gl);\n  this.levelStamps.push(this.rockStamp);\n\n  this.antModel = RigidModel.createCircleMesh(4)\n      .addRigidModel(RigidModel.createSquare()\n          .transformPositions(new Matrix44().toScaleOpXYZ(0.1, 0.5, 1))\n          .transformPositions(new Matrix44().toTranslateOpXYZ(0, 1, 0))\n          .transformPositions(new Matrix44().toRotateZOp(Math.PI / 8)))\n      .addRigidModel(RigidModel.createSquare()\n          .transformPositions(new Matrix44().toScaleOpXYZ(0.1, 0.5, 1))\n          .transformPositions(new Matrix44().toTranslateOpXYZ(0, 1, 0))\n          .transformPositions(new Matrix44().toRotateZOp(-Math.PI / 8)));\n  this.antStamp = this.antModel.createModelStamp(this.renderer.gl);\n  this.levelStamps.push(this.antStamp);\n\n  this.editor = new Editor(this, this.canvas, this.renderer, this.glyphs);\n  this.editor.addMenuItem(0, 0, PlayScreen.MenuItem.ROCK, this.rockModel);\n  this.editor.addMenuItem(1, 0, PlayScreen.MenuItem.RED_ANT, this.antModel);\n  for (var group = 0; group < 2; group++) {\n    this.editor.addMenuKeyboardShortcut(group, group + 1);\n  }\n\n};\n\nPlayScreen.prototype.updateHudLayout = function() {\n  this.pauseTriggerWidget.setCanvasPositionXY(this.canvas.width - 20, 20);\n  this.editor.updateHudLayout();\n};\n\n\nPlayScreen.prototype.updateSharableUrl = function() {\n  var levelJson = this.toJSON();\n  var squisher = new Squisher();\n  var anchor = document.querySelector('#sharableUrl');\n  var hashString = squisher.squish(JSON.stringify(levelJson));\n  var hash = document.createElement('button');\n  hash.id = 'hashstring';\n  hash.style.color = '#A09060';\n  hash.innerHTML = 'save map';\n  // window.location.href.split(\"#\")[0] + \"#\" + hashString;\n  var div = document.createElement('div');\n  div.id = 'urldiv';\n  div.setAttribute('style', 'position: absolute; top: 3px; left: 250px; z-index: 1001; display: block');\n  div.onmouseover = alert(\"pending: map save function\"); // saveHash(\"#\" + hashString);\n  div.appendChild(hash);\n  document.body.appendChild(div);\n};\n\n\nPlayScreen.prototype.setScreenListening = function(listen) {\n  if (listen == this.listening) return;\n  var rb, i;\n  BaseScreen.prototype.setScreenListening.call(this, listen);\n  if (listen) {\n    for (i = 0; i < this.listeners.vals.length; i++) {\n      this.listeners.vals[i].startListening();\n    }\n    this.pauseTriggerWidget.addTriggerDownListener(this.pauseDownFn);\n\n\t/*\n    fsb = document.querySelector('#fullScreenButton');\n    fsb.addEventListener('click', this.fullScreenFn);\n    fsb.addEventListener('touchend', this.fullScreenFn);\n\n    rb = document.querySelector('#resumeButton');\n    rb.addEventListener('click', this.pauseDownFn);\n    rb.addEventListener('touchend', this.pauseDownFn);\n\t*/\n\t\n  } else {\n    for (i = 0; i < this.listeners.vals.length; i++) {\n      this.listeners.vals[i].stopListening();\n    }\n    this.pauseTriggerWidget.removeTriggerDownListener(this.pauseDownFn);\n\t\n\t/*\n    fsb = document.querySelector('#fullScreenButton');\n    fsb.removeEventListener('click', this.fullScreenFn);\n    fsb.removeEventListener('touchend', this.fullScreenFn);\n\n    rb = document.querySelector('#resumeButton');\n    rb.removeEventListener('click', this.pauseDownFn);\n    rb.removeEventListener('touchend', this.pauseDownFn);\n\t*/\n  }\n  this.listening = listen;\n};\n\nPlayScreen.prototype.lazyInit = function() {\n  if (!this.initialized) {\n    this.initEditor();\n    this.updateHudLayout();\n    this.initPermStamps();\n    this.initWorld();\n    this.initialized = true;\n  }\n};\n\nPlayScreen.prototype.initPermStamps = function() {\n  this.cubeStamp = RigidModel.createCube().createModelStamp(this.renderer.gl);\n  this.levelStamps.push(this.cubeStamp);\n\n  var pauseModel = new RigidModel();\n  for (var x = -1; x <= 1; x+=2) {\n    pauseModel.addRigidModel(RigidModel.createSquare().transformPositions(\n        new Matrix44()\n            .multiply(new Matrix44().toScaleOpXYZ(0.2, 0.6, 1)\n            .multiply(new Matrix44().toTranslateOpXYZ(x*1.9, 0, 0)\n    ))));\n  }\n  this.pauseStamp = pauseModel.createModelStamp(this.renderer.gl);\n  this.levelStamps.push(this.pauseStamp);\n  this.pauseTriggerWidget.setStamp(this.pauseStamp);\n\n  var model = RigidModel.createDoubleRing(64);\n  this.soundStamp = model.createModelStamp(this.renderer.gl);\n  this.levelStamps.push(this.soundStamp);\n\n  var editorStamps = this.editor.getStamps();\n  for (var i = 0; i < editorStamps.length; i++) {\n    this.levelStamps.push(editorStamps[i]);\n  }\n};\n\nPlayScreen.prototype.initWorld = function() {\n  this.lastPathRefreshTime = -Infinity;\n  var groupCount = Object.keys(PlayScreen.Group).length;\n  this.world = new World(PlayScreen.WORLD_CELL_SIZE, groupCount, [\n    [PlayScreen.Group.EMPTY, PlayScreen.Group.EMPTY],\n    [PlayScreen.Group.ROCK, PlayScreen.Group.WALL],\n    [PlayScreen.Group.ROCK, PlayScreen.Group.ROCK],\n    [PlayScreen.Group.CURSOR, PlayScreen.Group.WALL],\n    [PlayScreen.Group.CURSOR, PlayScreen.Group.ROCK]\n  ]);\n  this.resolver = new HitResolver();\n  this.resolver.defaultElasticity = 0.8;\n  var frag = Url.getFragment();\n  if (!frag || !this.maybeLoadWorldFromFragment(frag)) {\n    this.createDefaultWorld();\n  }\n};\n\nPlayScreen.prototype.toJSON = function() {\n  var json = {\n    terrain: this.bitGrid.toJSON(),\n    now: this.world.now,\n    bodies: [],\n    spirits: [],\n    timeouts: [],\n    splashes: [],\n    cursorPos: this.editor.cursorPos.toJSON(),\n    cameraPos: this.camera.cameraPos.toJSON()\n  };\n  // bodies\n  for (var bodyId in this.world.bodies) {\n    var body = this.world.bodies[bodyId];\n    if (body.hitGroup != PlayScreen.Group.WALL) {\n      json.bodies.push(body.toJSON());\n    }\n  }\n  // spirits\n  for (var spiritId in this.world.spirits) {\n    var spirit = this.world.spirits[spiritId];\n    json.spirits.push(spirit.toJSON());\n  }\n  // timeouts\n  for (var e = this.world.queue.getFirst(); e; e = e.next[0]) {\n    if (e.type === WorldEvent.TYPE_TIMEOUT) {\n      var spirit = this.world.spirits[e.spiritId];\n      if (spirit) {\n        json.timeouts.push(e.toJSON());\n      }\n    }\n  }\n  // splashes\n  var splashes = this.splasher.splashes;\n  for (var i = 0; i < splashes.length; i++) {\n    json.splashes.push(splashes[i].toJSON());\n  }\n  return json;\n};\n\nPlayScreen.prototype.maybeLoadWorldFromFragment = function(frag) {\n  try {\n    var squisher = new Squisher();\n    var jsonStr = squisher.unsquish(frag);\n    var jsonObj = JSON.parse(jsonStr);\n  } catch (e) {\n    console.error(\"maybeLoadWorldFromFragment error\", e);\n    return false;\n  }\n  if (jsonObj) {\n    this.world.now = jsonObj.now;\n    // bodies\n    for (var i = 0; i < jsonObj.bodies.length; i++) {\n      var bodyJson = jsonObj.bodies[i];\n      var body = new Body();\n      body.setFromJSON(bodyJson);\n      this.world.loadBody(body);\n    }\n    // spirits\n    for (var i = 0; i < jsonObj.spirits.length; i++) {\n      var spiritJson = jsonObj.spirits[i];\n      var spiritType = spiritJson[0];\n      if (spiritType == PlayScreen.SpiritType.BALL) {\n        var spirit = new BallSpirit(this);\n        spirit.setModelStamp(this.rockStamp);\n        spirit.setFromJSON(spiritJson);\n        this.world.loadSpirit(spirit);\n      } else if (spiritType == PlayScreen.SpiritType.SOUND) {\n        var spirit = new SoundSpirit(this);\n        spirit.setModelStamp(this.rockStamp);\n        spirit.setFromJSON(spiritJson);\n        this.world.loadSpirit(spirit);\n      } else if (spiritType == PlayScreen.SpiritType.ANT) {\n        var spirit = new AntSpirit(this);\n        spirit.setModelStamp(this.antStamp);\n        spirit.setFromJSON(spiritJson);\n        this.world.loadSpirit(spirit);\n      } else {\n        console.error(\"Unknown spiritType \" + spiritType + \" in spirit JSON: \" + spiritJson);\n      }\n    }\n    // timeouts\n    var e = new WorldEvent();\n    for (var i = 0; i < jsonObj.timeouts.length; i++) {\n      e.setFromJSON(jsonObj.timeouts[i]);\n      this.world.loadTimeout(e);\n    }\n    // splashes\n    var splash = new Splash();\n    for (var i = 0; i < jsonObj.splashes.length; i++) {\n      var splashJson = jsonObj.splashes[i];\n      var splashType = splashJson[0];\n      if (splashType == PlayScreen.SplashType.NOTE) {\n        splash.setFromJSON(splashJson);\n        splash.stamp = this.soundStamp;\n        this.splasher.addCopy(splash);\n      } else {\n        console.error(\"Unknown splashType \" + splashType + \" in spirit JSON: \" + splashJson);\n      }\n    }\n    // terrain\n    this.bitGrid = BitGrid.fromJSON(jsonObj.terrain);\n    this.tiles = {};\n    this.flushTerrainChanges();\n\n    // cursor and camera\n    this.editor.cursorPos.set(Vec2d.fromJSON(jsonObj.cursorPos));\n    this.camera.cameraPos.set(Vec2d.fromJSON(jsonObj.cameraPos));\n  }\n  return true;\n};\n\nPlayScreen.prototype.createDefaultWorld = function() {\n  var count = 16;\n  for (var i = 0; i < count; i++) {\n    this.initSoundSpirit(\n        new Vec2d(i/count * 60 - 30, 0),\n        0.9,\n        (i + (Math.random() < 0.33 ? (1.05 - Math.random() * 0.1) : 0))/count);\n    this.initAntSpirit(new Vec2d(i/count * 60 - 30, -5), PlayScreen.ANT_RAD);\n  }\n  this.initRock(new Vec2d(40, 0), PlayScreen.ROCK_RAD);\n  this.initRock(new Vec2d(-40, 0), PlayScreen.ROCK_RAD);\n  this.initWalls();\n};\n\nPlayScreen.prototype.initAntSpirit = function(pos, rad) {\n  var density = 1;\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.setPosAtTime(pos, this.world.now);\n  b.rad = rad;\n  b.hitGroup = PlayScreen.Group.ROCK;\n  b.mass = (Math.PI * 4/3) * b.rad * b.rad * b.rad * density;\n  b.pathDurationMax = AntSpirit.MEASURE_TIMEOUT * 2;\n  var spirit = new AntSpirit(this);\n  spirit.bodyId = this.world.addBody(b);\n  spirit.setModelStamp(this.antStamp);\n  var spiritId = this.world.addSpirit(spirit);\n  b.spiritId = spiritId;\n  this.world.spirits[spiritId].setColorRGB(1, 0, 0);\n  this.world.addTimeout(this.world.now, spiritId, -1);\n  return spiritId;\n};\n\nPlayScreen.prototype.initRock = function(pos, rad) {\n  var density = 1;\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.setPosAtTime(pos, this.world.now);\n  b.rad = rad;\n  b.hitGroup = PlayScreen.Group.ROCK;\n  b.mass = (Math.PI * 4/3) * b.rad * b.rad * b.rad * density;\n  b.pathDurationMax = BallSpirit.MEASURE_TIMEOUT;\n  var spirit = new BallSpirit();\n  spirit.bodyId = this.world.addBody(b);\n  spirit.setModelStamp(this.rockStamp);\n  var spiritId = this.world.addSpirit(spirit);\n  b.spiritId = spiritId;\n  this.world.spirits[spiritId].setColorRGB(1, 0.2, 0.6);\n  this.world.addTimeout(this.world.now, spiritId, -1);\n  return spiritId;\n};\n\nPlayScreen.prototype.initSoundSpirit = function(pos, rad, measureFraction) {\n  var density = 1;\n  var b = Body.alloc();\n  b.shape = Body.Shape.CIRCLE;\n  b.setPosAtTime(pos, this.world.now);\n  b.rad = rad;\n  b.hitGroup = PlayScreen.Group.ROCK;\n  b.mass = (Math.PI * 4/3) * b.rad * b.rad * b.rad * density;\n  b.pathDurationMax = SoundSpirit.MEASURE_TIMEOUT * 2;\n  var spirit = new SoundSpirit(this);\n  spirit.bodyId = this.world.addBody(b);\n  spirit.setModelStamp(this.rockStamp);\n\n  var high = Math.random() < 0.5;\n  var hard = Math.random() < 0.5;\n  var low = !high && hard && Math.random() < 0.5;\n\n  var maxPow = 2;\n  var notes = 4 * maxPow;\n  var rand = 2;\n  var base = 7 + (low ? -1 : 0) + (high ? 2 : 0);\n  var f = Math.pow(2, base + Math.floor((high ? 1-Math.random()/2 : Math.random()) * notes)/notes * maxPow);\n  spirit.setSounds([\n      [\n        measureFraction,\n        hard ? 2 : 1,\n        0, low ? 0.2 : 0, 0.2 + 0.1 * Math.random(),\n        f + (Math.random() - 0.5) * rand, f,\n        low || hard ? 'square' : 'sine'\n      ],\n      [\n        measureFraction,\n        hard ? 2 : 1,\n        0, low ? 0.2 : 0, 0.2 + 0.1 * Math.random(),\n        f*2 + (Math.random() - 0.5) * rand, f*2,\n        'sine'\n      ],\n      [\n        measureFraction,\n        hard ? 2 : 1,\n        0, low ? 0.2 : 0, 0.2 + 0.1 * Math.random(),\n        f*3 + (Math.random() - 0.5) * rand, f*3,\n        'triangle'\n      ]\n  ]);\n  var spiritId = this.world.addSpirit(spirit);\n  b.spiritId = spiritId;\n  this.world.spirits[spiritId].setColorRGB(0, 1, hard ? 1 : 0);\n  this.world.spirits[spiritId].hard = hard;\n  this.world.addTimeout(this.world.now, spiritId, -1);\n\n  return spiritId;\n};\n\nPlayScreen.prototype.initWalls = function() {\n  function randVec() {\n    return new Vec2d(Math.random()-0.5, Math.random()-0.5).scale(100);\n  }\n  this.bitGrid = new BitGrid(this.bitSize);\n  this.bitGrid.drawPill(new Segment(new Vec2d(-50, 0), new Vec2d(50, 0)), 10, 1);\n  for (var i = 0; i < 16; i++) {\n    this.bitGrid.drawPill(new Segment(randVec(), randVec()), 2, 1);\n  }\n\n  this.tiles = {};\n  this.flushTerrainChanges();\n};\n\nPlayScreen.prototype.digTerrainAtPos = function(pos) {\n  this.bitGrid.drawPill(new Segment(pos, pos), 15, 1);\n  this.flushTerrainChanges();\n};\n\nPlayScreen.prototype.flushTerrainChanges = function() {\n  var changedCellIds = this.bitGrid.flushChangedCellIds();\n  for (var i = 0; i < changedCellIds.length; i++) {\n    this.changeTerrain(changedCellIds[i]);\n  }\n};\n\n/**\n * The cell at the cellId definitely changes, so unload it and reload it.\n * Make sure the four cardinal neighbors are also loaded.\n * @param cellId\n */\nPlayScreen.prototype.changeTerrain = function(cellId) {\n  var center = Vec2d.alloc();\n  this.bitGrid.cellIdToIndexVec(cellId, center);\n  this.loadCellXY(center.x - 1, center.y);\n  this.loadCellXY(center.x + 1, center.y);\n  this.loadCellXY(center.x, center.y - 1);\n  this.loadCellXY(center.x, center.y + 1);\n  this.unloadCellXY(center.x, center.y);\n  this.loadCellXY(center.x, center.y);\n  center.free();\n};\n\nPlayScreen.prototype.loadCellXY = function(cx, cy) {\n  var cellId = this.bitGrid.getCellIdAtIndexXY(cx, cy);\n  var tile = this.tiles[cellId];\n  if (!tile) {\n    this.tiles[cellId] = tile = {\n      cellId: cellId,\n      stamp: null,\n      bodyIds: null\n    };\n  }\n  if (!tile.bodyIds) {\n    tile.bodyIds = [];\n    // Create wall bodies and remember their IDs.\n    var rects = this.bitGrid.getRectsOfColorForCellId(0, cellId);\n    for (var r = 0; r < rects.length; r++) {\n      var rect = rects[r];\n      var body = this.createWallBody(rect);\n      tile.bodyIds.push(this.world.addBody(body));\n    }\n  }\n  // TODO don't repeat stamp for solid walls\n  if (!tile.stamp) {\n    if (!rects) rects = this.bitGrid.getRectsOfColorForCellId(0, cellId);\n    tile.stamp = this.createTileStamp(rects);\n  }\n};\n\nPlayScreen.prototype.unloadCellXY = function(cx, cy) {\n  this.unloadCellId(this.bitGrid.getCellIdAtIndexXY(cx, cy));\n};\n\nPlayScreen.prototype.unloadCellId = function(cellId) {\n  var tile = this.tiles[cellId];\n  if (!tile) return;\n  if (tile.stamp) {\n    tile.stamp.dispose(this.renderer.gl);\n    tile.stamp = null;\n  }\n  if (tile.bodyIds) {\n    for (var i = 0; i < tile.bodyIds.length; i++) {\n      var id = tile.bodyIds[i];\n      this.world.removeBodyId(id);\n    }\n    tile.bodyIds = null;\n  }\n};\n\n/**\n * Creates a body, but does not add it to the world.\n */\nPlayScreen.prototype.createWallBody = function(rect) {\n  var b = Body.alloc();\n  b.shape = Body.Shape.RECT;\n  b.setPosAtTime(rect.pos, this.world.now);\n  b.rectRad.set(rect.rad);\n  b.hitGroup = PlayScreen.Group.WALL;\n  b.mass = Infinity;\n  b.pathDurationMax = Infinity;\n  return b;\n};\n\nPlayScreen.prototype.createTileStamp = function(rects) {\n  var model = new RigidModel();\n  for (var i = 0; i < rects.length; i++) {\n    model.addRigidModel(this.createWallModel(rects[i]));\n  }\n  return model.createModelStamp(this.renderer.gl);\n};\n\nPlayScreen.prototype.createWallModel = function(rect) {\n  var transformation, wallModel;\n  transformation = new Matrix44()\n      .toTranslateOpXYZ(rect.pos.x, rect.pos.y, 0)\n      .multiply(new Matrix44().toScaleOpXYZ(rect.rad.x, rect.rad.y, 1));\n  wallModel = RigidModel.createSquare().transformPositions(transformation);\n  wallModel.setColorRGB(0.2, 0.3, 0.6);\n//  wallModel.setColorRGB(Math.random()/2+0.3 , Math.random() * 0.5, Math.random()/2+0.5);\n  return wallModel;\n};\n\nPlayScreen.prototype.addNoteSplash = function(x, y, dx, dy, r, g, b, bodyRad) {\n  var fullRad = bodyRad * 2;// * (1+Math.random()/2);\n  var s = this.splash;\n  s.reset(PlayScreen.SplashType.NOTE, this.soundStamp);\n\n  s.startTime = this.world.now;\n  s.duration = 10;\n\n  s.startPose.pos.setXYZ(x, y, 0);\n  s.endPose.pos.setXYZ(x + dx * s.duration, y + dy * s.duration, 1);\n  s.startPose.scale.setXYZ(fullRad, fullRad, 1);\n  s.endPose.scale.setXYZ(fullRad*2, fullRad*2, 1);\n\n  s.startPose2.pos.setXYZ(x, y, 0);\n  s.endPose2.pos.setXYZ(x + dx * s.duration, y + dy * s.duration, 1);\n  s.startPose2.scale.setXYZ(fullRad*0.5, fullRad*0.5, 1);\n  s.endPose2.scale.setXYZ(fullRad*1.9, fullRad*1.9, 1);\n\n  s.startPose.rotZ = s.startPose2.rotZ = Math.PI * 2 * Math.random();\n  s.endPose.rotZ = s.endPose2.rotZ = s.startPose.rotZ + 0.3 * Math.PI * (Math.random() - 0.5);\n\n  s.startColor.setXYZ(r, g, b);\n  s.endColor.setXYZ(r, g, b);\n\n  s.duration = 8;\n  s.endPose.rotZ = s.endPose2.rotZ =s.startPose2.rotZ;\n  this.splasher.addCopy(s);\n};\n\nPlayScreen.prototype.onHitEvent = function(e) {\n  var b0 = this.world.getBodyByPathId(e.pathId0);\n  var b1 = this.world.getBodyByPathId(e.pathId1);\n  if (b0 && b1) {\n    this.resolver.resolveHit(e.time, e.collisionVec, b0, b1);\n  }\n};\n\nPlayScreen.prototype.bodyIfInGroup = function(group, b0, b1) {\n  if (b0 && b0.hitGroup == group) return b0;\n  if (b1 && b1.hitGroup == group) return b1;\n  return null;\n};\n\nPlayScreen.prototype.updateViewMatrix = function() {\n  // scale\n  this.viewMatrix.toIdentity();\n  var pixelsPerMeter = 0.5 * (this.canvas.height + this.canvas.width) / this.camera.getViewDist();\n  this.viewMatrix\n      .multiply(this.mat44.toScaleOpXYZ(\n              pixelsPerMeter / this.canvas.width,\n              pixelsPerMeter / this.canvas.height,\n          0.2));\n\n  // center\n  this.viewMatrix.multiply(this.mat44.toTranslateOpXYZ(\n      -this.camera.getX(),\n      -this.camera.getY(),\n      0));\n};\n\nPlayScreen.prototype.handleInput = function () {\n  if (!this.world) return;\n  this.editor.handleInput();\n};\n\nPlayScreen.prototype.drawScene = function() {\n  this.renderer.setViewMatrix(this.viewMatrix);\n  this.hitsThisFrame = 0;\n  for (var id in this.world.spirits) {\n    this.world.spirits[id].onDraw(this.world, this.renderer);\n  }\n\n  this.sfx.setListenerXYZ(this.editor.cursorPos.x, this.editor.cursorPos.y, 5);\n\n  if (this.tiles) {\n    this.renderer\n        .setColorVector(this.levelColorVector)\n        .setModelMatrix(this.levelModelMatrix);\n    var cx = Math.round((this.camera.getX() - this.bitGrid.cellWorldSize/2) / (this.bitGrid.cellWorldSize));\n    var cy = Math.round((this.camera.getY() - this.bitGrid.cellWorldSize/2) / (this.bitGrid.cellWorldSize));\n    var pixelsPerMeter = 0.5 * (this.canvas.height + this.canvas.width) / this.camera.getViewDist();\n    var pixelsPerCell = this.bitGridMetersPerCell * pixelsPerMeter;\n    var cellsPerScreenX = this.canvas.width / pixelsPerCell;\n    var cellsPerScreenY = this.canvas.height / pixelsPerCell;\n    var rx = Math.ceil(cellsPerScreenX);\n    var ry = Math.ceil(cellsPerScreenY);\n    for (var dy = -ry; dy <= ry; dy++) {\n      for (var dx = -rx; dx <= rx; dx++) {\n        this.loadCellXY(cx + dx, cy + dy);\n        var cellId = this.bitGrid.getCellIdAtIndexXY(cx + dx, cy + dy);\n        var tile = this.tiles[cellId];\n        if (tile && tile.stamp) {\n          this.renderer\n              .setStamp(tile.stamp)\n              .drawStamp();\n        }\n      }\n    }\n  }\n  this.splasher.draw(this.renderer, this.world.now);\n  this.editor.drawScene();\n  this.drawHud();\n  this.configMousePointer();\n\n  if (this.restarting) {\n    this.controller.restart();\n    this.restarting = false;\n  } else {\n    // Animate whenever this thing draws.\n    if (!this.paused) {\n      this.controller.requestAnimation();\n    }\n  }\n};\n\nPlayScreen.prototype.drawHud = function() {\n  this.hudViewMatrix.toIdentity()\n      .multiply(this.mat44.toScaleOpXYZ(\n              2 / this.canvas.width,\n              -2 / this.canvas.height,\n          1))\n      .multiply(this.mat44.toTranslateOpXYZ(-this.canvas.width/2, -this.canvas.height/2, 0));\n  this.renderer.setViewMatrix(this.hudViewMatrix);\n\n  this.updateHudLayout();\n  this.renderer.setBlendingEnabled(true);\n  this.pauseTriggerWidget.draw(this.renderer);\n  this.editor.drawHud();\n  this.renderer.setBlendingEnabled(false);\n};\n\nPlayScreen.prototype.configMousePointer = function() {\n  if (this.pauseTriggerWidget.isMouseHovered()) {\n    this.canvas.style.cursor = \"auto\"\n  } else if (this.paused) {\n    this.canvas.style.cursor = \"\";\n  } else {\n    this.canvas.style.cursor = \"crosshair\";\n  }\n};\n\nPlayScreen.prototype.getPauseTriggerColorVector = function() {\n  this.colorVector.setRGBA(1, 1, 1, this.paused ? 0 : 0.1);\n  return this.colorVector;\n};\n\nPlayScreen.prototype.unloadLevel = function() {\n  if (this.tiles) {\n    for (var cellId in this.tiles) {\n      this.unloadCellId(cellId);\n    }\n    this.tiles = null;\n  }\n  if (this.world) {\n    for (var spiritId in this.world.spirits) {\n      var s = this.world.spirits[spiritId];\n      var b = this.world.bodies[s.bodyId];\n      this.world.removeBodyId(b.id);\n      this.world.removeSpiritId(spiritId);\n    }\n    this.world = null;\n  }\n  this.editor.cursorPos.reset();\n  this.editor.cursorVel.reset();\n  this.camera.setXY(0, 0);\n};\n\nPlayScreen.prototype.showPausedOverlay = function() {\n  document.querySelector('#pausedOverlay').style.display = 'block';\n  this.canvas.style.cursor = \"auto\";\n};\n\nPlayScreen.prototype.hidePausedOverlay = function() {\n  document.querySelector('#pausedOverlay').style.display = 'none';\n  this.canvas.style.cursor = \"\";\n};\n\n/////////////////////\n// Editor API stuff\n/////////////////////\n\nPlayScreen.prototype.getBodyPos = function(body, outVec2d) {\n  return body.getPosAtTime(this.world.now, outVec2d);\n};\n\nPlayScreen.prototype.getCanvas = function() {\n  return this.canvas;\n};\n\nPlayScreen.prototype.addListener = function(listener) {\n  this.listeners.put(listener);\n  if (this.listening) {\n    listener.startListening();\n  }\n};\n\nPlayScreen.prototype.getBodyOverlaps = function(body) {\n  return this.world.getOverlaps(body);\n};\n\nPlayScreen.prototype.getBodyById = function(id) {\n  return this.world.bodies[id];\n};\n\nPlayScreen.prototype.drawTerrainPill = function(pos0, pos1, rad, color) {\n  this.bitGrid.drawPill(new Segment(pos0, pos1), rad, color);\n  this.flushTerrainChanges();\n};\n\nPlayScreen.prototype.addItem = function(name, pos) {\n  switch (name) {\n    case PlayScreen.MenuItem.ROCK:\n      this.initRock(pos, PlayScreen.ROCK_RAD);\n      break;\n    case PlayScreen.MenuItem.RED_ANT:\n      this.initAntSpirit(pos, PlayScreen.ANT_RAD);\n      break;\n  }\n};\n\nPlayScreen.prototype.removeByBodyId = function(bodyId) {\n  var body = this.world.getBody(bodyId);\n  if (body) {\n    if (body.spiritId) {\n      this.world.removeSpiritId(body.spiritId);\n    }\n    this.world.removeBodyId(bodyId);\n  }\n};\n\nPlayScreen.prototype.getCursorHitGroup = function() {\n  return PlayScreen.Group.CURSOR;\n};\n\nPlayScreen.prototype.getWallHitGroup = function() {\n  return PlayScreen.Group.WALL;\n};\n\nPlayScreen.prototype.getWorldTime = function() {\n  return this.world.now;\n};\n\nPlayScreen.prototype.getViewDist = function() {\n  return this.camera.getViewDist();\n};\n\nPlayScreen.prototype.getViewMatrix = function() {\n  return this.viewMatrix;\n};\n\nPlayScreen.prototype.getPopupEventTarget = function() {\n  return this.eventDistributor.getFakeLayerElement(PlayScreen.EventLayer.POPUP);\n};\n\nPlayScreen.prototype.getHudEventTarget = function() {\n  return this.eventDistributor.getFakeLayerElement(PlayScreen.EventLayer.HUD);\n};\n\nPlayScreen.prototype.getWorldEventTarget = function() {\n  return this.eventDistributor.getFakeLayerElement(PlayScreen.EventLayer.WORLD);\n};\n\n/////////////////\n// Spirit APIs //\n/////////////////\n\n/**\n * @param {number} hitGroup\n * @param {Vec2d} pos\n * @param {Vec2d} vel\n * @param {number} rad\n * @returns {number} fraction (0-1) of vel where the hit happened, or -1 if there was no hit.\n */\nPlayScreen.prototype.scan = function(hitGroup, pos, vel, rad) {\n  this.scanReq.hitGroup = hitGroup;\n  // write the body's position into the req's position slot.\n  this.scanReq.pos.set(pos);\n  this.scanReq.vel.set(vel);\n  this.scanReq.shape = Body.Shape.CIRCLE;\n  this.scanReq.rad = rad;\n  var retval = -1;\n  var hit = this.world.rayscan(this.scanReq, this.scanResp);\n  if (hit) {\n    retval = this.scanResp.timeOffset;\n  }\n  return retval;\n};\n\n\n\n/* ---- js/pausescreen.js ---- */\n\n\n\n/**\n * @constructor\n * @extends {BaseScreen}\n */\nfunction PauseScreen(controller, canvas, renderer, glyphs, stamps, sound) {\n  BaseScreen.call(this, controller, canvas, renderer, glyphs, stamps, sound);\n}\nPauseScreen.prototype = new BaseScreen();\nPauseScreen.prototype.constructor = PauseScreen;\n\nPauseScreen.prototype.lazyInit = function() {\n  if (!this.world) {\n    this.initWorld();\n  }\n};\n\nPauseScreen.prototype.onSpaceDown = function() {\n  this.resumeSpirit.onClick();\n};\n\nPauseScreen.prototype.onPointerDown = function(pageX, pageY) {\n  this.vec2d.setXY(pageX, pageY);\n  this.transformCanvasToWorld(this.vec2d);\n  if (this.resumeSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.resumeSpirit.onClick();\n  }\n  if (this.fullScreenSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.fullScreenSpirit.onClick();\n  }\n  if (this.quitSpirit.isOverlapping(this.world, this.vec2d)) {\n    this.quitSpirit.onClick();\n  }\n};\n\nPauseScreen.prototype.initWorld = function() {\n  this.world = new World(World.DEFAULT_CELL_SIZE, 2, [[0, 0], [1, 1]]);\n  this.resolver = new HitResolver();\n  this.resolver.defaultElasticity = 0.9;\n  var labelMaker = new LabelMaker(this.glyphs);\n  var controller = this.controller;\n  var sfx = this.sfx;\n  var world = this.world;\n\n  var red = 0.75, green = 0.25, blue = 0.0;\n\n  var buttonMaker = new ButtonMaker(labelMaker, this.world, null, this.renderer);\n  buttonMaker\n      .setNextCharMatrix(new Matrix44().toTranslateOpXYZ(3, 0, 0))\n      .setPaddingXY(1.5, 0.5);\n\n  buttonMaker.setLetterColor([red*0.7, green*0.7, blue*0.7]).setBlockColor(null);\n  buttonMaker.addButton(0, 0, \"PAUSED\", null);\n\n  var spiritId;\n\n  // RESUME\n  buttonMaker.setLetterColor([red, green, blue]).setBlockColor([red*0.5, green*0.5, blue*0.5]);\n  spiritId = buttonMaker.addButton(0, -8, \"RESUME\", function(e) {\n    var freq0 = 100;\n    var freq1 = 5000;\n    var delay = 0;\n    var attack = 0.01;\n    var sustain = 0.1;\n    var decay = 0.04;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.gotoScreen(Test36.SCREEN_PLAY);\n    controller.requestPointerLock();\n  });\n  this.resumeSpirit = this.world.spirits[spiritId];\n\n  // FULL SCREEN\n  buttonMaker.setScale(0.75);\n  spiritId = buttonMaker.addButton(0, -8-6, \"FULL SCREEN\", function(e) {\n    var freq0 = 200;\n    var freq1 = 2200;\n    var delay = 0;\n    var attack = 0.05;\n    var sustain = 0.1;\n    var decay = 0.2;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.requestFullScreen();\n  });\n  this.fullScreenSpirit = world.spirits[spiritId];\n\n  // QUIT\n  spiritId = buttonMaker.addButton(0, -8-6-5, \"QUIT\", function(e) {\n    var freq0 = 200;\n    var freq1 = 5;\n    var delay = 0;\n    var attack = 0;\n    var sustain = 1;\n    var decay = 0.1;\n    sfx.sound(0, 0, 0, 0.5, attack, sustain, decay, freq0, freq1, 'square', delay);\n    this.lastSoundMs = Date.now();\n    this.soundLength = (attack + sustain + decay + delay) * 1000;\n    controller.quit();\n  });\n  this.quitSpirit = world.spirits[spiritId];\n\n  for (spiritId in this.world.spirits) {\n    var s = this.world.spirits[spiritId];\n    var b = this.world.bodies[s.bodyId];\n    this.worldBoundingRect.coverRect(b.getBoundingRectAtTime(this.world.now));\n  }\n//  this.worldBoundingRect.coverXY(0, 5);\n//  this.worldBoundingRect.coverXY(0, -27);\n};\n\nPauseScreen.prototype.updateViewMatrix = function() {\n  var br = this.worldBoundingRect;\n  this.viewMatrix.toIdentity();\n  var ratio = Math.min(this.canvas.height, this.canvas.width) / Math.max(br.rad.x, br.rad.y);\n  this.viewMatrix\n      .multiply(this.mat4.toScaleOpXYZ(\n              ratio / this.canvas.width,\n              ratio / this.canvas.height,\n          0.2));\n\n  // scale\n  var v = this.visibility;\n  this.viewMatrix.multiply(this.mat4.toScaleOpXYZ(3 - v*2, v * v, 1));\n\n  // center\n  this.viewMatrix.multiply(this.mat4.toTranslateOpXYZ(\n      -br.pos.x,\n      -br.pos.y,\n      0));\n\n  this.renderer.setViewMatrix(this.viewMatrix);\n};\n\n\n// ----------------------- MAIN ------------------------\n\n\nvar canvas = document.createElement('canvas');\ncanvas.id = 'canvas';\nresizeCanvas();\n\ndocument.body.appendChild(canvas);\n\nthis.addEventListener(\"load\", main);\n\nfunction resizeCanvas() {\n  var w = window.innerWidth;\n  var h = window.innerHeight;\n  canvas.style.width = w + \"px\";\n  canvas.style.height = h + \"px\";\n  canvas.width = w;\n  canvas.height = h;\n}\n\n// ------  main  -------\n\nfunction main() {\n  var test38 = new Test38();\n}\n\nfunction Test38() {\n  this.canvas = canvas;\n  new RendererLoader(this.canvas, 'vertex-shader.txt', 'fragment-shader.txt').load(this.onRendererLoaded.bind(this));\n  this.sfx = new SoundFx();\n  this.sfx.setListenerXYZ(0, 0, 5);\n  this.iosSoundUnlocked = false;\n  this.animateFrameFn = this.animateFrame.bind(this);\n  // on-event sound unlocker for iOS\n  // document.body.addEventListener('mouseup', this.unlockIosSound.bind(this));\n  document.body.addEventListener('touchend', this.unlockIosSound.bind(this));\n}\n\nTest38.SCREEN_PLAY = 'play';\n\nTest38.SCREENS = [Test38.SCREEN_PLAY];\n\n/**\n * It seems that a drag won't work. There has to be a clean tap.\n * For now, I'll unlock every time there's a touchend.\n */\nTest38.prototype.unlockIosSound = function() {\n  this.sfx.sound(0, 0, 0, 0.001, 0, 0, 0.001, 1, 1, 'sine');\n  this.iosSoundUnlocked++;\n};\n\nTest38.prototype.onRendererLoaded = function(r) {\n  this.renderer = r;\n  this.initScreens();\n  this.requestAnimation();\n};\n\nTest38.prototype.initScreens = function() {\n  this.initStamps();\n  this.screens = {};\n  this.screens[Test38.SCREEN_PLAY] = new PlayScreen(this, this.canvas, this.renderer, this.glyphs, this.stamps, this.sfx);\n\n  this.visibility = {};\n  for (var i = 0; i < Test38.SCREENS.length; i++) {\n    var screen = Test38.SCREENS[i];\n    this.visibility[screen] = screen == Test38.SCREEN_PLAY ? 1 : 0;\n  }\n  this.frontScreenId = Test38.SCREEN_PLAY;\n  this.animationRequested = false;\n};\n\nTest38.prototype.initStamps = function() {\n  var glyphMaker = new GlyphMaker(0.4, 1.2);\n  this.glyphs = new Glyphs(glyphMaker);\n  var glyphStamps = this.glyphs.initStamps(this.renderer.gl);\n  this.stamps = {};\n  for (var key in glyphStamps) {\n    this.stamps[key] = glyphStamps[key];\n  }\n};\n\n/**\n * Manages changing screen visibility, and calls drawScreen() on visible screens.\n */\nTest38.prototype.animateFrame = function() {\n  this.animationRequested = false;\n  this.renderer.resize().clear();\n  for (var i = 0; i < Test38.SCREENS.length; i++) {\n    var id = Test38.SCREENS[i];\n    var oldVisibility = this.visibility[id];\n    var seconds = 0.2;\n    if (this.frontScreenId == id) {\n      this.visibility[id] = Math.min(1, this.visibility[id] + 1 / (seconds * 60));\n    } else {\n      this.visibility[id] = Math.max(0, this.visibility[id] - 1 / (seconds * 60));\n    }\n    this.screens[id].setScreenListening(this.frontScreenId == id);\n    if (this.visibility[id]) {\n      this.screens[id].drawScreen(this.visibility[id]);\n    }\n    if (oldVisibility != this.visibility[id]) {\n      this.requestAnimation();\n    }\n  }\n};\n\nTest38.prototype.gotoScreen = function(screenId) {\n  this.frontScreenId = screenId;\n  this.requestAnimation();\n};\n\nTest38.prototype.restart = function() {\n  this.screens[Test38.SCREEN_PLAY].unloadLevel();\n  this.requestAnimation();\n};\n\nTest38.prototype.requestFullScreen = function() {\n  var elem = document.body;\n  if (elem.requestFullscreen) {\n    elem.requestFullscreen();\n  } else if (elem.msRequestFullscreen) {\n    elem.msRequestFullscreen();\n  } else if (elem.mozRequestFullScreen) {\n    elem.mozRequestFullScreen();\n  } else if (elem.webkitRequestFullscreen) {\n    elem.webkitRequestFullscreen();\n  }\n  this.requestAnimation();\n};\n\nTest38.prototype.requestPointerLock = function() {\n  this.canvas.requestPointerLock = this.canvas.requestPointerLock || this.canvas.mozRequestPointerLock || this.canvas.webkitRequestPointerLock;\n  if (this.canvas.requestPointerLock) { this.canvas.requestPointerLock(); }\n};\n\nTest38.prototype.exitPointerLock = function() {\n  document.exitPointerLock = document.exitPointerLock ||\n      document.mozExitPointerLock ||\n      document.webkitExitPointerLock;\n  if (document.exitPointerLock) {\n    document.exitPointerLock();\n  } else {\n    console.log('exitPointerLock UNPOSSIBLE');\n  }\n};\n\nTest38.prototype.requestAnimation = function() {\n  if (!this.animationRequested) {\n    this.animationRequested = true;\n    requestAnimationFrame(this.animateFrameFn, this.canvas);\n  }\n};\n \n\n// -------------------- END OF FILE ------------------------\n\n","language":"text/javascript","encrypted":false,"added":1460768912},{"paste_id":16,"description":"Simple Game","body":"\n// https://github.com/lostdecade/simple_canvas_game\n\n// Create the canvas\nvar canvas = document.createElement(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\ncanvas.width = 512;\ncanvas.height = 480;\ncanvas.style.padding = '7px 0 0 42px';\ndocument.body.appendChild(canvas);\n\n// Background image\nvar bgReady = false;\nvar bgImage = new Image();\nbgImage.onload = function () {\n\tbgReady = true;\n};\nbgImage.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAHgBAMAAAAh+sjWAAAAMFBMVEUGDwYIFgkJGAoUMhYZEwocRx8fTyImUB0/gzA/hTA/hjBAbC1LOR9Mck5UPyNegGAQoePyAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEz0lEQVR4Xu3aTXHjeBQA8T6EgCh4IMgQlsKKQiCMIXghhEKWQiAkEMYURGEPzmTsyFu6/7v7MvU876R6+Sr9nl6B5QAA5+s/qvkJeU9cDqeZdy7/rDy/gG3uAjicfl2WI/P6yvL8gm3uAgBOHFi5ME3XD01zF8Dpr4V3jq/LAhewzV0A59M8ceTwvlzef4Bt7gJgvXAEmA78+nG2zV0ATO8scHz9uRzXM7a5CwAuJ15ZFpjfwDZ3AcCJ6bIwv/B8/Uw1dwFwfv7758LMM29nLgfZ3AUAL6d/J96AMxxscxfAtHL++DhzWGYA29wFsPIB8wlmPmawzV0AMHN9NjPTim3uAgCY5uu0fn4qmrsA2L4/vz6p6ffzGm7OB9z0yAd8/tfnAxtvzgfc9sAHfNsYbs4H3PUE9+/LDeUDbtr6gGnl61vntI435wPu2/qAFb6+da4DzvmA+57YvD8fvXzAXQ98wJ/Wb78XjDHnA+565AP4/afz1wMca84H3PbIB3z+7Px8bOPN+YDbHviA363AiHM+4K5HPuC2Eed8wG0PfcDdl86Acz7gpkc+gLsvnfHmfMBtj3zAn8ac8wG3/Y8PWAef8wFf5QOQlw9AXj4AefmAveXRywcgLx+AvHzA3vro5QOQlw9AXj4AefkA5OUDkJcPQF4+AHn5AOTlA5CXD0BePgB5+QDk5QP2lkcvH4C8fADy8gF766OXD0BePgB5+QDk5QOQlw9AXj4AefkA5OUDkJcPQF4+AHn5AOTlA5CXD9hbHr18APLyAcjLB+ytj14+AHn5AOTlA5CXD0BePgB5+QDk5QOQlw9AXj4AefkA5OUDkJcPQF4+YG959PIByMsHIC8fsLc+evkA5OUDkJcPQF4+AHn5AOTlA5CXD0BePgB5+QDk5QOQlw9AXj4AefmAveXRywcgLx+AvHzA3vro5QOQlw9AXj4AefkA5OUDkJcPQF4+AHn5AOTlA5CXD0BePgB5+QDk5QP2lkcvH4C8fADy8gF766OXD0BePgB5+QDk5QOQlw9AXj4AefkA5OUDkJcPQF4+AHn5AOTlA5CXD9hbHr18APLyAcjLB+ytj14+AHn5AOTlA5CXD0BePgB5+QDk5QOQlw9AXj4AefkA5OUDkJcPQF4+YG959PIByMsHIC8fsLc+evkA5OUDkJcPQF4+AHn5AOTlA5CXD0BePgB5+QDk5QOQlw9AXj4AefmAveXRywcgLx+AvHzA3vro5QOQlw9AXj4AefkA5OUDkJcPQF4+AHn5AOTlA5CXD0BePgB5+QDk5QP2lkcvH4C8fADy8gF766OXD0BePgB5+QDk5QOQlw9AXj4AefkA5OUDkJcPQF4+AHn5AOTlA5CXD9hbHr18APLyAcjLB+ytj14+AHn5AOTlA5CXD0BePgB5+QDk5QOQlw9AXj4AefkA5OUDkJcPQF4+YG959PIByMsHIC8fsLc+evkA5OUDkJcPQF4+AHn5AOTlA5CXD0BePgB5+QDkPfQBprkLYOsDVHMXsPUBrrkLgK0PMM1dwMYHyOYuYOMDZHMXwMYHuOYugI0PcM1dAGx8gGruAvj2vtw2dwFsfIBr7gLY+gDV3AV8f19um7sAtj5ANXcBwPzNB6jmLgBg6wM8s/4C/gPCHEonpOZggQAAAABJRU5ErkJggg==\";\n\n// Hero image\nvar heroReady = false;\nvar heroImage = new Image();\nheroImage.onload = function () {\n\theroReady = true;\n};\nheroImage.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAASFBMVEUAAAAAAAAAAAAAAAAAfcVYRRtpgpBuViJvYD59kZyDo7SLeE6ctcPLpn7+0J7+2bH/xFH/x4v/yJj/8z7/9WX/+a7/+r7///8xDi3HAAAAA3RSTlMAZmcaB/wEAAAA1UlEQVQ4jZWS2xKDIAwFwaBYLXhplf//03qIqUxnWtJ9IZIdIInGGCKToQLZKZdvAtG+IyC6Z4YM7+SMSkAgKYFoXbdNI+AoBM+CxwHRsryrqAhcYJtBkqOrWI1wtanveYVgjFaQ9qbk3DTF6FxKMRYtrwhSID7jCeJ5xoNzJysCzkBrMSi5rDvhoWmEGIeh66DcMkgShYDL6gLROHofAi66Rg6hbb3XCjwaiCjYHxTjqgrcai62K/gY1k9BNFyBhM/8K1jLAj8NWKsX7An/uEgJTaMQXgQOGP28nGoKAAAAAElFTkSuQmCC\";\n\n// Monster image\nvar monsterReady = false;\nvar monsterImage = new Image();\nmonsterImage.onload = function () {\n\tmonsterReady = true;\n};\nmonsterImage.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAgCAYAAAAFQMh/AAAA+klEQVR42s2WvQ3CMBCFUWCJLEGXAaCghS4UdEh0sAO0mYIdGIOCEdjEYHRPAp4eJ9P4LH1FLPt90fknGaWUfvJsqQTKEFQTk+D7ebicilA5YcQk+Fd4OG8/ULnBxRwo+l3iiNWxEQE+6+MyI49ZFLF/cYglISAmYVAxC2/364thPMnQ5kI/xqlSxxM7pfSOkSo5l766WASLiQKINPSCwcSMF6xKH19MA5yPg1oiEoMwYlmqfT8vQf36UH89sRqglgCCftFleKNxSVujyVQX59YZu3eEGEKEuscJefCEFyNIiAkShhQ3RmtMjZnhXQQbY2VgHnJoc1UVPwARyA+KY6o4FwAAAABJRU5ErkJggg==\";\n\n// Game objects\nvar hero = {\n\tspeed: 256 // movement in pixels per second\n};\nvar monster = {};\nvar monstersCaught = 0;\n\n// Handle keyboard controls\nvar keysDown = {};\n\naddEventListener(\"keydown\", function (e) {\n\tkeysDown[e.keyCode] = true;\n}, false);\n\naddEventListener(\"keyup\", function (e) {\n\tdelete keysDown[e.keyCode];\n}, false);\n\n// Reset the game when the player catches a monster\nvar reset = function () {\n\thero.x = canvas.width / 2;\n\thero.y = canvas.height / 2;\n\n\t// Throw the monster somewhere on the screen randomly\n\tmonster.x = 32 + (Math.random() * (canvas.width - 64));\n\tmonster.y = 32 + (Math.random() * (canvas.height - 64));\n};\n\n// Update game objects\nvar update = function (modifier) {\n\tif (38 in keysDown) { // Player holding up\n\t\thero.y -= hero.speed * modifier;\n\t}\n\tif (40 in keysDown) { // Player holding down\n\t\thero.y += hero.speed * modifier;\n\t}\n\tif (37 in keysDown) { // Player holding left\n\t\thero.x -= hero.speed * modifier;\n\t}\n\tif (39 in keysDown) { // Player holding right\n\t\thero.x += hero.speed * modifier;\n\t}\n\n\t// Are they touching?\n\tif (\n\t\thero.x <= (monster.x + 32)\n\t\t&& monster.x <= (hero.x + 32)\n\t\t&& hero.y <= (monster.y + 32)\n\t\t&& monster.y <= (hero.y + 32)\n\t) {\n\t\t++monstersCaught;\n\t\treset();\n\t}\n};\n\n// Draw everything\nvar render = function () {\n\tif (bgReady) {\n\t\tctx.drawImage(bgImage, 0, 0);\n\t}\n\n\tif (heroReady) {\n\t\tctx.drawImage(heroImage, hero.x, hero.y);\n\t}\n\n\tif (monsterReady) {\n\t\tctx.drawImage(monsterImage, monster.x, monster.y);\n\t}\n\n\t// Score\n\tctx.fillStyle = \"rgb(250, 250, 250)\";\n\tctx.font = \"24px Helvetica\";\n\tctx.textAlign = \"left\";\n\tctx.textBaseline = \"top\";\n\tctx.fillText(\"Goblins caught: \" + monstersCaught, 32, 32);\n};\n\n// The main game loop\nvar main = function () {\n\tvar now = Date.now();\n\tvar delta = now - then;\n\n\tupdate(delta / 1000);\n\trender();\n\n\tthen = now;\n\n\t// Request to do this again ASAP\n\trequestAnimationFrame(main);\n};\n\n// Cross-browser support for requestAnimationFrame\nvar w = window;\nrequestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;\n\n// Let's play this game!\nvar then = Date.now();\n\nreset();\nmain();\n\n// ---------------------- End of file ------------------------\n","language":"text/javascript","encrypted":false,"added":1461334220},{"paste_id":18,"description":"WebGL Demo1 (Cave2D.com)","body":"// Webgl-1\n\n// Test 14\n// WebGL Demo by Aaron Whyte\n// CAVE2D.com\n\n// ----------------------- GL MATRIX --------------------\n\n// function glMatrix() {\n\tglMatrixArrayType=typeof Float32Array!=\"undefined\"?Float32Array:typeof WebGLFloatArray!=\"undefined\"?WebGLFloatArray:Array;var vec3={};vec3.create=function(a){var b=new glMatrixArrayType(3);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2]}return b};vec3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b};vec3.add=function(a,b,c){if(!c||a==c){a[0]+=b[0];a[1]+=b[1];a[2]+=b[2];return a}c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];return c};\n\tvec3.subtract=function(a,b,c){if(!c||a==c){a[0]-=b[0];a[1]-=b[1];a[2]-=b[2];return a}c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c};vec3.negate=function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b};vec3.scale=function(a,b,c){if(!c||a==c){a[0]*=b;a[1]*=b;a[2]*=b;return a}c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};\n\tvec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g==1){b[0]=c;b[1]=d;b[2]=e;return b}}else{b[0]=0;b[1]=0;b[2]=0;return b}g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};vec3.cross=function(a,b,c){c||(c=a);var d=a[0],e=a[1];a=a[2];var g=b[0],f=b[1];b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c};vec3.length=function(a){var b=a[0],c=a[1];a=a[2];return Math.sqrt(b*b+c*c+a*a)};vec3.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]};\n\tvec3.direction=function(a,b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1];a=a[2]-b[2];b=Math.sqrt(d*d+e*e+a*a);if(!b){c[0]=0;c[1]=0;c[2]=0;return c}b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c};vec3.lerp=function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);return d};vec3.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\"]\"};var mat3={};\n\tmat3.create=function(a){var b=new glMatrixArrayType(9);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9]}return b};mat3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b};mat3.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a};\n\tmat3.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b};mat3.toMat4=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=0;b[4]=a[3];b[5]=a[4];b[6]=a[5];b[7]=0;b[8]=a[6];b[9]=a[7];b[10]=a[8];b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};\n\tmat3.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\", \"+a[4]+\", \"+a[5]+\", \"+a[6]+\", \"+a[7]+\", \"+a[8]+\"]\"};var mat4={};mat4.create=function(a){var b=new glMatrixArrayType(16);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15]}return b};\n\tmat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};\n\tmat4.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]=a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b};\n\tmat4.determinant=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],i=a[7],j=a[8],k=a[9],l=a[10],o=a[11],m=a[12],n=a[13],p=a[14];a=a[15];return m*k*h*e-j*n*h*e-m*f*l*e+g*n*l*e+j*f*p*e-g*k*p*e-m*k*d*i+j*n*d*i+m*c*l*i-b*n*l*i-j*c*p*i+b*k*p*i+m*f*d*o-g*n*d*o-m*c*h*o+b*n*h*o+g*c*p*o-b*f*p*o-j*f*d*a+g*k*d*a+j*c*h*a-b*k*h*a-g*c*l*a+b*f*l*a};\n\tmat4.inverse=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],i=a[6],j=a[7],k=a[8],l=a[9],o=a[10],m=a[11],n=a[12],p=a[13],r=a[14],s=a[15],A=c*h-d*f,B=c*i-e*f,t=c*j-g*f,u=d*i-e*h,v=d*j-g*h,w=e*j-g*i,x=k*p-l*n,y=k*r-o*n,z=k*s-m*n,C=l*r-o*p,D=l*s-m*p,E=o*s-m*r,q=1/(A*E-B*D+t*C+u*z-v*y+w*x);b[0]=(h*E-i*D+j*C)*q;b[1]=(-d*E+e*D-g*C)*q;b[2]=(p*w-r*v+s*u)*q;b[3]=(-l*w+o*v-m*u)*q;b[4]=(-f*E+i*z-j*y)*q;b[5]=(c*E-e*z+g*y)*q;b[6]=(-n*w+r*t-s*B)*q;b[7]=(k*w-o*t+m*B)*q;b[8]=(f*D-h*z+j*x)*q;\n\tb[9]=(-c*D+d*z-g*x)*q;b[10]=(n*v-p*t+s*A)*q;b[11]=(-k*v+l*t-m*A)*q;b[12]=(-f*C+h*y-i*x)*q;b[13]=(c*C-d*y+e*x)*q;b[14]=(-n*u+p*B-r*A)*q;b[15]=(k*u-l*B+o*A)*q;return b};mat4.toRotationMat=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};\n\tmat4.toMat3=function(a,b){b||(b=mat3.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b};mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,o=-k*g+h*i,m=j*g-f*i,n=c*l+d*o+e*m;if(!n)return null;n=1/n;b||(b=mat3.create());b[0]=l*n;b[1]=(-k*d+e*j)*n;b[2]=(h*d-e*f)*n;b[3]=o*n;b[4]=(k*c-e*i)*n;b[5]=(-h*c+e*g)*n;b[6]=m*n;b[7]=(-j*c+d*i)*n;b[8]=(f*c-d*g)*n;return b};\n\tmat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],o=a[9],m=a[10],n=a[11],p=a[12],r=a[13],s=a[14];a=a[15];var A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14];b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*o+u*r;c[2]=A*g+B*j+t*m+u*s;c[3]=A*f+B*k+t*n+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*o+y*r;c[6]=v*g+w*j+x*m+y*s;c[7]=v*f+w*k+x*n+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*o+E*r;c[10]=z*\n\tg+C*j+D*m+E*s;c[11]=z*f+C*k+D*n+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*o+b*r;c[14]=q*g+F*j+G*m+b*s;c[15]=q*f+F*k+G*n+b*a;return c};mat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1];b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c};\n\tmat4.multiplyVec4=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[3]=a[3]*d+a[7]*e+a[11]*g+a[15]*b;return c};\n\tmat4.translate=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[12]=a[0]*d+a[4]*e+a[8]*b+a[12];a[13]=a[1]*d+a[5]*e+a[9]*b+a[13];a[14]=a[2]*d+a[6]*e+a[10]*b+a[14];a[15]=a[3]*d+a[7]*e+a[11]*b+a[15];return a}var g=a[0],f=a[1],h=a[2],i=a[3],j=a[4],k=a[5],l=a[6],o=a[7],m=a[8],n=a[9],p=a[10],r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=o;c[8]=m;c[9]=n;c[10]=p;c[11]=r;c[12]=g*d+j*e+m*b+a[12];c[13]=f*d+k*e+n*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+o*e+r*b+a[15];return c};\n\tmat4.scale=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[0]*=d;a[1]*=d;a[2]*=d;a[3]*=d;a[4]*=e;a[5]*=e;a[6]*=e;a[7]*=e;a[8]*=b;a[9]*=b;a[10]*=b;a[11]*=b;return a}c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};\n\tmat4.rotate=function(a,b,c,d){var e=c[0],g=c[1];c=c[2];var f=Math.sqrt(e*e+g*g+c*c);if(!f)return null;if(f!=1){f=1/f;e*=f;g*=f;c*=f}var h=Math.sin(b),i=Math.cos(b),j=1-i;b=a[0];f=a[1];var k=a[2],l=a[3],o=a[4],m=a[5],n=a[6],p=a[7],r=a[8],s=a[9],A=a[10],B=a[11],t=e*e*j+i,u=g*e*j+c*h,v=c*e*j-g*h,w=e*g*j-c*h,x=g*g*j+i,y=c*g*j+e*h,z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;if(d){if(a!=d){d[12]=a[12];d[13]=a[13];d[14]=a[14];d[15]=a[15]}}else d=a;d[0]=b*t+o*u+r*v;d[1]=f*t+m*u+s*v;d[2]=k*t+n*u+A*v;d[3]=l*t+p*u+B*\n\tv;d[4]=b*w+o*x+r*y;d[5]=f*w+m*x+s*y;d[6]=k*w+n*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+o*e+r*g;d[9]=f*z+m*e+s*g;d[10]=k*z+n*e+A*g;d[11]=l*z+p*e+B*g;return d};mat4.rotateX=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[4],g=a[5],f=a[6],h=a[7],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[0]=a[0];c[1]=a[1];c[2]=a[2];c[3]=a[3];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[4]=e*b+i*d;c[5]=g*b+j*d;c[6]=f*b+k*d;c[7]=h*b+l*d;c[8]=e*-d+i*b;c[9]=g*-d+j*b;c[10]=f*-d+k*b;c[11]=h*-d+l*b;return c};\n\tmat4.rotateY=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[4]=a[4];c[5]=a[5];c[6]=a[6];c[7]=a[7];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*-d;c[1]=g*b+j*-d;c[2]=f*b+k*-d;c[3]=h*b+l*-d;c[8]=e*d+i*b;c[9]=g*d+j*b;c[10]=f*d+k*b;c[11]=h*d+l*b;return c};\n\tmat4.rotateZ=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[4],j=a[5],k=a[6],l=a[7];if(c){if(a!=c){c[8]=a[8];c[9]=a[9];c[10]=a[10];c[11]=a[11];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*d;c[1]=g*b+j*d;c[2]=f*b+k*d;c[3]=h*b+l*d;c[4]=e*-d+i*b;c[5]=g*-d+j*b;c[6]=f*-d+k*b;c[7]=h*-d+l*b;return c};\n\tmat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b=a*b;return mat4.frustum(-b,b,-a,a,c,d,e)};\n\tmat4.ortho=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/i;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/j;f[11]=0;f[12]=-(a+b)/h;f[13]=-(d+c)/i;f[14]=-(g+e)/j;f[15]=1;return f};\n\tmat4.lookAt=function(a,b,c,d){d||(d=mat4.create());var e=a[0],g=a[1];a=a[2];var f=c[0],h=c[1],i=c[2];c=b[1];var j=b[2];if(e==b[0]&&g==c&&a==j)return mat4.identity(d);var k,l,o,m;c=e-b[0];j=g-b[1];b=a-b[2];m=1/Math.sqrt(c*c+j*j+b*b);c*=m;j*=m;b*=m;k=h*b-i*j;i=i*c-f*b;f=f*j-h*c;if(m=Math.sqrt(k*k+i*i+f*f)){m=1/m;k*=m;i*=m;f*=m}else f=i=k=0;h=j*f-b*i;l=b*k-c*f;o=c*i-j*k;if(m=Math.sqrt(h*h+l*l+o*o)){m=1/m;h*=m;l*=m;o*=m}else o=l=h=0;d[0]=k;d[1]=h;d[2]=c;d[3]=0;d[4]=i;d[5]=l;d[6]=j;d[7]=0;d[8]=f;d[9]=\n\to;d[10]=b;d[11]=0;d[12]=-(k*e+i*g+f*a);d[13]=-(h*e+l*g+o*a);d[14]=-(c*e+j*g+b*a);d[15]=1;return d};mat4.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\", \"+a[4]+\", \"+a[5]+\", \"+a[6]+\", \"+a[7]+\", \"+a[8]+\", \"+a[9]+\", \"+a[10]+\", \"+a[11]+\", \"+a[12]+\", \"+a[13]+\", \"+a[14]+\", \"+a[15]+\"]\"};quat4={};quat4.create=function(a){var b=new glMatrixArrayType(4);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3]}return b};quat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b};\n\tquat4.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a==b){a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return a}b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};quat4.inverse=function(a,b){if(!b||a==b){a[0]*=1;a[1]*=1;a[2]*=1;return a}b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};quat4.length=function(a){var b=a[0],c=a[1],d=a[2];a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};\n\tquat4.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(f==0){b[0]=0;b[1]=0;b[2]=0;b[3]=0;return b}f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};quat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2];a=a[3];var f=b[0],h=b[1],i=b[2];b=b[3];c[0]=d*b+a*f+e*i-g*h;c[1]=e*b+a*h+g*f-d*i;c[2]=g*b+a*i+d*h-e*f;c[3]=a*b-d*f-e*h-g*i;return c};\n\tquat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=a[0];var f=a[1],h=a[2];a=a[3];var i=a*d+f*g-h*e,j=a*e+h*d-b*g,k=a*g+b*e-f*d;d=-b*d-f*e-h*g;c[0]=i*a+d*-b+j*-h-k*-f;c[1]=j*a+d*-f+k*-b-i*-h;c[2]=k*a+d*-h+i*-f-j*-b;return c};quat4.toMat3=function(a,b){b||(b=mat3.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=k+g;b[4]=1-(j+e);b[5]=d-f;b[6]=c-h;b[7]=d+f;b[8]=1-(j+l);return b};\n\tquat4.toMat4=function(a,b){b||(b=mat4.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=0;b[4]=k+g;b[5]=1-(j+e);b[6]=d-f;b[7]=0;b[8]=c-h;b[9]=d+f;b[10]=1-(j+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};quat4.slerp=function(a,b,c,d){d||(d=a);var e=c;if(a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]<0)e=-1*c;d[0]=1-c*a[0]+e*b[0];d[1]=1-c*a[1]+e*b[1];d[2]=1-c*a[2]+e*b[2];d[3]=1-c*a[3]+e*b[3];return d};\n\tquat4.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\"]\"};\n// }\n\n// ------------------------ MAIN ----------------------\n\n// glMatrix();\n\nvar canvas = document.createElement('canvas');\ncanvas.id = 'canvas';\nresizeCanvas();\ndocument.body.appendChild(canvas);\naddEventListener(\"load\", main);\n\nvar gl;\nvar program;\nvar mvMatrix = mat4.create();\nvar pMatrix = mat4.create();\nvar triangleVertexPositionBuffer;\nvar squareVertexPositionBuffer;\n\t\nfunction resizeCanvas() {\n\tvar w = window.innerWidth;\n\tvar h = window.innerHeight;\n\tcanvas.style.width = w + \"px\";\n\tcanvas.style.height = h + \"px\";\n\tcanvas.width = w;\n\tcanvas.height = h;\n}\n\nfunction main() { canvas = this.canvas;\n\tnew RendererLoader(this.canvas, 'shaders/demo-vertex-shader.txt', 'shaders/demo-fragment-shader.txt').load(this.onRendererLoaded.bind(this));\n}\nfunction onRendererLoaded(r) { initBuffers(); this.renderer = r; this.loop(); }\nfunction loop() { drawScene(); requestAnimationFrame(loop, canvas); }\n\nfunction setMatrixUniforms() {\n\tgl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);\n\tgl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);\n}\n\n// ----------------------- BUFFERS --------------------\n\nfunction initBuffers() {\n\ttriangleVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);\n\tvar vertices = [\n\t  0.0,  1.0,  0.0,\n\t -1.0, -1.0,  0.0,\n\t  1.0, -1.0,  0.0\n  ];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\ttriangleVertexPositionBuffer.itemSize = 3;\n\ttriangleVertexPositionBuffer.numItems = 3;\n\tsquareVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);\n\tvertices = [\n\t  1.0,  1.0,  0.0,\n\t  -1.0,  1.0,  0.0,\n\t  1.0, -1.0,  0.0,\n\t  -1.0, -1.0,  0.0\n\t];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\tsquareVertexPositionBuffer.itemSize = 3;\n\tsquareVertexPositionBuffer.numItems = 4;\n}\n\n// --------------------- DRAW SCENE ------------------\n\nfunction drawScene() {\n\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\tmat4.perspective(45 + Math.sin(Date.now() / 300) * 10, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);\n\tmat4.identity(mvMatrix);\n\tmat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);\n\tgl.vertexAttribPointer(program.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\tsetMatrixUniforms();\n\tgl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);\n\tmat4.translate(mvMatrix, [3.0, 0.0+ Math.sin(Date.now() / 400) * 2, 0.0+ Math.sin(Date.now() / 500) * 2]);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);\n\tgl.vertexAttribPointer(program.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\tsetMatrixUniforms();\n\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);\n}\n\n// ------------------- RENDERER LOADER -----------------\n\nfunction RendererLoader(canvas, vertexShaderPath, fragmentShaderPath) {\n\tthis.canvas = canvas;\n\tthis.textLoader = new TextLoader([vertexShaderPath, fragmentShaderPath]);\n\tthis.renderer = null;\n}\n\nRendererLoader.prototype.load = function(callback) {\n\tvar self = this; this.callback = callback; this.textLoader.load(function() {  self.invalidate(); });\n};\n\nRendererLoader.prototype.invalidate = function() {\n  var vertexShader = this.textLoader.getTextByIndex(0);\n  var fragmentShader = this.textLoader.getTextByIndex(1);\n\t\n  if (!this.renderer && vertexShader && fragmentShader) {\n\tgl = this.canvas.getContext(\"webgl\", { alpha: true, antialias: true } );\n\tif (!gl) { console.log(\"!gl. Could not initialise WebGL\"); }\n\tgl.viewportWidth = this.canvas.width;\n\tgl.viewportHeight = this.canvas.height;\n\tvar vs = compileShader(gl, vertexShader, gl.VERTEX_SHADER);\n\tvar fs = compileShader(gl, fragmentShader, gl.FRAGMENT_SHADER);\n\tprogram = createProgram(gl, vs, fs);\n\tgl.enable(gl.DEPTH_TEST);\n\tgl.clearColor(0.0, 0.0, 0.0, 1.0);\n\tgl.useProgram(program);\n\tprogram.vertexPositionAttribute = gl.getAttribLocation(program, \"aVertexPosition\");\n\tgl.enableVertexAttribArray(program.vertexPositionAttribute);\n\tprogram.pMatrixUniform = gl.getUniformLocation(program, \"uPMatrix\");\n\tprogram.mvMatrixUniform = gl.getUniformLocation(program, \"uMVMatrix\");\n\tthis.renderer = new Renderer(this.canvas, gl, program);\n\tthis.callback(this.renderer);\n  }\n};\n\n// --------------------- TEXTLOADER ----------------------\n\nfunction TextLoader(paths) { this.paths = paths; this.texts = {}; }\n\nTextLoader.prototype.load = function(callback) {\n\tthis.callback = callback;\n\tfor (var _n = 0; _n < this.paths.length; _n++) { \n\t  var path = this.paths[_n]; if (!this.texts[path]) { this.xhr(path, this.getOnTextLoadedFunc(_n)); }\n\t}\n};\n\nTextLoader.prototype.getOnTextLoadedFunc = function(_n) {\n\tvar self = this;\n\treturn function(text) {\n\t  var path = self.paths[_n];\n\t  self.texts[path] = text;\n\t  // alert(text);\n\t  self.callback && self.callback(_n);\n  };\n};\n\nTextLoader.prototype.getTextByIndex = function(_n) { return this.getTextByPath(this.paths[_n]); };\nTextLoader.prototype.getTextByPath = function(path) { return this.texts[path]; };\n\nTextLoader.prototype.xhr = function(url, callback) {\n\tvar xhr = new XMLHttpRequest();\n\txhr.open('GET', url, true);\n\txhr.responseType = 'text';\n\txhr.onload = function() { callback(this.response); };\n\txhr.send();\n};\n\n// ----------------------- WEBGL UTIL -----------------\n\nfunction compileShader(gl, shaderSource, shaderType) {\n\tvar shader = gl.createShader(shaderType);\n\tgl.shaderSource(shader, shaderSource);\n\tgl.compileShader(shader);\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { alert(\"could not compile shader:\" + gl.getShaderInfoLog(shader)); }\n\treturn shader;\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader) {\n\tvar program = gl.createProgram();\n\tgl.attachShader(program, vertexShader);\n\tgl.attachShader(program, fragmentShader);\n\tgl.linkProgram(program);\n\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) { alert(\"program filed to link:\" + gl.getProgramInfoLog(program)); }\n\treturn program;\n}\n\nfunction createStaticGlBuff(gl, values) {\n\tvar buff = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, buff);\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(values), gl.STATIC_DRAW);\n\treturn buff;\n}\n\n// ----------------------- RENDERER --------------------\n\nfunction Renderer(canvas, gl, program) {\n\tthis.canvas = canvas;\n\tthis.gl = gl;\n\tthis.program = program;\n\tthis.initAttributesAndUniforms();\n}\nRenderer.prototype.initAttributesAndUniforms = function() {\n\tthis.createVertexAttribute('aVertexPosition');\n\tthis.createVertexAttribute('aVertexColor');\n\tthis.createVertexAttribute('aVertexGroup');\n\tthis.createUniform('uViewMatrix');\n\tthis.createUniform('uModelMatrix');\n\tthis.createUniform('uModelMatrix2');\n\tthis.createUniform('uModelColor');\n};\nRenderer.prototype.createVertexAttribute = function(name) {\n\tthis[name] = this.gl.getAttribLocation(this.program, name);\n\tthis.gl.enableVertexAttribArray(this[name]);\n};\nRenderer.prototype.createUniform = function(name) { this[name] = this.gl.getUniformLocation(this.program, name); };\nRenderer.prototype.resize = function() {\n\tif (this.canvas.width != this.canvas.clientWidth || this.canvas.height != this.canvas.clientHeight) {\n      this.canvas.width = this.canvas.clientWidth;\n      this.canvas.height = this.canvas.clientHeight;\n      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\t}\n\treturn this;\n};\nRenderer.prototype.clear = function() { this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT); return this; };\nRenderer.prototype.clearColor = function(r, g, b, a) { this.gl.clearColor(r, g, b, a); return this; };\nRenderer.prototype.setColorVector = function(colorVector) { this.gl.uniform4fv(this.uModelColor, colorVector.v); return this; };\nRenderer.prototype.setBlendingEnabled = function(blend) {\n\tif (blend) {\n\t  this.gl.enable(this.gl.BLEND);\n\t  this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE)\n\t} else { this.gl.disable(this.gl.BLEND) }\n\treturn this;\n};\nRenderer.prototype.setViewMatrix = function(viewMatrix) {\n\tthis.viewMatrix = viewMatrix;\n\tthis.gl.uniformMatrix4fv(this.uViewMatrix, this.gl.FALSE, viewMatrix.m); return this;\n};\nRenderer.prototype.getViewMatrix = function() { return this.viewMatrix; };\nRenderer.prototype.setModelMatrix = function(modelMatrix) {\n\tthis.gl.uniformMatrix4fv(this.uModelMatrix, this.gl.FALSE, modelMatrix.m); return this;\n};\nRenderer.prototype.setModelMatrix2 = function(modelMatrix2) {\n\tthis.gl.uniformMatrix4fv(this.uModelMatrix2, this.gl.FALSE, modelMatrix2.m); return this;\n};\nRenderer.prototype.setStamp = function(stamp) {\n\tthis.modelStamp = stamp;\n\tstamp.prepareToDraw(this.gl, this.aVertexPosition, this.aVertexColor, this.aVertexGroup); return this;\n};\nRenderer.prototype.drawStamp = function() { this.modelStamp.draw(this.gl); return this; };\n\n\n\n// -------------------- END OF FILE ---------------------\n","language":"text/javascript","encrypted":false,"added":1461939650},{"paste_id":19,"description":"Voxel Demo (qake.se/demo)","body":"// ------------------------------------------------//\n//             http://qake.se/demo                 //\n//                                                 //\n//        Voxel Demo by Magnus Persson             //\n// ------------------------------------------------//\n\nfunction VoxelData() {\n\t\n\tthis.x;\n\tthis.y;\n\tthis.z;\n\tthis.color;\n\n\tVoxelData.prototype.Create = function(_data,_onLoad,_context) {\n\t\tthis.x = (_context?_data[_onLoad]&255/2:_data[_onLoad++]&255);\n\t\tthis.y = (_context?_data[_onLoad]&255/2:_data[_onLoad++]&255);\n\t\tthis.z = (_context?_data[_onLoad]&255/2:_data[_onLoad++]&255);\n\t\tthis.color = _data[_onLoad]&255;\n\t};\n};\n\nVoxelData.prototype = new VoxelData();\nVoxelData.prototype.constructor = VoxelData;\n\nfunction Vox() {\n\tvar _colors=[0,4294967295,4291624959,4288282623,4284940287,4281597951,4278255615,4294954239,4291611903,4288269567,4284927231,4281584895,\n\t\t4278242559,4294941183,4291598847,4288256511,4284914175,4281571839,4278229503,4294928127,4291585791,4288243455,4284901119,4281558783,\n\t\t4278216447,4294915071,4291572735,4288230399,4284888063,4281545727,4278203391,4294902015,4291559679,4288217343,4284875007,4281532671,\n\t\t4278190335,4294967244,4291624908,4288282572,4284940236,4281597900,4278255564,4294954188,4291611852,4288269516,4284927180,4281584844,\n\t\t4278242508,4294941132,4291598796,4288256460,4284914124,4281571788,4278229452,4294928076,4291585740,4288243404,4284901068,4281558732,\n\t\t4278216396,4294915020,4291572684,4288230348,4284888012,4281545676,4278203340,4294901964,4291559628,4288217292,4284874956,4281532620,\n\t\t4278190284,4294967193,4291624857,4288282521,4284940185,4281597849,4278255513,4294954137,4291611801,4288269465,4284927129,4281584793,\n\t\t4278242457,4294941081,4291598745,4288256409,4284914073,4281571737,4278229401,4294928025,4291585689,4288243353,4284901017,4281558681,\n\t\t4278216345,4294914969,4291572633,4288230297,4284887961,4281545625,4278203289,4294901913,4291559577,4288217241,4284874905,4281532569,\n\t\t4278190233,4294967142,4291624806,4288282470,4284940134,4281597798,4278255462,4294954086,4291611750,4288269414,4284927078,4281584742,\n\t\t4278242406,4294941030,4291598694,4288256358,4284914022,4281571686,4278229350,4294927974,4291585638,4288243302,4284900966,4281558630,\n\t\t4278216294,4294914918,4291572582,4288230246,4284887910,4281545574,4278203238,4294901862,4291559526,4288217190,4284874854,4281532518,\n\t\t4278190182,4294967091,4291624755,4288282419,4284940083,4281597747,4278255411,4294954035,4291611699,4288269363,4284927027,4281584691,\n\t\t4278242355,4294940979,4291598643,4288256307,4284913971,4281571635,4278229299,4294927923,4291585587,4288243251,4284900915,4281558579,\n\t\t4278216243,4294914867,4291572531,4288230195,4284887859,4281545523,4278203187,4294901811,4291559475,4288217139,4284874803,4281532467,\n\t\t4278190131,4294967040,4291624704,4288282368,4284940032,4281597696,4278255360,4294953984,4291611648,4288269312,4284926976,4281584640,\n\t\t4278242304,4294940928,4291598592,4288256256,4284913920,4281571584,4278229248,4294927872,4291585536,4288243200,4284900864,4281558528,\n\t\t4278216192,4294914816,4291572480,4288230144,4284887808,4281545472,4278203136,4294901760,4291559424,4288217088,4284874752,4281532416,\n\t\t4278190318,4278190301,4278190267,4278190250,4278190216,4278190199,4278190165,4278190148,4278190114,4278190097,4278251008,4278246656,\n\t\t4278237952,4278233600,4278224896,4278220544,4278211840,4278207488,4278198784,4278194432,4293787648,4292673536,4290445312,4289331200,\n\t\t4287102976,4285988864,4283760640,4282646528,4280418304,4279304192,4293848814,4292730333,4290493371,4289374890,4287137928,4286019447,\n\t\t4283782485,4282664004,4280427042,4279308561];\n\t\n\t// var kolors = [0,FFFFFFFF,FFCCFFFF,FF99FFFF,FF66FFFF,FF33FFFF,FF00FFFF,FFFFCCFF,FFFF99FF,FFFF66FF,FFFF33FF,FFFF00FF,FF00CCFF...];\n\t\n\tVox.prototype.readInt = function(_context,_onLoad) {\n\t\treturn _context[_onLoad]|(_context[_onLoad+1]<<8)|(_context[_onLoad+2]<<16)|(_context[_onLoad+3]<<24);\n\t};\n\t\n\tVox.prototype.LoadModel = function(_context,_filename,_arraybuffer,_0x1673xa) {\n\t\tvar _request = new XMLHttpRequest();\n\t\t_request.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\t_request.open(\"GET\",_context);\n\t\t_request.responseType = \"arraybuffer\";\n\t\tvar _onLoad = 0;\n\t\tif (_0x1673xa==TYPE_OBJECT) {\n\t\t\t_onLoad= new Chunk();\n\t\t\t_onLoad.type=1;\n\t\t\t_onLoad.blockList= new Array();\n\t\t}\n\t\tvar _model = this;\n\t\t\n\t\t_request.onload = function(_e) {\n\t\t\t\n\t\t\tvar _0x1673xe = [];\n\t\t\tvar _colors = undefined;\n\t\t\tvar _blocks = [];\n\t\t\t\n\t\t\tconsole.log(\"Loaded model: \"+_request.responseURL);\n\t\t\t\n\t\t\tvar _response = _request.response;\n\t\t\tif (_response) {\n\t\t\t\tvar _blockdata = new Uint8Array(_response);\n\t\t\t\tvar _0x1673x13 =_model.readInt(_blockdata,0);\n\t\t\t\tvar _0x1673x14 =_model.readInt(_blockdata,4);\n\t\t\t\tvar _0x1673x15 = 8;\n\t\t\t\t\n\t\t\t\twhile (_0x1673x15<_blockdata.length) {\n\t\t\t\t\tvar _mesh = false;\n\t\t\t\t\tvar _0x1673x17=0;\n\t\t\t\t\tvar _0x1673x18=0;\n\t\t\t\t\tvar _0x1673x19=0;\n\t\t\t\t\tvar _0x1673x1a=String.fromCharCode(parseInt(_blockdata[_0x1673x15++]))+String.fromCharCode(parseInt(_blockdata[_0x1673x15++]))+String.fromCharCode(parseInt(_blockdata[_0x1673x15++]))+String.fromCharCode(parseInt(_blockdata[_0x1673x15++]));\n\t\t\t\t\tvar _0x1673x1b=_model.readInt(_blockdata,_0x1673x15)&255;_0x1673x15+=4;\n\t\t\t\t\tvar _0x1673x1c=_model.readInt(_blockdata,_0x1673x15)&255;_0x1673x15+=4;\n\t\t\t\t\t\n\t\t\t\t\tif (_0x1673x1a==\"SIZE\") {\n\t\t\t\t\t\t_0x1673x17=_model.readInt(_blockdata,_0x1673x15)&255;\n\t\t\t\t\t\t_0x1673x15+=4;\n\t\t\t\t\t\t_0x1673x18=_model.readInt(_blockdata,_0x1673x15)&255;\n\t\t\t\t\t\t_0x1673x15+=4;_0x1673x19=_model.readInt(_blockdata,_0x1673x15)&255;\n\t\t\t\t\t\t_0x1673x15+=4;\n\t\t\t\t\t\tif (_0x1673x17>32||_0x1673x18>32) {\n\t\t\t\t\t\t\t_mesh=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_0x1673x15+=_0x1673x1b-4*3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (_0x1673x1a==\"XYZI\") {\n\t\t\t\t\t\t\tvar _0x1673x1d=Math.abs(_model.readInt(_blockdata,_0x1673x15));\n\t\t\t\t\t\t\t_0x1673x15+=4;\n\t\t\t\t\t\t\t_blocks= new Array(_0x1673x1d);\n\t\t\t\t\t\t\tfor (var _n=0;_n<_blocks.length;_n++) {\n\t\t\t\t\t\t\t\t_blocks[_n]= new VoxelData();\n\t\t\t\t\t\t\t\t_blocks[_n].Create(_blockdata,_0x1673x15,_mesh);\n\t\t\t\t\t\t\t\t_0x1673x15+=4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (_0x1673x1a==\"RGBA\") {\n\t\t\t\t\t\t\t\t_colors= new Array(256);\n\t\t\t\t\t\t\t\tfor (var _n = 0;_n < 256; _n++){\n\t\t\t\t\t\t\t\t\tvar _0x1673x1f = _blockdata[_0x1673x15++]&255;\n\t\t\t\t\t\t\t\t\tvar _0x1673x20 = _blockdata[_0x1673x15++]&255;\n\t\t\t\t\t\t\t\t\tvar _0x1673x21 = _blockdata[_0x1673x15++]&255;\n\t\t\t\t\t\t\t\t\tvar _0x1673x22 = _blockdata[_0x1673x15++]&255;\n\t\t\t\t\t\t\t\t\t_colors[_n] = { r:_0x1673x1f,g:_0x1673x20,b:_0x1673x21,a:_0x1673x22 }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {_0x1673x15+=_0x1673x1b; }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (_blocks==null||_blocks.length==0) { return null }\n\t\t\t\t\n\t\t\t\tvar totalBlocks = 0;\n\t\t\t\t\n\t\t\t\tfor (var _n = 0; _n < _blocks.length; _n++) {\n\t\t\t\t\tif (_colors==undefined) {\n\t\t\t\t\t\tvar _color = _colors[Math.abs(_blocks[_n].color-1)];\n\t\t\t\t\t\tvar _rgb = { b:(_color & 16711680) >> 16, g:(_color & 65280) >> 8, r:(_color & 255), a:1 }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar _color = _colors[Math.abs(_blocks[_n].color-1)];\n\t\t\t\t\t\tvar _lengthx = _blocks[_n].x;\n\t\t\t\t\t\tvar _lengthy = _blocks[_n].y;\n\t\t\t\t\t\tvar _lengthz = _blocks[_n].z;\n\t\t\t\t\t\tif (_0x1673xa==TYPE_MAP) {\n\t\t\t\t\t\t\tfor (var _x = _lengthx*2+1; _x < _lengthx*2+3; _x++) {\n\t\t\t\t\t\t\t\tfor (var _y = _lengthz*2+1;_y < _lengthz*2+3; _y++) {\n\t\t\t\t\t\t\t\t\tfor (var _z=_lengthy*2+1;_z < _lengthy*2+3;_z++) {\n\t\t\t\t\t\t\t\t\t\tgame.world.AddBlock(_x,_y,195-_z,[_color.r,_color.g,_color.b]);\n\t\t\t\t\t\t\t\t\t\ttotalBlocks++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (_0x1673xa==TYPE_OBJECT) {\n\t\t\t\t\t\t\t\tvar _object= new Object();\n\t\t\t\t\t\t\t\t_object.x=_lengthx+5;\n\t\t\t\t\t\t\t\t_object.y=_lengthy+10;\n\t\t\t\t\t\t\t\t_object.z=_lengthz+7;\n\t\t\t\t\t\t\t\t_object.color=[_color.r,_color.g,_color.b];\n\t\t\t\t\t\t\t\tgame.world.AddBlock(_lengthx+5,_lengthz+5,_lengthy+10,[_color.r,_color.g,_color.b]);\n\t\t\t\t\t\t\t\t_onLoad.blockList.push(_object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// totalBlocks = _0x1673x23\n\t\t\t\tconsole.log(\"TOTAL BLOCKS: \",totalBlocks);\n\t\t\t\t\n\t\t\t\tif (_0x1673xa==TYPE_OBJECT) {\n\t\t\t\t\t_onLoad.dirty=true;\n\t\t\t\t\t_onLoad.fromX=1000;\n\t\t\t\t\t_onLoad.fromY=1000;\n\t\t\t\t\t_onLoad.fromZ=1000;\n\t\t\t\t\t_onLoad.type=CHUNK_OBJECT;\n\t\t\t\t\tfor(var _0x1673x2d=0; _0x1673x2d<_onLoad.blockList.length; _0x1673x2d++) {\n\t\t\t\t\t\tvar _block=_onLoad.blockList[_0x1673x2d];\n\t\t\t\t\t\t_block.val = game.world.blocks[_block.x][_block.y][_block.z];\n\t\t\t\t\t\tif (_block.x<_onLoad.fromX) {\n\t\t\t\t\t\t\t_onLoad.fromX=_block.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_block.x>_onLoad.toX) {\n\t\t\t\t\t\t\t_onLoad.toX=_block.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_block.y>_onLoad.toY) {\n\t\t\t\t\t\t\t_onLoad.toY=_block.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_block.y<_onLoad.fromZ) {\n\t\t\t\t\t\t\t_onLoad.fromZ=_block.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_block.z<_onLoad.fromY) {\n\t\t\t\t\t\t\t_onLoad.fromY=_block.z; \n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_block.z>_onLoad.toZ) {\n\t\t\t\t\t\t\t_onLoad.toZ=_block.z;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t_onLoad.fromX-=2;\n\t\t\t\t\t_onLoad.fromZ-=6;_onLoad.fromY -= 2;\n\t\t\t\t\t_onLoad.toX+=2;_onLoad.toY += 4;\n\t\t\t\t\t_onLoad.toZ+=8;game.world.RebuildChunk(_onLoad);\n\t\t\t\t\t_onLoad.mesh.visible = false;\n\t\t\t\t\t_filename(_model,_response,_onLoad);\n\t\t\t\t} else {\n\t\t\t\t\tgame.world.RebuildDirtyChunks(1);\n\t\t\t\t\t_filename(_model,_response);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_request.onerror = function() { alert(\"BufferLoader: XHR error\") }\n\t\t\t}\n\t\t}\n\t\t\n\t\t_request.send();\n\t}\n};\n\nVox.prototype = new Vox();\nVox.prototype.constructor = Vox;\n\n\n/////* _________________________________ Sound ______________________________________ */////\n\n\nfunction SoundLoader() {\n\tthis.sounds = new Array();\n\tthis.context;\n\tthis.muted = false;\n\t\n\tSoundLoader.prototype.StopSound = function(_file) {\n\t\tvar _context = this.sounds[_file].context;\n\t\t_context.stop=_context.noteOff;\n\t\t_context.stop(0)\n\t};\n\t\n\tSoundLoader.prototype.PlaySound = function(_arraybuffer,_context,_distance) {\n\t\tvar _sound = this.sounds[_arraybuffer].context.createBufferSource();\n\t\t_sound.buffer = this.sounds[_arraybuffer].buffer;\n\t\tvar _soundbuffer = this.sounds[_arraybuffer].context.createGain();\n\t\t_sound.connect(_soundbuffer);\n\t\t_soundbuffer.connect(this.sounds[_arraybuffer].context.destination);\n\t\tif (_context != undefined) {\n\t\t\tvar _onLoad = game.camera.localToWorld( new THREE.Vector3(0,0,0));\n\t\t\tvar _range=_context.distanceTo(_onLoad);\n\t\t\tif (_range<=_distance) {\n\t\t\t\tvar _volume=1*(1-_range/_distance);\n\t\t\t\t_soundbuffer.gain.value=_volume;\n\t\t\t\t_sound.start(0);\n\t\t\t} else {\n\t\t\t\t_soundbuffer.gain.value=0;\n\t\t\t}\n\t\t} else {\n\t\t\t_soundbuffer.gain.value=1;\n\t\t\t_sound.start(0);\n\t\t}\n\t};\n\t\n\tSoundLoader.prototype.Add = function(_context) {\n\t\tthis.sounds[_context.name]= new Object();\n\t\twindow.AudioContext=window.AudioContext || window.webkitAudioContext;\n\t\tif (this.context==undefined) {\n\t\t\tthis.context= new AudioContext();\n\t\t}\n\t\tvar _sound= new BufferLoader(this.context,[_context.file],this.Load.bind(this,_context.name));\n\t\tthis.sounds[_context.name].context = this.context;\n\t\t_sound.load();\n\t};\n\t\n\tSoundLoader.prototype.Load = function(_context,_sound) {\n\t\tthis.sounds[_context].buffer=_sound[0];\n\t};\n};\n\n/////* _________________________________ Buffer ______________________________________ */////\n\n\nfunction BufferLoader(_context,_urlList,_onLoad) {\n\t// _context = _0x1673x6\n\tthis.context = _context;\n\t// _urlList = _0x1673x4\n\tthis.urlList = _urlList;\n\t// _onLoad = _0x1673x5\n\tthis.onload = _onLoad;\n\tthis.bufferList= new Array();\n\tthis.loadCount=0;\n\t\n\tBufferLoader.prototype.loadBuffer = function(_filename,_0x1673xa) {\n\t\tconsole.log(\"URL: \" + _filename);\n\t\t// _request = _0x1673xc\n\t\tvar _request = new XMLHttpRequest();\n\t\t_request.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\t\n\t\t_request.open(\"GET\",_filename);\n\t\t\n\t\t// _request.addEventListener(\"load\", this);\n\t\t\n\t\t_request.responseType = \"arraybuffer\";\n\t\t\n\t\t// _arraybuffer = _0x1673x9\n\t\tvar _arraybuffer = this;\n\t\t\n\t\t_request.onload = function(_e) {\n\t\t\t// alert(_request);\n\t\t\t_arraybuffer.context.decodeAudioData(_request.response,function(_request) {\n\t\t\t\tif (!_request) {\n\t\t\t\t\talert(\"error decoding file data: \"+_filename);\n\t\t\t\t\treturn;\n\t\t\t\t};\n\t\t\t\t_arraybuffer.bufferList[_0x1673xa]=_request;\n\t\t\t\tif (++_arraybuffer.loadCount==_arraybuffer.urlList.length) {\n\t\t\t\t\t_arraybuffer.onload(_arraybuffer.bufferList);\n\t\t\t\t}\n\t\t\t},function(_request) {\n\t\t\t\tconsole.log(\"ERROR FOR URL: \"+_filename);\n\t\t\t\tconsole.log(\"decodeAudioData error\",_request);\n\t\t\t});\n\t\t};\n\t\t\n\t\t_request.onerror = function() { alert(\"BufferLoader: XHR error\") }\n\t\t\n\t\t_request.send();\n\t};\n\t\n\t// two?\n\tBufferLoader.prototype.load = function() {\n\t\tfor (var _arraybuffer=0; _arraybuffer<this.urlList.length; ++_arraybuffer) {\n\t\t\tthis.loadBuffer(this.urlList[_arraybuffer],_arraybuffer);\n\t\t}\n\t};\n};\n\n\nvar lfsr = (function() {\n\t\n\tvar _urlList=Math.pow(2,16),_arraybuffer=0,_context,_onLoad;\n\t\n\treturn { setSeed:function(_0x1673xa) {\n\t\t\n\t\t_onLoad = _context = _0x1673xa||Math.round(Math.random()*_urlList)},rand:function() {\n\t\t\tvar _0x1673xa;\n\t\t\t_0x1673xa=((_onLoad>>0)^(_onLoad>>2)^(_onLoad>>3)^(_onLoad>>5))&1;\n\t\t\t_onLoad=(_onLoad>>1)|(_0x1673xa<<15);\n\t\t\t_arraybuffer++;\n\t\t\treturn _onLoad/_urlList;\t\n\t\t}\n\t}\n}());\n\nlfsr.setSeed();\n\n\n/////* _________________________________ Player ______________________________________ */////\n\n\nfunction Player() {\n\tthis.name = \"John Doe\";\n\tthis.hp = 0;\n\tthis.weapon = WEAPON_NONE;\n\tthis.rotateAngle = 0;\n\tthis.moveDistance = 0;\n\t\n\t// chunks\n\tthis.run1Chunk = undefined;\n\tthis.run2Chunk = undefined;\n\tthis.run1RocketChunk = undefined;\n\tthis.run2RocketChunk = undefined;\n\tthis.run1ShotgunChunk = undefined;\n\tthis.run2ShotgunChunk = undefined;\n\tthis.jumpChunk = undefined;\n\tthis.jumpRocketChunk = undefined;\n\tthis.jumpShotgunChunk = undefined;\n\tthis.standChunk = undefined;\n\tthis.standRocketChunk = undefined;\n\tthis.standShotgunChunk = undefined;\n\tthis.fallChunk = undefined;\n\tthis.fallRocketChunk = undefined;\n\tthis.fallShotgunChunk = undefined;\n\tthis.shootChunk = undefined;\n\tthis.shootRocketChunk = undefined;\n\tthis.shootShotgunChunk = undefined;\n\tthis.chunk = undefined;\n\t\n\tthis.currentModel = MODEL_STAND;\n\tthis.runTime = 0;\n\tthis.jumpTime = 0;\n\tthis.cameraAttached = false;\n\tthis.camera = new THREE.Object3D();\n\tthis.mass = 4;\n\tthis.area = 1;\n\tthis.vy = 1;\n\tthis.avg_ay = 1;\n\tthis.gravity = 9.82;\n\tthis.airDensity = 1.2;\n\tthis.jumping = false;\n\tthis.keyboard = new THREEx.KeyboardState();\n\tthis.shooting = false;\n\tthis.attachedCamera = false;\n\tthis.cameraObj = undefined;\n\tthis.canWalkLeft = true;\n\tthis.canWalkRight = true;\n\tthis.canWalkForward = true;\n\tthis.canWalkBackward = true;\n\tthis.canJump = true;\n\tthis.canFall = true;\n\t\n\t// this.player = undefined;\n\tthis.mesh = undefined;\n\t\n\tPlayer.prototype.Init = function(_name) {\n\t\t\n\t\tthis.AddBindings();\n\t\tthis.name = _name;\n\t\tthis.hp = MAX_HP;\n\t\t\n\t\tvar _chunkArray = [this.run1Chunk,this.run2Chunk,this.run1RocketChunk,this.run2RocketChunk,this.run1ShotgunChunk,this.run2ShotgunChunk,this.jumpChunk,this.jumpRocketChunk,this.jumpShotgunChunk,this.standChunk,this.standRocketChunk,this.standShotgunChunk,this.fallChunk,this.fallRocketChunk,this.fallShotgunChunk,this.shootChunk,this.shootRocketChunk,this.shootShotgunChunk];\n\t\t\n\t\tfor (var _n = 0; _n < _chunkArray.length; _n++) {\n\t\t\t\n\t\t\t// reset all chunks\n\t\t\tvar _player = _chunkArray[_n].mesh;\n\t\t\t_player.position.set(0,0,0);\n\t\t\t_player.rotation.set(0,0,0);\n\t\t\t_player.geometry.center();\n\t\t\t_player.geometry.verticesNeedUpdate = true;\n\t\t}\n\t\t\n\t\tthis.SwitchModel(MODEL_STAND);\n\t\tthis.mesh.position.set(153,21,55);\n\t\tthis.cameraObj = new THREE.Object3D();\n\t\tthis.cameraObj.add(game.camera);\n\t\tthis.attachedCamera = true;\n\t\tgame.camera.position.set(0,400,0);\n\t\tgame.camera.lookAt(this.cameraObj);\n\t\tgame.camera.rotation.set(-1.57,0,0),game.camera.quaternion.set(-0.7,0,0,0.7);\n\t\tthis.cameraObj.rotation.set(Math.PI/1.5,0,-Math.PI);\n\t\tthis.weapon = WEAPON_NONE;\n\t\tvar _playerX = this.mesh.position.x+6|0;\n\t\tvar _playerY = this.mesh.position.y+3|0;\n\t\tvar _playerZ = this.mesh.position.z+6|0;\n\t\tvar _vector = new THREE.Vector3(-1,-3,-3);\n\t\tvar _player =_vector.applyMatrix4(this.mesh.matrix);\n\t\tvar _onLoad = new THREE.PointLight(16763904,1,10);\n\t\t_onLoad.position.set(_player.x,_player.y+1,_player.z);\n\t\tthis.jumpChunk.mesh.add(_onLoad.clone());\n\t\tthis.jumpRocketChunk.mesh.add(_onLoad.clone());\n\t\tthis.jumpShotgunChunk.mesh.add(_onLoad.clone());\n\t\tvar _context = _onLoad.clone();\n\t\t_context.position.set(_player.x,_player.y,_player.z + 4);\n\t\tthis.shootShotgunChunk.mesh.add(_onLoad.clone());\n\t\t\n\t};\n\t\t\n\tPlayer.prototype.SwitchWeapon = function(_urlList) {\n\t\tthis.weapon=_urlList;\n\t\tthis.SwitchModel(MODEL_STAND);\n\t};\n\t\n\tPlayer.prototype.SwitchModel = function(_context) {\n\t\tif (this.shooting){ return }\n\t\tif (this.currentModel==_context&&this.mesh!=undefined){ return }\n\t\tvar _onLoad,_urlList;\n\t\tif (this.mesh!=undefined) {\n\t\t\tthis.mesh.remove(this.cameraObj);\n\t\t\tthis.mesh.visible = false;\n\t\t\t_onLoad = this.mesh.position;\n\t\t\t_urlList = this.mesh.rotation;\n\t\t} else {\n\t\t\t_onLoad= new THREE.Vector3(0,0,0);\n\t\t\t_urlList= new THREE.Vector3(0,0,0);\n\t\t}\n\t\t\n\t\tswitch (_context) {\n\t\t\tcase MODEL_JUMP:switch(this.weapon) {\n\t\t\t\tcase WEAPON_SHOTGUN:this.mesh=this.jumpShotgunChunk.mesh;\n\t\t\t\t\tthis.chunk=this.jumpShotgunChunk; break;\n\t\t\t\tcase WEAPON_ROCKET:this.mesh=this.jumpRocketChunk.mesh;\n\t\t\t\t\tthis.chunk=this.jumpRocketChunk; break;\n\t\t\t\tcase WEAPON_NONE:this.mesh=this.jumpChunk.mesh;\n\t\t\t\t\tthis.chunk=this.jumpChunk; break\n\t\t\t}; break;\n\t\t\t\n\t\t\tcase MODEL_STAND:switch(this.weapon) {\n\t\t\t\tcase WEAPON_SHOTGUN:this.mesh=this.standShotgunChunk.mesh;\n\t\t\t\t\tthis.chunk=this.standShotgunChunk; break;\n\t\t\t\tcase WEAPON_ROCKET:this.mesh=this.standRocketChunk.mesh;\n\t\t\t\t\tthis.chunk=this.standRocketChunk; break;\n\t\t\t\tcase WEAPON_NONE:this.mesh=this.standChunk.mesh;\n\t\t\t\t\tthis.chunk=this.standChunk; break\n\t\t\t\t}; break;\n\t\t\t\t\n\t\t\tcase MODEL_RUN1:switch(this.weapon) {\n\t\t\t\tcase WEAPON_SHOTGUN:this.mesh=this.run1ShotgunChunk.mesh;\n\t\t\t\t\tthis.chunk=this.run1ShotgunChunk; break;\n\t\t\t\tcase WEAPON_ROCKET:this.mesh=this.run1RocketChunk.mesh;\n\t\t\t\t\tthis.chunk=this.run1RocketChunk; break;\n\t\t\t\tcase WEAPON_NONE:this.mesh=this.run1Chunk.mesh;\n\t\t\t\t\tthis.chunk=this.run1Chunk; break\n\t\t\t\t}; break;\n\t\t\t\n\t\t\tcase MODEL_RUN2:switch(this.weapon) {\n\t\t\t\tcase WEAPON_SHOTGUN:this.mesh=this.run2ShotgunChunk.mesh;\n\t\t\t\t\tthis.chunk=this.run2ShotgunChunk; break;\n\t\t\t\tcase WEAPON_ROCKET:this.mesh=this.run2RocketChunk.mesh;\n\t\t\t\t\tthis.chunk=this.run2RocketChunk; break;\n\t\t\t\tcase WEAPON_NONE:this.mesh=this.run2Chunk.mesh;\n\t\t\t\t\tthis.chunk=this.run2Chunk; break;\n\t\t\t\t}; break;\n\t\t\t\t\n\t\t\tcase MODEL_SHOOT:switch(this.weapon) {\n\t\t\t\tcase WEAPON_SHOTGUN:this.mesh=this.shootShotgunChunk.mesh;\n\t\t\t\t\tthis.chunk=this.shootShotgunChunk; break;\n\t\t\t\tcase WEAPON_ROCKET:this.mesh=this.shootRocketChunk.mesh;\n\t\t\t\t\tthis.chunk=this.shootRocketChunk; break;\n\t\t\t\tcase WEAPON_NONE:this.mesh=this.shootChunk.mesh;\n\t\t\t\t\tthis.chunk=this.shootChunk; break;\n\t\t\t}; break;\n\t\t\t\n\t\t\tcase MODEL_FALL:switch(this.weapon) {\n\t\t\t\tcase WEAPON_SHOTGUN:this.mesh=this.fallShotgunChunk.mesh;\n\t\t\t\t\tthis.chunk=this.fallShotgunChunk; break;\n\t\t\t\tcase WEAPON_ROCKET:this.mesh=this.fallRocketChunk.mesh;\n\t\t\t\t\tthis.chunk=this.fallRocketChunk; break;\n\t\t\t\tcase WEAPON_NONE:this.mesh=this.fallChunk.mesh;\n\t\t\t\t\tthis.chunk=this.fallChunk; break;\n\t\t\t}; break;\n\t\t\n\t\tdefault:this.mesh = this.standChunk.mesh;\n\t\tthis.chunk = this.standChunk};\n\t\tthis.mesh.position.set(_onLoad.x,_onLoad.y,_onLoad.z);\n\t\tthis.mesh.rotation.set(_urlList.x,_urlList.y,_urlList.z);\n\t\tthis.currentModel = _context;\n\t\tthis.mesh.updateMatrixWorld();\n\t\tthis.mesh.add(this.cameraObj);\n\t\tthis.mesh.visible = true;\n\t};\n\t\n\tPlayer.prototype.AddBindings = function() {\n\t\t$(document).mouseup(this.OnMouseUp.bind(this));\n\t\t$(document).mousemove(this.OnMouseMove.bind(this));\n\t\t$(document).mousedown(this.OnMouseDown.bind(this));\n\t};\n\t\n\tPlayer.prototype.RemoveBindings = function() {\n\t\t$(document).unbind(mouseup);\n\t\t$(document).unbind(mousemove);\n\t\t$(document).unbind(mousedown);\n\t};\n\t\n\tPlayer.prototype.OnMouseMove = function(_context) {\n\t\t// _mouseMove = _0x1673x8\n\t\tvar _mouseMove = _context.originalEvent;\n\t\tvar _mx = _mouseMove.movementX || _mouseMove.mozMovementX || 0;\n\t\tvar _mz = _mouseMove.movementZ || _mouseMove.mozMovementZ || 0;\n\t\tvar _rotate = _mx * 0.0075;\n\t\tvar _my = _mz * 0.001;\n\t\tif (this.mesh != undefined) {\n\t\t\tvar _vector = new THREE.Vector3(0,1,0);\n\t\t\tvar _onLoad = new THREE.Matrix4();\n\t\t\t_onLoad.makeRotationAxis(_vector.normalize(),-(Math.PI/2)*_rotate);\n\t\t\tthis.mesh.matrix.multiply(_onLoad);\n\t\t\tthis.mesh.rotation.setFromRotationMatrix(this.mesh.matrix);\n\t\t}\n\t};\n\t\n\tPlayer.prototype.OnMouseDown = function(_e){\n\t\tif (this.dead) { return }\n\t\tvar _button =_e.keyCode||_e.which;\n\t\tif (_button!=1) { return }\n\t\tthis.SwitchModel(MODEL_SHOOT);\n\t\tthis.shooting = true;\n\t};\n\t\n\tPlayer.prototype.OnMouseUp = function(_e) {\n\t\tif (this.dead) { return }\n\t\tvar _button = _e.keyCode || _e.which;\n\t\tif (_button==1) {\n\t\t\tswitch(this.weapon) {\n\t\t\t\tcase WEAPON_ROCKET:this.CreateMissile(); break;\n\t\t\t\tcase WEAPON_SHOTGUN:this.CreateShot(); break;\n\t\t\t}\n\t\t\tthis.shooting=false;\n\t\t} else {\n\t\t\tif (_button==3) { this.CreateGrenade(); }\n\t\t}\n\t};\n\t\n\tPlayer.prototype.CreateGrenade = function() {\n\t\t\n\t\tvar _onLoad = game.phys.Get();\n\t\tvar _vector = new THREE.Vector3(3,2,5);\n\t\t\n\t\t// matrix undefined\n\t\tvar _context = _vector.applyMatrix4(this.mesh.matrix);\n\t\t\n\t\tif (_onLoad!=undefined) {\n\t\t\t_onLoad.Create(_context.x,_context.y,_context.z,0,66,0,5,4,PHYS_GRENADE,5,0.1);\n\t\t\t_onLoad.mesh.scale.set(1.5,1.5,1.5);\n\t\t\tgame.sound.PlaySound(\"threw\",this.mesh.position,500);\n\t\t\tvar _urlList= new THREE.PointLight(16763904,1,50);\n\t\t\t_urlList.position.set(0,0,0);\n\t\t\t_onLoad.mesh.light=_urlList;\n\t\t\t_onLoad.mesh.add(_urlList);\n\t\t}\n\t};\n\t\n\tPlayer.prototype.CreateShot=function() {\n\t\t\n\t\tvar _vect1= new THREE.Vector3(3,0,3);\n\t\tvar _vec1=_vect1.applyMatrix4(this.mesh.matrix);\n\t\t\n\t\tvar _vect2= new THREE.Vector3(-3,0,3);\n\t\tvar _vec2=_vect2.applyMatrix4(this.mesh.matrix);\n\t\t\n\t\tfor (var _n = 0; _n < 5; _n++) {\n\t\t\t// \n\t\t\tvar _urlList=game.phys.Get();\n\t\t\tvar _onLoad=150+lfsr.rand()*105|0;\n\t\t\tif (_urlList!=undefined) {\n\t\t\t\t_urlList.gravity= -1;\n\t\t\t\t_urlList.Create(_vec1.x,_vec1.y+1,_vec1.z,_onLoad,_onLoad,_onLoad,lfsr.rand()*1,1,PHYS_SMOKE);\n\t\t\t}\n\t\t\t//\n\t\t\tvar _mouseMove = game.phys.Get();\n\t\t\tvar _onLoad=150+lfsr.rand()*105|0;\n\t\t\tif (_mouseMove!=undefined) {\n\t\t\t\t_mouseMove.gravity= -1;\n\t\t\t\t_mouseMove.Create(_vec2.x,_vec2.y+1,_vec2.z,_onLoad,_onLoad,_onLoad,lfsr.rand()*1,1,PHYS_SMOKE);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (var _n = 0; _n < 5; _n++) {\n\t\t\t//\n\t\t\tvar _0x1673x2c=game.phys.Get();\n\t\t\tif (_0x1673x2c!=undefined) {\n\t\t\t\t_0x1673x2c.Create(_vec1.x+(2-lfsr.rand()*4),_vec1.y+(2-lfsr.rand()*4),_vec1.z+(2-lfsr.rand()*4),0,0,0,20,0.4,PHYS_SHOT,1);\n\t\t\t\t_0x1673x2c.mesh.scale.set(0.5,0.5,0.5);\n\t\t\t}\n\t\t\t//\n\t\t\tvar _context=game.phys.Get();\n\t\t\tif (_context!=undefined){\n\t\t\t\t_context.Create(_vec2.x+(2-lfsr.rand()*4),_vec2.y+(2-lfsr.rand()*4),_vec2.z+(2-lfsr.rand()*4),0,0,0,20,0.4,PHYS_SHOT,1);\n\t\t\t\t_context.mesh.scale.set(0.5,0.5,0.5);\n\t\t\t}\n\t\t}\n\t\tgame.sound.PlaySound(\"shotgun_shoot\",this.mesh.position,500);\n\t};\n\t\t\t\t\t\t\n\tPlayer.prototype.CreateMissile = function() {\n\t\tvar _mouseMove=game.phys.Get();\n\t\tvar _request= new THREE.Vector3(3,2,5);\n\t\tvar _0x1673xa=_request.applyMatrix4(this.mesh.matrix);\n\t\t\n\t\tif (_mouseMove!=undefined) {\n\t\t\tfor (var _onLoad=0;_onLoad<20;_onLoad++) {\n\t\t\t\tvar _arraybuffer=game.phys.Get();\n\t\t\t\tvar _context=150+lfsr.rand()*105|0;\n\t\t\t\tif (_arraybuffer!=undefined) {\n\t\t\t\t\t_arraybuffer.gravity= -1;\n\t\t\t\t\t_arraybuffer.Create(_0x1673xa.x,_0x1673xa.y+1,_0x1673xa.z,_context,_context,_context,lfsr.rand()*1,1,PHYS_SMOKE);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_mouseMove.Create(_0x1673xa.x,_0x1673xa.y,_0x1673xa.z,255,140,0,20,1,PHYS_MISSILE,1);\n\t\t\tvar _urlList= new THREE.PointLight(16763904,0.5,50);\n\t\t\t_urlList.position.set(0,10,0);\n\t\t\t_mouseMove.mesh.light=_urlList;\n\t\t\t_mouseMove.mesh.add(_urlList);\n\t\t}\n\t\t\n\t\tgame.sound.PlaySound(\"rocket_shoot\",this.mesh.position,550);\n\t};\n\t\t\n\tPlayer.prototype.ChangeWeapon = function(_urlList){\n\t\tthis.weapon=_urlList;\n\t};\n\t\t\n\tPlayer.prototype.CanMove = function(_mouseMove) {\n\t\tfor (var _0x1673xa=0;_0x1673xa<this.chunk.blockList.length;_0x1673xa+=2) {\n\t\t\tvar _urlList=this.chunk.blockList[_0x1673xa];\n\t\t\tif (_mouseMove==MOVE_FORWARD&&_urlList.z<11) { continue;\n\t\t\t} else {\n\t\t\t\tif (_mouseMove==MOVE_BACKWARD&&_urlList.z>7) { continue;\n\t\t\t\t}else {\n\t\t\t\t\tif (_mouseMove==MOVE_LEFT&&_urlList.x<10) { continue;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tif (_mouseMove==MOVE_RIGHT&&_urlList.x>5) { continue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (_mouseMove==MOVE_UP&&(_urlList.x<6||_urlList.x>7||_urlList.z>9)) { continue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (_mouseMove==MOVE_DOWN&&_urlList.y-3>2){ continue; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar _vector= new THREE.Vector3(_urlList.x-7,_urlList.y-10,_urlList.z-10);\n\t\t\tvar _context=_vector.applyMatrix4(this.mesh.matrix);\n\t\t\tvar _onLoad=_context.x|0;var _arraybuffer=_context.y|0;\n\t\t\tvar _request=_context.z|0;\n\t\t\t_onLoad+=7;\n\t\t\t_request+=10;\n\t\t\tif (_mouseMove==MOVE_UP) { _arraybuffer+=2 }\n\t\t\tif (game.world.IsWithinWorld(_onLoad,_arraybuffer,_request)) {\n\t\t\t\tif ((game.world.blocks[_onLoad][_arraybuffer][_request]>>8)!=0) { return false; }\n\t\t\t} else { return false; }\n\t\t};\n\t\treturn true;\n\t};\n\t\n\tPlayer.prototype.KeyDown = function() {\n\t\tif (this.keyboard.pressed(\"1\")) { this.weapon=WEAPON_ROCKET; }\n\t\tif (this.keyboard.pressed(\"2\")) { this.weapon=WEAPON_SHOTGUN; }\n\t\tif (this.keyboard.pressed(\"3\")) { this.weapon=WEAPON_NONE; }\n\t\tif (this.keyboard.pressed(\"K\")) { this.Die(); }\n\t\tif (this.keyboard.pressed(\"n\")) { this.mesh.position.x+=5; }\n\t\tif (this.keyboard.pressed(\"m\")) { this.mesh.position.x-=5; }\n\t\tif (this.keyboard.pressed(\"p\")) { console.log(this.mesh.position); }\n\t\tif (this.keyboard.pressed(\"W\")&&this.canWalkForward) {\n\t\t\tthis.mesh.translateZ(this.moveDistance);\n\t\t\tif (!this.CanMove(MOVE_FORWARD)) {\n\t\t\t\tthis.mesh.translateZ(-this.moveDistance);\n\t\t\t}\n\t\t\tthis.Run();\n\t\t}\n\t\tif (this.keyboard.pressed(\"S\")&&this.canWalkBackward) {\n\t\t\tthis.mesh.translateZ(-this.moveDistance);\n\t\t\tif (!this.CanMove(MOVE_BACKWARD)) {\n\t\t\t\tthis.mesh.translateZ(this.moveDistance);\n\t\t\t}\n\t\t\tthis.Run();\n\t\t}\n\t\tif (this.keyboard.pressed(\"A\")&&this.canWalkLeft) {\n\t\t\tthis.mesh.translateX(this.moveDistance);\n\t\t\tif (!this.CanMove(MOVE_LEFT)) {\n\t\t\t\tthis.mesh.translateX(-this.moveDistance);\n\t\t\t}\n\t\t\tthis.Run();\n\t\t}\n\t\tif (this.keyboard.pressed(\"D\")&&this.canWalkRight) {\n\t\t\tthis.mesh.translateX(-this.moveDistance);\n\t\t\tif (!this.CanMove(MOVE_RIGHT)){\n\t\t\t\tthis.mesh.translateX(this.moveDistance);\n\t\t\t}\n\t\t\tthis.Run();\n\t\t}\n\t\tif (this.keyboard.pressed(\"space\")) {\n\t\t\tthis.jumpTime = 0;\n\t\t\tthis.mesh.translateY(this.moveDistance);\n\t\t\tvar _0x1673xf=Math.round(this.mesh.position.x+6);\n\t\t\tvar _onLoad=Math.round(this.mesh.position.y+3);\n\t\t\tvar _context=Math.round(this.mesh.position.z+6);\n\t\t\tif (!this.CanMove(MOVE_UP)) {\n\t\t\t\tthis.mesh.translateY(-this.moveDistance);\n\t\t\t}\n\t\t\tthis.SwitchModel(MODEL_JUMP);\n\t\t\tthis.jumping = true;\n\t\t\tthis.canFall = true;\n\t\t\tvar _request= new THREE.Vector3(-1,-3,-3);\n\t\t\tvar _0x1673x2c=_request.applyMatrix4(this.mesh.matrix);\n\t\t\tvar _arraybuffer= new THREE.Vector3(1,-3,-3);\n\t\t\tvar _mouseMove=_arraybuffer.applyMatrix4(this.mesh.matrix);\n\t\t\t\n\t\t\tfor (var _urlList=0;_urlList<5;_urlList++) {\n\t\t\t\tvar _0x1673x1c=game.phys.Get();\n\t\t\t\tvar _0x1673xa=game.phys.Get();\n\t\t\t\tif (_0x1673x1c!=undefined) {\n\t\t\t\t\t_0x1673x1c.gravity= -1;\n\t\t\t\t\t_0x1673x1c.Create(_0x1673x2c.x,_0x1673x2c.y+1,_0x1673x2c.z,255,255,255,-lfsr.rand()*10,0.2,PHYS_SMOKE);\n\t\t\t\t}\n\t\t\t\tif (_0x1673xa!=undefined) {\n\t\t\t\t\t_0x1673xa.gravity= -1;\n\t\t\t\t\t_0x1673xa.Create(_mouseMove.x,_mouseMove.y+1,_mouseMove.z,255,255,255,-lfsr.rand()*10,0.2,PHYS_SMOKE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tPlayer.prototype.KeyUp = function() {\n\t\tif (this.keyboard.pressed(\"space\")) {}\n\t};\n\t\t\n\tPlayer.prototype.Run = function() {\n\t\tif (this.runTime>0.2) {\n\t\t\tif(this.currentModel==MODEL_RUN2) {\n\t\t\t\tthis.SwitchModel(MODEL_RUN1);\n\t\t\t} else {\n\t\t\t\tthis.SwitchModel(MODEL_RUN2);\n\t\t\t}\n\t\t\tthis.runTime=0;\n\t\t}\n\t};\n\t\n\tPlayer.prototype.Draw = function(_onLoad,_urlList3) {\n\t\tif (this.mesh==undefined) { return }\n\t\tthis.KeyDown();\n\t\tthis.KeyUp();\n\t\tif (this.mesh.position.x>game.world.worldSize-1) {\n\t\t\tthis.mesh.translateX(-1);\n\t\t}\n\t\tif(this.mesh.position.x<0){ this.mesh.translateX(1); }\n\t\tif(this.mesh.position.z<0){ this.mesh.translateZ(1); }\n\t\tif(this.mesh.position.z>game.world.worldSize-1) {\n\t\t\tthis.mesh.translateZ(-1);\n\t\t}\n\t\tif (this.mesh.position.y>game.world.chunkHeight-1) {\n\t\t\tthis.mesh.translateY(-1);\n\t\t}\n\t\tif (this.currentModel==MODEL_FALL) {\n\t\t\tif (lfsr.rand()>0.8) {\n\t\t\t\tvar _urlList2= new THREE.Vector3(-1,-2,-4);\n\t\t\t\tvar _0x1673x10=_urlList2.applyMatrix4(this.mesh.matrix);\n\t\t\t\tvar _player=game.phys.Get();\n\t\t\t\tif (_player!=undefined) {\n\t\t\t\t\t_player.gravity= -1;\n\t\t\t\t\t_player.Create(_0x1673x10.x,_0x1673x10.y+1,_0x1673x10.z,255,255,255,-lfsr.rand()*10,0.2,PHYS_SMOKE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lfsr.rand()>0.8) {\n\t\t\t\tvar _0x1673x1c=game.phys.Get();\n\t\t\t\tvar _request= new THREE.Vector3(1,-2,-4);\n\t\t\t\tvar _0x1673x2c=_request.applyMatrix4(this.mesh.matrix);\n\t\t\t\tif (_0x1673x1c!=undefined) {\n\t\t\t\t\t_0x1673x1c.gravity= -1;\n\t\t\t\t\t_0x1673x1c.Create(_0x1673x2c.x,_0x1673x2c.y+1,_0x1673x2c.z,255,255,255,-lfsr.rand()*10,0.2,PHYS_SMOKE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.rotateAngle=(Math.PI/1.5)*_urlList3;\n\t\tthis.moveDistance=70*_urlList3;\n\t\tthis.runTime+=_urlList3;\n\t\tthis.jumpTime+=_urlList3;\n\t\t\n\t\tif (this.runTime>0.25&&this.currentModel!=MODEL_JUMP&&this.currentModel!=MODEL_FALL) {\n\t\t\tthis.SwitchModel(MODEL_STAND);\n\t\t}\n\t\tif (this.jumpTime>0.1) { this.jumping = false; }\n\t\tvar _0x1673xf=Math.round(this.mesh.position.x+6+2);\n\t\tvar _request=Math.round(this.mesh.position.y-7);\n\t\tvar _mouseMove=Math.round(this.mesh.position.z+6+2);\n\t\tfor (var _urlList=_0x1673xf;_urlList<_0x1673xf+4;_urlList++) {\n\t\t\tfor (var _arraybuffer=_mouseMove; _arraybuffer<_mouseMove+4; _arraybuffer++) {\n\t\t\t\tif (game.world.IsWithinWorld(_urlList,_request,_arraybuffer)) {\n\t\t\t\t\tif (game.world.blocks[_urlList][_request][_arraybuffer]==0) {\n\t\t\t\t\t\tthis.canFall=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.mesh!=undefined&&this.jumping!=true&&this.canFall) {\n\t\t\tvar _context=this.mass*this.gravity;_context+=-1*0.5*this.airDensity*this.area*this.vy*this.vy;\n\t\t\tvar _0x1673x14=this.vy*_urlList3+(0.5*this.avg_ay*_urlList3*_urlList3);\n\t\t\tthis.mesh.translateY(-_0x1673x14*100);\n\t\t\tvar _0x1673xa=_context/this.mass;\n\t\t\tthis.avg_ay=0.5*(_0x1673xa+this.avg_ay);\n\t\t\tfor (var _urlList=_0x1673xf;_urlList<_0x1673xf+4;_urlList++) {\n\t\t\t\tfor (var _arraybuffer=_mouseMove;_arraybuffer<_mouseMove+4;_arraybuffer++) {\n\t\t\t\t\tif (game.world.IsWithinWorld(_urlList,_request,_arraybuffer)) {\n\t\t\t\t\t\tif (game.world.blocks[_urlList][_request][_arraybuffer]!=0) {\n\t\t\t\t\t\t\tif (this.currentModel==MODEL_FALL) {\n\t\t\t\t\t\t\t\tthis.SwitchModel(MODEL_STAND)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.mesh.translateY(_0x1673x14*100);\n\t\t\t\t\t\t\tthis.canFall = false;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.canFall=false;\n\t\t\t\t\t\tthis.SwitchModel(MODEL_STAND);\n\t\t\t\t\t\tthis.vy-=this.avg_ay*_urlList3;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.SwitchModel(MODEL_FALL);\n\t\t} else {\n\t\t\tif(this.currentModel==MODEL_FALL){\n\t\t\t\tthis.SwitchModel(MODEL_STAND);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tPlayer.prototype.Die = function() {\n\t\tgame.sound.PlaySound(\"die2\",this.mesh.position,500);\n\t\tfor (var _arraybuffer=0;_arraybuffer<this.chunk.blockList.length;_arraybuffer+=3) {\n\t\t\tvar _0x1673xf=this.chunk.blockList[_arraybuffer];\n\t\t\tvar _request= new THREE.Vector3(_0x1673xf.x-7,_0x1673xf.y-10,_0x1673xf.z-10);\n\t\t\tvar _urlList=_request.applyMatrix4(this.mesh.matrix);\n\t\t\tvar _context=_urlList.x|0;var _onLoad=_urlList.y|0;\n\t\t\tvar _0x1673xa=_urlList.z|0;_context+=7;_0x1673xa+=10;\n\t\t\tvar _mouseMove=game.phys.Get();\n\t\t\tif (_mouseMove!=undefined) {\n\t\t\t\tr=_0x1673xf.color[0];g=_0x1673xf.color[1];\n\t\t\t\tb=_0x1673xf.color[2];\n\t\t\t\t_mouseMove.Create(_urlList.x,_urlList.y,_urlList.z,r,g,b,lfsr.rand()*5,3,PHYS_DIE);\n\t\t\t}\n\t\t}\n\t\tthis.mesh.visible = false;\n\t};\n\t\n\tPlayer.prototype.Spawn = function(_urlList,_onLoad,_context) { }\n};\n\n\n/////* _________________________________ World ____________________________________ */////\n\n\nString.prototype.bin = function() { return parseInt(this,2); }\n\nNumber.prototype.bin = function() {\n\tvar _context = (this < 0 ? \"-\" : \"\");\n\tvar _urlList = Math.abs(this).toString(2);\n\twhile(_urlList.length<32){ _urlList=\"0\"+_urlList; }\n\treturn _context+_urlList;\n};\n\nfunction Chunk() {\n\tthis.mesh = undefined;\n\tthis.blocks = 0;\n\tthis.triangles = 0;\n\tthis.dirty = false;\n\tthis.fromX = 0;\n\tthis.fromZ = 0;\n\tthis.fromY = 0;\n\tthis.toX = 0;\n\tthis.toY = 0;\n\tthis.toZ = 0;\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.z = 0;\n\tthis.type = 0;\n\tthis.blockList = 0;\n};\n\nfunction World() {\n\tthis.worldSize = 192;\n\tthis.chunkBase = 16;\n\tthis.worldDivBase = this.worldSize/this.chunkBase;\n\tthis.chunkHeight = 160;\n\tthis.blocks = 0;\n\tthis.blockSize = 1;\n\tthis.material = 0;\n\tthis.chunks = undefined;\n\tthis.plane = 0;\n\tthis.ffTime = 0;\n\tthis.last = 0;\n\tthis.floodFill = new Array();\n\tthis.wireframe = false;\n\tthis.showChunks = false;\n\t\n\t\n\tWorld.prototype.Init = function() {\n\t\t\n\t\tthis.blocks= new Array();\n\t\tfor (var _n = 0; _n < this.worldSize; _n++) {\n\t\t\tthis.blocks[_n] = new Array();\n\t\t\tfor (var _x = 0; _x < this.chunkHeight; _x++) { \n\t\t\t\tthis.blocks[_n][_x] = new Array();\n\t\t\t\tfor (var _y = 0;_y < this.worldSize; _y++) {\n\t\t\t\t\tthis.blocks[_n][_x][_y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tconsole.log(\"DIVBASE: \",this.worldDivBase);\n\t\tthis.chunks= new Array(this.worldDivBase);\n\t\tfor (var _x=0;_x<this.worldDivBase;_x++) {\n\t\t\tthis.chunks[_x]= new Array(this.worldDivBase);\n\t\t\tfor (var _y=0;_y<this.worldDivBase;_y++) {\n\t\t\t\t\n\t\t\t\tthis.chunks[_x][_y]= new Chunk();\n\t\t\t\tthis.chunks[_x][_y].type=0;\n\t\t\t\tthis.chunks[_x][_y].fromZ=0;\n\t\t\t\tthis.chunks[_x][_y].toY=this.chunkHeight;\n\t\t\t\tthis.chunks[_x][_y].fromX=_x*this.blockSize*this.chunkBase;\n\t\t\t\tthis.chunks[_x][_y].toX=_x*this.blockSize*this.chunkBase+this.chunkBase;\n\t\t\t\tthis.chunks[_x][_y].fromY=_y*this.blockSize*this.chunkBase;\n\t\t\t\tthis.chunks[_x][_y].toZ=_y*this.blockSize*this.chunkBase+this.chunkBase;\n\t\t\t\tthis.chunks[_x][_y].x=_x;this.chunks[_x][_y].z=_y;\n\t\t\t}\n\t\t}\n\t\tvar _color = 4473924;\n\t\tvar _arraybuffer = new THREE.BoxGeometry(this.blockSize*this.worldSize-2,1,this.blockSize*this.worldSize-7);\n\t\tvar _material = new THREE.MeshLambertMaterial( { color: _color } );\n\t\tvar _world = new THREE.Mesh(_arraybuffer,_material);\n\t\t_world.position.set((this.worldSize/2-this.chunkBase/2),-1/2+1,this.worldSize/2-this.chunkBase/2+2);\n\t\t_world.receiveShadow=true;\n\t\tgame.scene.add(_world);\n\t\tvar _arraybuffer = new THREE.BoxGeometry(this.blockSize*this.worldSize-2,1000,this.blockSize*this.worldSize-7);\n\t\tvar _material = new THREE.MeshLambertMaterial({ color: _color });\n\t\tvar _world = new THREE.Mesh(_arraybuffer,_material);\n\t\t_world.position.set((this.worldSize/2-this.chunkBase/2),-1000/2,this.worldSize/2-this.chunkBase/2+2);\n\t\tgame.scene.add(_world);\n\t\tthis.RebuildMaterial(false);\n\t};\n\t\n\tWorld.prototype.RebuildMaterial = function(_e) {\n\t\tthis.wireframe=_e;\n\t\tthis.material= new THREE.MeshLambertMaterial( { vertexColors:THREE.VertexColors,wireframe:this.wireframe } )\n\t};\n\t\n\tWorld.prototype.PlaceObject = function(_urlList2,_request,_arraybuffer,_model) {\n\t\tfor (var _n=0; _n < _model.blockList.length; _n++) {\n\t\t\t_model.mesh.updateMatrixWorld();\n\t\t\tvar _0x1673xf = _model.blockList[_n];\n\t\t\tvar _object = new THREE.Vector3(_0x1673xf.x,_0x1673xf.y,_0x1673xf.z);\n\t\t\t_object.applyMatrix4(_model.mesh.matrixWorld);\n\t\t\tvar _0x1673xa = _object.x + game.world.blockSize*8|0;\n\t\t\tvar _context = _object.y|0;\n\t\t\tvar _0x1673x10 = _object.z + game.world.blockSize*8|0;\n\t\t\tif (_context <= 0) { _context = 1; }\n\t\t\tif (this.IsWithinWorld(_0x1673xa,_context,_0x1673x10)) {\n\t\t\t\tthis.blocks[_0x1673xa][_context][_0x1673x10]=_0x1673xf.val;\n\t\t\t\tif (_model.blockList.length > 200) {\n\t\t\t\t\tvar _playerX=(game.player.mesh.position.x+this.blockSize*8)|0;\n\t\t\t\t\tvar _playerY=(game.player.mesh.position.y+this.blockSize*8)|0;\n\t\t\t\t\tvar _playerZ=(game.player.mesh.position.z+this.blockSize*8)|0;\n\t\t\t\t\tif (_playerX==_0x1673xa&&_playerY==_context&&_playerZ==_0x1673x10) { game.player.Die(); }\n\t\t\t\t}\n\t\t\t\tthis.GetChunk(_0x1673xa,_0x1673x10).dirty = true;\n\t\t\t}\n\t\t}\n\t\tthis.RebuildDirtyChunks();\n\t};\n\t\n\tWorld.prototype.IsWithinWorld = function(_urlList,_onLoad,_context) {\n\t\tif (_urlList>0&&_urlList<game.world.worldSize-1&&_onLoad>0&&_onLoad<game.world.chunkHeight-1&&_context>4&&_context<game.world.worldSize-1) {return true;}\n\t\treturn false;\n\t};\n\t\n\tWorld.prototype.Explode = function(_0x1673x14,_0x1673x10,_0x1673x2c,_arraybuffer,_request) {\n\t\tthis.exploded = 1;\n\t\tvar _0x1673x1c=_arraybuffer*_arraybuffer;\n\t\tvar _mouseMove= new Array();\n\t\tfor (var _0x1673xa=_0x1673x14+_arraybuffer;_0x1673xa>=_0x1673x14-_arraybuffer;_0x1673xa--) {\n\t\t\tfor (var _context=_0x1673x2c+_arraybuffer;_context>=_0x1673x2c-_arraybuffer;_context--) {\n\t\t\t\tfor (var _onLoad=_0x1673x10+_arraybuffer;_onLoad>=_0x1673x10-_arraybuffer;_onLoad--) {\n\t\t\t\t\tval=(_0x1673xa-_0x1673x14)*(_0x1673xa-_0x1673x14)+(_onLoad-_0x1673x10)*(_onLoad-_0x1673x10)+(_context-_0x1673x2c)*(_context-_0x1673x2c);\n\t\t\t\t\tif (val<=_0x1673x1c) {\n\t\t\t\t\t\tthis.RemoveBlock(_0x1673xa,_onLoad,_context);\n\t\t\t\t\t\tvar _0x1673x1d=(game.player.mesh.position.x+this.blockSize*8)|0;\n\t\t\t\t\t\tvar _urlList3=(game.player.mesh.position.y-this.blockSize*8)|0;\n\t\t\t\t\t\tvar _mesh=(game.player.mesh.position.z+this.blockSize*8)|0;\n\t\t\t\t\t\tif (_0x1673x1d==_0x1673xa&&_urlList3==_onLoad&&_mesh==_context) {game.player.Die(); }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (val<_0x1673x1c+4) {\n\t\t\t\t\t\t\tif (this.IsWithinWorld(_0x1673xa,_onLoad,_context)) {\n\t\t\t\t\t\t\t\tif ((this.blocks[_0x1673xa][_onLoad][_context]>>8)!=0) {\n\t\t\t\t\t\t\t\t\tvar _urlList=(this.blocks[_0x1673xa][_onLoad][_context]>>24)&255;\n\t\t\t\t\t\t\t\t\tvar _0x1673xf=(this.blocks[_0x1673xa][_onLoad][_context]>>16)&255;\n\t\t\t\t\t\t\t\t\tvar _urlList2=(this.blocks[_0x1673xa][_onLoad][_context]>>8)&255;\n\t\t\t\t\t\t\t\t\tvar _request=10;\n\t\t\t\t\t\t\t\t\tif (_arraybuffer>5) { _request=20; }\n\t\t\t\t\t\t\t\t\tif (_urlList>20) { _urlList-=_request; }\n\t\t\t\t\t\t\t\t\tif (_0x1673xf>20) { _0x1673xf-=_request; }\n\t\t\t\t\t\t\t\t\tif (_urlList2>20){ _urlList2-=_request; }\n\t\t\t\t\t\t\t\t\tthis.blocks[_0x1673xa][_onLoad][_context]=(_urlList&255)<<24|(_0x1673xf&255)<<16|(_urlList2&255)<<8;\n\t\t\t\t\t\t\t\t\tthis.GetChunk(_0x1673xa,_context).dirty = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (val>_0x1673x1c) {\n\t\t\t\t\t\t\t\tif (this.IsWithinWorld(_0x1673xa,_onLoad,_context)) {\n\t\t\t\t\t\t\t\t\tif ((this.blocks[_0x1673xa][_onLoad][_context]>>8)!=0) {\n\t\t\t\t\t\t\t\t\t\t_mouseMove.push( new THREE.Vector3(_0x1673xa,_onLoad,_context));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (val<=_0x1673x1c/10) {\n\t\t\t\t\t\tthis.ExplosionBlock(_0x1673xa,_onLoad,_context);\n\t\t\t\t\t\tif(lfsr.rand()>0.8) {\n\t\t\t\t\t\t\tthis.SmokeBlock(_0x1673xa,_onLoad,_context);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.RebuildDirtyChunks();\n\t\tif(!_request){ this.floodFill.push(_mouseMove); }\n\t};\n\t\n\tWorld.prototype.DrawStats = function() {\n\t\tvar _context=0;\n\t\tvar _urlList=0;\n\t\tvar _request2=0;\n\t\tvar _onLoad=0;\n\t\tvar _0x1673xa=0\n\t\tvar _arraybuffer=0;\n\t\t\n\t\tfor (var _request=0;_request<this.chunks.length;_request++) {\n\t\t\tfor (var _mouseMove=0;_mouseMove<this.chunks.length;_mouseMove++) {\n\t\t\t\tif (this.chunks[_request][_mouseMove].mesh!=undefined) {\n\t\t\t\t\tif (this.chunks[_request][_mouseMove].mesh.visible) {\n\t\t\t\t\t\t_context+=this.chunks[_request][_mouseMove].blocks;_request2+=this.chunks[_request][_mouseMove].triangles;\n\t\t\t\t\t\t_0x1673xa++;\n\t\t\t\t\t}\n\t\t\t\t\t_urlList+=this.chunks[_request][_mouseMove].blocks;\n\t\t\t\t\t_onLoad+=this.chunks[_request][_mouseMove].triangles;\n\t\t\t\t\t_arraybuffer++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar _0x1673xf=game.phys.Stats();\n\t\t$(\"#blockstats\").html(\"[Total] Blocks: \"+_urlList+\" Triangles: \"+_onLoad+\" Chunks: \"+_arraybuffer+\"<br>[Visible] Blocks: \"+_context+\" Triangles: \"+_request2+\" Chunks: \"+_0x1673xa+\"<br>[Particle Engine] Free: \"+_0x1673xf.free+\"/\"+_0x1673xf.total);\n\t};\n\t\n\tWorld.prototype.RebuildDirtyChunks = function(_context) {\n\t\tfor (var _urlList=0;_urlList<this.chunks.length;_urlList++) {\n\t\t\tfor (var _onLoad=0;_onLoad<this.chunks.length;_onLoad++) {\n\t\t\t\tif (_context==1||this.chunks[_urlList][_onLoad].dirty==true) {\n\t\t\t\t\tthis.RebuildChunk(this.chunks[_urlList][_onLoad]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tWorld.prototype.Draw = function(_urlList,_context) {\n\t\tif ((this.ffTime+=_context)>0.1) {\n\t\t\tif (this.floodFill.length>0&&this.exploded!=1) {\n\t\t\t\tthis.RemoveHangingBlocks(this.floodFill.pop());\n\t\t\t}\n\t\t\tthis.ffTime=0;\n\t\t}\n\t\tthis.exploded=0;\n\t};\n\t\n\tWorld.prototype.componentToHex = function(_onLoad) {\n\t\tvar _urlList=_onLoad.toString(16);\n\t\treturn _urlList.length==1?\"0\"+_urlList:_urlList;\n\t};\n\t\n\tWorld.prototype.rgbToHex = function(_arraybuffer,_onLoad,_urlList) {\n\t\tif (_arraybuffer<0) {_arraybuffer=0; }\n\t\tif (_onLoad<0) { _onLoad=0; }\n\t\tvar _context=this.componentToHex(_arraybuffer)+this.componentToHex(_onLoad)+this.componentToHex(_urlList);\n\t\treturn parseInt(\"0x\"+_context.substring(0,6));\n\t};\n\t\n\tWorld.prototype.GetChunk = function(_context,_arraybuffer){\n\t\tvar _urlList=parseInt(_context/(this.chunkBase));\n\t\tvar _onLoad=parseInt(_arraybuffer/(this.chunkBase));\n\t\tif(_urlList<0||_onLoad<0){return undefined};\n\t\treturn this.chunks[_urlList][_onLoad];\n\t};\n\t\n\tWorld.prototype.RemoveHangingBlocks = function(_urlList) {\n\t\tvar _0x1673x1c= new Array();\n\t\tvar _arraybuffer= new Array();\n\t\tvar _0x1673x1d= new Array();\n\t\tfor (var _0x1673xf=0;_0x1673xf<_urlList.length;_0x1673xf++) {\n\t\t\tvar _0x1673xa=_urlList[_0x1673xf];\n\t\t\tvar _onLoad=this.FloodFill(_0x1673xa);_0x1673x1d.push(_onLoad.all);\n\t\t\tif(_onLoad.result!=true) {\n\t\t\t\tif(_onLoad.vals.length==0){ continue; }\n\t\t\t\t_0x1673x1c.push(_onLoad);\n\t\t\t}\n\t\t}\n\t\tfor (var _request=0; _request<_0x1673x1c.length; _request++) {\n\t\t\tvar _onLoad=_0x1673x1c[_request];\n\t\t\tvar _0x1673x14= new Chunk();\n\t\t\t_0x1673x14.dirty=true;\n\t\t\t_0x1673x14.fromX=5000;\n\t\t\t_0x1673x14.fromY=5000;\n\t\t\t_0x1673x14.fromZ=5000;\n\t\t\t_0x1673x14.type=CHUNK_FF;\n\t\t\t_0x1673x14.blockList= new Array();\n\t\t\tfor (var _context=0;_context<_onLoad.vals.length;_context++) {\n\t\t\t\tvar _mesh=_onLoad.vals[_context];\n\t\t\t\tthis.blocks[_mesh.x][_mesh.y][_mesh.z]&= ~(1<<5);\n\t\t\t\tthis.blocks[_mesh.x][_mesh.y][_mesh.z]&= ~(1<<6);\n\t\t\t\t_mesh.val=this.blocks[_mesh.x][_mesh.y][_mesh.z];\n\t\t\t\tthis.blocks[_mesh.x][_mesh.y][_mesh.z]|=32;\n\t\t\t\t_0x1673x14.blockList.push(_mesh);\n\t\t\t\tthis.GetChunk(_mesh.x,_mesh.z).dirty=true;\n\t\t\t\tif(_mesh.x<_0x1673x14.fromX) { _0x1673x14.fromX=_mesh.x; }\n\t\t\t\tif(_mesh.x>_0x1673x14.toX) { _0x1673x14.toX=_mesh.x; }\n\t\t\t\tif(_mesh.y>_0x1673x14.toY) { _0x1673x14.toY=_mesh.y; }\n\t\t\t\tif(_mesh.y<_0x1673x14.fromZ) { _0x1673x14.fromZ=_mesh.y; }\n\t\t\t\tif(_mesh.z<_0x1673x14.fromY) { _0x1673x14.fromY=_mesh.z; }\n\t\t\t\tif(_mesh.z>_0x1673x14.toZ) { _0x1673x14.toZ=_mesh.z; }\n\t\t\t}\n\t\t\t_0x1673x14.fromX--;\n\t\t\t_0x1673x14.fromZ--;\n\t\t\t_0x1673x14.fromY--;\n\t\t\t_0x1673x14.toX++;\n\t\t\t_0x1673x14.toY++;\n\t\t\t_0x1673x14.toZ++;\n\t\t\tthis.RebuildChunk(_0x1673x14);\n\t\t\tgame.phys.CreateMeshBlock(_0x1673x14);\n\t\t}\n\t\tfor (var _request=0; _request<_arraybuffer.length; _request++) {\n\t\t\tvar _onLoad=_arraybuffer[_request];\n\t\t\tfor (var _context=0; _context<_onLoad.vals.length; _context++) {\n\t\t\t\tvar _mesh=_onLoad.vals[_context];\n\t\t\t\tthis.RemoveBlock(_mesh.x,_mesh.y,_mesh.z);\n\t\t\t}\n\t\t}\n\t\tfor (var _0x1673xf=0; _0x1673xf<_0x1673x1d.length; _0x1673xf++) {\n\t\t\tfor (var _mouseMove=0;_mouseMove<_0x1673x1d[_0x1673xf].length; _mouseMove++) {\n\t\t\t\tvar _mesh=_0x1673x1d[_0x1673xf][_mouseMove];\n\t\t\t\tthis.blocks[_mesh.x][_mesh.y][_mesh.z]&= ~(1<<5);\n\t\t\t\tthis.blocks[_mesh.x][_mesh.y][_mesh.z]&= ~(1<<6);\n\t\t\t}\n\t\t}\n\t\tthis.RebuildDirtyChunks()\n\t};\n\t\n\tWorld.prototype.IsBlockHidden = function(_request2,_mouseMove,_arraybuffer){\n\t\tif ((this.blocks[_request2][_mouseMove][_arraybuffer]>>8)==0) { return true; }\n\t\tvar _context=0,_0x1673xf=0,_0x1673xa=0,_urlList=0,_onLoad=0,_request=0;\n\t\tif (_mouseMove>0) {\n\t\t\tif ((this.blocks[_request2][_mouseMove-1][_arraybuffer]>>8)!=0) { _request2=1; }\n\t\t}\n\t\tif (_arraybuffer>0) {\n\t\t\tif ((this.blocks[_request2][_mouseMove][_arraybuffer-1]>>8)!=0) { _onLoad=1; }\n\t\t}\n\t\tif (_request2>0) {\n\t\t\tif ((this.blocks[_request2-1][_mouseMove][_arraybuffer]>>8)!=0) { _context=1; }\n\t\t}\n\t\tif (_request2<this.worldSize-1) {\n\t\t\tif ((this.blocks[_request2+1][_mouseMove][_arraybuffer]>>8)!=0) { _0x1673xf=1; }\n\t\t}\n\t\tif(_mouseMove<this.chunkHeight-1){\n\t\t\tif ((this.blocks[_request2][_mouseMove+1][_arraybuffer]>>8)!=0) { _0x1673xa=1; }\n\t\t}\n\t\tif (_arraybuffer<this.worldSize-1) {\n\t\t\tif((this.blocks[_request2][_mouseMove][_arraybuffer+1]>>8)!=0) { _urlList=1; }\n\t\t}\n\t\tif (_urlList==1&&_context==1&&_0x1673xf==1&&_0x1673xa==1&&_onLoad==1&&_request==1) { return true; }\n\t\treturn false;\n\t};\n\t\n\tWorld.prototype.FloodFill = function(_mouseMove) {\n\t\tvar _0x1673xa = 32;\n\t\tvar _onLoad = new Array();\n\t\tvar _context = new Array();\n\t\t_onLoad.push(_mouseMove);\n\t\tvar _arraybuffer = new Array();\n\t\tif ((_mouseMove&_0x1673xa)!=0) {\n\t\t\treturn {result:true,vals:_context,all:_arraybuffer}\n\t\t}\n\t\twhile (_onLoad.length!=0) {\n\t\t\tvar _urlList=_onLoad.pop();\n\t\t\t_arraybuffer.push(_urlList);\n\t\t\tif (!this.IsWithinWorld(_urlList.x,_urlList.y,_urlList.z)) { continue; }\n\t\t\tif ((this.blocks[_urlList.x][_urlList.y][_urlList.z]>>8)==0) { continue; }\n\t\t\tif ((this.blocks[_urlList.x][_urlList.y][_urlList.z]&64)!=0) { return {result:true,vals:_context,all:_arraybuffer} }\n\t\t\tif ((this.blocks[_urlList.x][_urlList.y][_urlList.z]&_0x1673xa)!=0) { continue; }\n\t\t\tif (_urlList.y<=4) {\n\t\t\t\tthis.blocks[_urlList.x][_urlList.y][_urlList.z]|=_0x1673xa;\n\t\t\t\tthis.blocks[_mouseMove.x][_mouseMove.y][_mouseMove.z]|=64;\t\t\t\t\n\t\t\t\treturn { result:true, vals:_context, all:_arraybuffer }\n\t\t\t}\n\t\t\t_context.push(_urlList);\n\t\t\tthis.blocks[_urlList.x][_urlList.y][_urlList.z]|=_0x1673xa;_onLoad.push( new THREE.Vector3(_urlList.x,_urlList.y+1,_urlList.z));_onLoad.push( new THREE.Vector3(_urlList.x,_urlList.y,_urlList.z+1));_onLoad.push( new THREE.Vector3(_urlList.x+1,_urlList.y,_urlList.z));\n\t\t\t_onLoad.push( new THREE.Vector3(_urlList.x,_urlList.y,_urlList.z-1));\n\t\t\t_onLoad.push( new THREE.Vector3(_urlList.x-1,_urlList.y,_urlList.z));\n\t\t\t_onLoad.push( new THREE.Vector3(_urlList.x,_urlList.y-1,_urlList.z));\n\t\t}\n\t\tthis.blocks[_mouseMove.x][_mouseMove.y][_mouseMove.z]|=64;\n\t\treturn { result:false,vals:_context,all:_arraybuffer }\n\t};\n\t\n\tWorld.prototype.SmokeBlock = function(_context,_request,_request2) {\n\t\tvar _mouseMove=game.phys.Get();\n\t\tif (_mouseMove!=undefined) {\n\t\t\tvar _onLoad=lfsr.rand()*155|0;\n\t\t\tvar _0x1673xa=_onLoad;\n\t\t\tvar _arraybuffer=_onLoad;\n\t\t\tvar _urlList=_onLoad;\n\t\t\t_mouseMove.gravity= -2;\n\t\t\t_mouseMove.Create(_context-this.blockSize*8,_request+this.blockSize,_request2-this.blockSize*8,_0x1673xa,_arraybuffer,_urlList,lfsr.rand()*1,2,PHYS_SMOKE);\n\t\t}\n\t};\n\t\n\tWorld.prototype.ExplosionBlock = function(_context,_request,_mouseMove) {\n\t\tvar _0x1673xa=game.phys.Get();\n\t\tif (_0x1673xa!=undefined) {\n\t\t\tvar _arraybuffer=255;\n\t\t\tvar _onLoad=100+(lfsr.rand()*155|0);\n\t\t\tvar _urlList=0;_0x1673xa.Create(_context-this.blockSize*8,_request+this.blockSize,_mouseMove-this.blockSize*8,_arraybuffer,_onLoad,_urlList,lfsr.rand()*4,0.3);\n\t\t}\n\t};\n\t\n\tWorld.prototype.RemoveBlock = function(_context,_request,_request2) {\n\t\tif (_context<0||_request<0||_request2<0||_context>this.worldSize-1||_request>this.chunkHeight-1||_request2>this.worldSize-1){ return; }\n\t\tif (this.blocks[_context][_request][_request2]==0) { return; };\n\t\tvar _onLoad=this.GetChunk(_context,_request2);\n\t\tif (_onLoad!=undefined) {\n\t\t\t_onLoad.blocks--;\n\t\t\t_onLoad.dirty = true;\n\t\t\tvar _mouseMove=game.phys.Get();\n\t\t\tif (_mouseMove!=undefined) {\n\t\t\t\tif (lfsr.rand()<0.25) {\n\t\t\t\t\tvar _0x1673xa=(this.blocks[_context][_request][_request2]>>24)&255;\n\t\t\t\t\tvar _arraybuffer=(this.blocks[_context][_request][_request2]>>16)&255;\n\t\t\t\t\tvar _urlList=(this.blocks[_context][_request][_request2]>>8)&255;\n\t\t\t\t\t_mouseMove.Create(_context-this.blockSize*8,_request+this.blockSize,_request2-this.blockSize*8,_0x1673xa,_arraybuffer,_urlList,3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.blocks[_context][_request][_request2]=0;\n\t\t}\n\t};\n\t\t\t\n\tWorld.prototype.AddBlock = function(_urlList,_mouseMove,_0x1673xa,_context) {\n\t\t\t\tvar _arraybuffer=1/this.blockSize;\n\t\t\t\tif(_urlList<0||_mouseMove<0||_0x1673xa<0||_urlList>this.worldSize-1||_mouseMove>this.chunkHeight-1||_0x1673xa>this.worldSize-1){ return; }\n\t\t\t\tvar _onLoad=this.GetChunk(_urlList,_0x1673xa);\n\t\t\t\tif (this.blocks[_urlList][_mouseMove][_0x1673xa]==0) {\n\t\t\t\t\t_onLoad.blocks+=_arraybuffer;\n\t\t\t\t\tthis.blocks[_urlList][_mouseMove][_0x1673xa]=(_context[0]&255)<<24|(_context[1]&255)<<16|(_context[2]&255)<<8|0&255;\n\t\t\t\t\t_onLoad.dirty = true;\n\t\t\t\t}\n\t};\n\t\n\tWorld.prototype.SameColor = function(_context,_urlList){if(((_context>>8)&16777215)==((_urlList>>8)&16777215)&&_context!=0&&_urlList!=0){return true};return false};\n\t\n\tWorld.prototype.RebuildChunk = function(_0x1673x10) {\n\t\tvar _0x1673x2d=0;var _mouseMove=[];\n\t\tvar _0x1673x2c=[];\n\t\t\n\t\tfor (var _mesh=_0x1673x10.fromX; _mesh<_0x1673x10.toX; _mesh++) {\n\t\t\tfor (var _0x1673x1c=_0x1673x10.fromZ;_0x1673x1c<_0x1673x10.toY;_0x1673x1c++) {\n\t\t\t\tfor (var _0x1673xf=_0x1673x10.fromY;_0x1673xf<_0x1673x10.toZ;_0x1673xf++) {\n\t\t\t\t\tif (this.blocks[_mesh][_0x1673x1c][_0x1673xf]!=0) {\n\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]&= ~(1<<0);\n\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]&= ~(1<<1);\n\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]&= ~(1<<2);\n\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]&= ~(1<<3);\n\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]&= ~(1<<4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (var _mesh=_0x1673x10.fromX;_mesh<_0x1673x10.toX;_mesh++) {\n\t\t\tfor (var _0x1673x1c=_0x1673x10.fromZ;_0x1673x1c<_0x1673x10.toY;_0x1673x1c++) {\n\t\t\t\tfor (var _0x1673xf=_0x1673x10.fromY;_0x1673xf<_0x1673x10.toZ;_0x1673xf++) {\n\t\t\t\t\tif (_0x1673x10.type==CHUNK_FF) {\n\t\t\t\t\t\tif ((this.blocks[_mesh][_0x1673x1c][_0x1673xf]&32)==0&&(this.blocks[_mesh][_0x1673x1c][_0x1673xf]&64)==0){continue; }\n\t\t\t\t\t}\n\t\t\t\t\tif (this.blocks[_mesh][_0x1673x1c][_0x1673xf]==0) { continue; }\n\t\t\t\t\tvar _arraybuffer=0,_0x1673x1e=0,_e=0,_request=0,_0x1673x1b=0;\n\t\t\t\t\tif (_0x1673xf>0){if(this.blocks[_mesh][_0x1673x1c][_0x1673xf-1]!=0){_0x1673x1b=1;\n\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]=this.blocks[_mesh][_0x1673x1c][_0x1673xf]|16}};\n\t\t\t\t\tif (_mesh>0) {\n\t\t\t\t\t\tif (this.blocks[_mesh-1][_0x1673x1c][_0x1673xf]!=0) {\n\t\t\t\t\t\t\t_arraybuffer=1;\n\t\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]=this.blocks[_mesh][_0x1673x1c][_0x1673xf]|8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (_mesh<this.worldSize-1) {\n\t\t\t\t\t\tif(this.blocks[_mesh+1][_0x1673x1c][_0x1673xf]!=0) {\n\t\t\t\t\t\t\t_0x1673x1e=1;\n\t\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]=this.blocks[_mesh][_0x1673x1c][_0x1673xf]|4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (_0x1673x1c<_0x1673x10.toY-1) {\n\t\t\t\t\t\tif (this.blocks[_mesh][_0x1673x1c+1][_0x1673xf]!=0) {\n\t\t\t\t\t\t\t_e=1;\n\t\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]=this.blocks[_mesh][_0x1673x1c][_0x1673xf]|2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (_0x1673xf<this.worldSize-1) {\n\t\t\t\t\t\tif (this.blocks[_mesh][_0x1673x1c][_0x1673xf+1]!=0) {\n\t\t\t\t\t\t\t_request=1;\n\t\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]=this.blocks[_mesh][_0x1673x1c][_0x1673xf]|1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (_request==1&&_arraybuffer==1&&_0x1673x1e==1&&_e==1&&_0x1673x1b==1) {\n\t\t\t\t\t\tif (_0x1673x10.type==CHUNK_OBJECT||_0x1673x10.type==CHUNK_FF) {\n\t\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!_e) {\n\t\t\t\t\t\tif ((this.blocks[_mesh][_0x1673x1c][_0x1673xf]&2)==0) {\n\t\t\t\t\t\t\tvar _0x1673x1a=0;\n\t\t\t\t\t\t\tvar _0x1673x13=0;\n\t\t\t\t\t\t\tvar _onLoad=0;\n\t\t\t\t\t\t\tfor (var _0x1673x2b=_mesh;_0x1673x2b<_0x1673x10.toX;_0x1673x2b++) {\n\t\t\t\t\t\t\t\tif ((this.blocks[_0x1673x2b][_0x1673x1c][_0x1673xf]&2)==0&&this.SameColor(this.blocks[_0x1673x2b][_0x1673x1c][_0x1673xf],this.blocks[_mesh][_0x1673x1c][_0x1673xf])) {\n\t\t\t\t\t\t\t\t\t_0x1673x1a++;\n\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\tvar _0x1673xe=0;\n\t\t\t\t\t\t\t\tfor (var _0x1673x14=_0x1673xf;_0x1673x14<_0x1673x10.toZ; _0x1673x14++) {\n\t\t\t\t\t\t\t\t\tif ((this.blocks[_0x1673x2b][_0x1673x1c][_0x1673x14]&2)==0&&this.SameColor(this.blocks[_0x1673x2b][_0x1673x1c][_0x1673x14],this.blocks[_mesh][_0x1673x1c][_0x1673xf])) {\n\t\t\t\t\t\t\t\t\t\t_0x1673xe++;\n\t\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (_0x1673xe<_0x1673x13||_0x1673x13==0) { _0x1673x13=_0x1673xe; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (var _0x1673x2b=_mesh;_0x1673x2b<_mesh+_0x1673x1a;_0x1673x2b++) {\n\t\t\t\t\t\t\t\tfor (var _0x1673x14=_0x1673xf;_0x1673x14<_0x1673xf+_0x1673x13;_0x1673x14++) {\n\t\t\t\t\t\t\t\t\tthis.blocks[_0x1673x2b][_0x1673x1c][_0x1673x14]=this.blocks[_0x1673x2b][_0x1673x1c][_0x1673x14]|2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_0x1673x1a--;\n\t\t\t\t\t\t\t_0x1673x13--;\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize,_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize,_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize,_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);_0x1673x2d+=6;for(var _0x1673x1d=0;_0x1673x1d<6;_0x1673x1d++){_0x1673x2c.push([((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>24)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>16)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>8)&255)]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!_0x1673x1b) {\n\t\t\t\t\t\tif ((this.blocks[_mesh][_0x1673x1c][_0x1673xf]&16)==0) {\n\t\t\t\t\t\t\tvar _0x1673x1a=0;\n\t\t\t\t\t\t\tvar _0x1673x1f=0;\n\t\t\t\t\t\t\tfor (var _0x1673x2b=_mesh;_0x1673x2b<_0x1673x10.toX;_0x1673x2b++) {\n\t\t\t\t\t\t\t\tif ((this.blocks[_0x1673x2b][_0x1673x1c][_0x1673xf]&16)==0&&this.SameColor(this.blocks[_0x1673x2b][_0x1673x1c][_0x1673xf],this.blocks[_mesh][_0x1673x1c][_0x1673xf])) {\n\t\t\t\t\t\t\t\t\t_0x1673x1a++;\n\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\tvar _0x1673x27=0;\n\t\t\t\t\t\t\t\tfor (var _urlList=_0x1673x1c;_urlList<_0x1673x10.toY;_urlList++) {\n\t\t\t\t\t\t\t\t\tif ((this.blocks[_0x1673x2b][_urlList][_0x1673xf]&16)==0&&this.SameColor(this.blocks[_0x1673x2b][_urlList][_0x1673xf],this.blocks[_mesh][_0x1673x1c][_0x1673xf])) { _0x1673x27++; } else { break; }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (_0x1673x27<_0x1673x1f||_0x1673x1f==0) { _0x1673x1f=_0x1673x27 }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (var _0x1673x2b=_mesh;_0x1673x2b<_mesh+_0x1673x1a;_0x1673x2b++) {\n\t\t\t\t\t\t\tfor (var _urlList=_0x1673x1c;_urlList<_0x1673x1c+_0x1673x1f;_urlList++) {\n\t\t\t\t\t\t\tthis.blocks[_0x1673x2b][_urlList][_0x1673xf]=this.blocks[_0x1673x2b][_urlList][_0x1673xf]|16}};\n\t\t\t\t\t\t\t_0x1673x1a--;\n\t\t\t\t\t\t\t_0x1673x1f--;\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_0x1673x2d+=6;\n\t\t\t\t\t\t\tfor (var _0x1673x1d=0;_0x1673x1d<6;_0x1673x1d++) {\n\t\t\t\t\t\t\t\t_0x1673x2c.push([((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>24)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>16)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>8)&255)]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!_request) {\n\t\t\t\t\t\tif ((this.blocks[_mesh][_0x1673x1c][_0x1673xf]&1)==0) {\n\t\t\t\t\t\t\tvar _0x1673x1a=0;\n\t\t\t\t\t\t\tvar _0x1673x1f=0;\n\t\t\t\t\t\t\tfor (var _0x1673x2b=_mesh; _0x1673x2b<_0x1673x10.toX; _0x1673x2b++) {\n\t\t\t\t\t\t\t\tif ((this.blocks[_0x1673x2b][_0x1673x1c][_0x1673xf]&1)==0&&this.SameColor(this.blocks[_0x1673x2b][_0x1673x1c][_0x1673xf],this.blocks[_mesh][_0x1673x1c][_0x1673xf])) {\n\t\t\t\t\t\t\t\t\t_0x1673x1a++;\n\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\tvar _0x1673x27=0;\n\t\t\t\t\t\t\t\tfor (var _urlList=_0x1673x1c; _urlList<_0x1673x10.toY; _urlList++) {\n\t\t\t\t\t\t\t\t\tif ((this.blocks[_0x1673x2b][_urlList][_0x1673xf]&1)==0&&this.SameColor(this.blocks[_0x1673x2b][_urlList][_0x1673xf],this.blocks[_mesh][_0x1673x1c][_0x1673xf])){\n\t\t\t\t\t\t\t\t\t\t_0x1673x27++;\n\t\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (_0x1673x27<_0x1673x1f||_0x1673x1f==0) { _0x1673x1f=_0x1673x27; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (var _0x1673x2b=_mesh;_0x1673x2b<_mesh+_0x1673x1a;_0x1673x2b++) {\n\t\t\t\t\t\t\t\tfor (var _urlList=_0x1673x1c;_urlList<_0x1673x1c+_0x1673x1f;_urlList++) {\n\t\t\t\t\t\t\t\t\tthis.blocks[_0x1673x2b][_urlList][_0x1673xf]=this.blocks[_0x1673x2b][_urlList][_0x1673xf]|1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_0x1673x1a--;\n\t\t\t\t\t\t\t_0x1673x1f--;\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize]);_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize+(this.blockSize*_0x1673x1a),_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize]);\n\t\t\t\t\t\t\t_0x1673x2d+=6;\n\t\t\t\t\t\t\tfor (var _0x1673x1d=0;_0x1673x1d<6;_0x1673x1d++) {\n\t\t\t\t\t\t\t\t_0x1673x2c.push([((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>24)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>16)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>8)&255)]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!_arraybuffer) {\n\t\t\t\t\t\tif ((this.blocks[_mesh][_0x1673x1c][_0x1673xf]&8)==0) {\n\t\t\t\t\t\t\tvar _0x1673x13=0;\n\t\t\t\t\t\t\tvar _0x1673x1f=0;\n\t\t\t\t\t\t\tfor (var _0x1673x14=_0x1673xf;_0x1673x14<_0x1673x10.toZ;_0x1673x14++) {\n\t\t\t\t\t\t\t\tif ((this.blocks[_mesh][_0x1673x1c][_0x1673x14]&8)==0&&this.SameColor(this.blocks[_mesh][_0x1673x1c][_0x1673x14],this.blocks[_mesh][_0x1673x1c][_0x1673xf])) {\n\t\t\t\t\t\t\t\t\t_0x1673x13++;\n\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\tvar _0x1673x27=0;\n\t\t\t\t\t\t\t\tfor (var _urlList=_0x1673x1c;_urlList<_0x1673x10.toY;_urlList++) {\n\t\t\t\t\t\t\t\t\tif ((this.blocks[_mesh][_urlList][_0x1673x14]&8)==0&&this.SameColor(this.blocks[_mesh][_urlList][_0x1673x14],this.blocks[_mesh][_0x1673x1c][_0x1673xf])){\n\t\t\t\t\t\t\t\t\t\t_0x1673x27++;\n\t\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (_0x1673x27<_0x1673x1f||_0x1673x1f==0) { _0x1673x1f=_0x1673x27; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (var _0x1673x14=_0x1673xf;_0x1673x14<_0x1673xf+_0x1673x13;_0x1673x14++) {\n\t\t\t\t\t\t\t\tfor (var _urlList=_0x1673x1c;_urlList<_0x1673x1c+_0x1673x1f;_urlList++) {\n\t\t\t\t\t\t\t\t\tthis.blocks[_mesh][_urlList][_0x1673x14]=this.blocks[_mesh][_urlList][_0x1673x14]|8;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_0x1673x13--;\n\t\t\t\t\t\t\t_0x1673x1f--;\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize-this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_0x1673x2d+=6;\n\t\t\t\t\t\t\tfor (var _0x1673x1d=0; _0x1673x1d<6; _0x1673x1d++) {\n\t\t\t\t\t\t\t\t_0x1673x2c.push([((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>24)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>16)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>8)&255)]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!_0x1673x1e) {\n\t\t\t\t\t\tif ((this.blocks[_mesh][_0x1673x1c][_0x1673xf]&4)==0) {\n\t\t\t\t\t\t\tvar _0x1673x13=0;var _0x1673x1f=0;\n\t\t\t\t\t\t\tfor (var _0x1673x14=_0x1673xf; _0x1673x14<_0x1673x10.toZ; _0x1673x14++) {\n\t\t\t\t\t\t\t\tif ((this.blocks[_mesh][_0x1673x1c][_0x1673x14]&4)==0&&this.SameColor(this.blocks[_mesh][_0x1673x1c][_0x1673x14],this.blocks[_mesh][_0x1673x1c][_0x1673xf])) {\n\t\t\t\t\t\t\t\t\t_0x1673x13++;\n\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\tvar _0x1673x27=0;\n\t\t\t\t\t\t\t\tfor (var _urlList=_0x1673x1c;_urlList<_0x1673x10.toY;_urlList++) {\n\t\t\t\t\t\t\t\t\tif ((this.blocks[_mesh][_urlList][_0x1673x14]&4)==0&&this.SameColor(this.blocks[_mesh][_urlList][_0x1673x14],this.blocks[_mesh][_0x1673x1c][_0x1673xf])) {\n\t\t\t\t\t\t\t\t\t\t_0x1673x27++;\n\t\t\t\t\t\t\t\t\t} else { break; }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (_0x1673x27<_0x1673x1f||_0x1673x1f==0) { _0x1673x1f=_0x1673x27; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (var _0x1673x14=_0x1673xf;_0x1673x14<_0x1673xf+_0x1673x13;_0x1673x14++) {\n\t\t\t\t\t\t\t\tfor (var _urlList=_0x1673x1c;_urlList<_0x1673x1c+_0x1673x1f;_urlList++) {\n\t\t\t\t\t\t\t\t\tthis.blocks[_mesh][_urlList][_0x1673x14]=this.blocks[_mesh][_urlList][_0x1673x14]|4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_0x1673x13--;\n\t\t\t\t\t\t\t_0x1673x1f--;\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);_mouseMove.push([_mesh*this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize+(this.blockSize*_0x1673x13)]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize,_0x1673x1c*this.blockSize-this.blockSize,_0x1673xf*this.blockSize-this.blockSize]);\n\t\t\t\t\t\t\t_mouseMove.push([_mesh*this.blockSize,_0x1673x1c*this.blockSize+(this.blockSize*_0x1673x1f),_0x1673xf*this.blockSize-this.blockSize]);_0x1673x2d+=6;\n\t\t\t\t\t\t\tfor (var _0x1673x1d=0;_0x1673x1d<6;_0x1673x1d++) {\n\t\t\t\t\t\t\t\t_0x1673x2c.push([((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>24)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>16)&255),((this.blocks[_mesh][_0x1673x1c][_0x1673xf]>>8)&255)]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tif (_0x1673x10.type==CHUNK_OBJECT||_0x1673x10.type==CHUNK_FF) {\n\t\t\t\t\t\tthis.blocks[_mesh][_0x1673x1c][_0x1673xf]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_0x1673x10.triangles =_mouseMove.length / 3;\n\t\tvar _geometry = new THREE.BufferGeometry();\n\t\tvar _urlList3 = new THREE.BufferAttribute( new Float32Array(_mouseMove.length*3),3);\n\t\tfor (var _n = 0; _n < _mouseMove.length; _n++) {\n\t\t\t_urlList3.setXYZ(_n,_mouseMove[_n][0],_mouseMove[_n][1],_mouseMove[_n][2]);\n\t\t}\n\t\t_geometry.addAttribute(\"position\",_urlList3);\n\t\tvar _rgb= new THREE.BufferAttribute( new Float32Array(_0x1673x2c.length*3),3);\n\t\tfor (var _n = 0; _n < _0x1673x2c.length; _n++) {\n\t\t\t_rgb.setXYZW(_n,_0x1673x2c[_n][0]/255,_0x1673x2c[_n][1]/255,_0x1673x2c[_n][2]/255,1);\n\t\t}\n\t\t_geometry.addAttribute(\"color\",_rgb);\n\t\t_geometry.computeVertexNormals();\n\t\t_geometry.computeFaceNormals();\n\t\t_geometry.computeBoundingBox();\n\t\t\n\t\tgame.scene.remove(_0x1673x10.mesh);\n\t\t_0x1673x10.mesh= new THREE.Mesh(_geometry,this.material);\n\t\t_0x1673x10.mesh.position.set((_0x1673x10.fromX/this.chunkBase)-this.chunkBase/2-this.blockSize*(_0x1673x10.fromX/this.chunkBase),this.blockSize,(_0x1673x10.fromY/this.chunkBase)-this.chunkBase/2-this.blockSize*(_0x1673x10.fromY/this.chunkBase));\n\t\t_0x1673x10.mesh.receiveShadow = true;\n\t\t_0x1673x10.mesh.castShadow = true;\n\t\t_0x1673x10.dirty = false;\n\t\tgame.scene.add(_0x1673x10.mesh);\n\t\t_0x1673x10.mesh.visible = true;\n\t};\n};\n\n\n/////* _________________________________ Proc ____________________________________ */////\n\n\t\nfunction Proc() {\n\t\t\n\tthis.worldSize = 0;\n\tthis.worldSpace = 0;\n\tthis.landHeight = 4;\n\tthis.currentType = 0;\n\tthis.addBuffer = [];\n\tthis.lastBuffer = [];\n\tthis.freeDraw = [];\n\t\n\tProc.prototype.DrawType = function(_urlList,_onLoad,_context) {\n\t\tswitch(this.currentType) {\n\t\t\tcase 2:this.Block(_urlList,_onLoad,_context,0); break;\n\t\t\tcase 3:this.Block(_urlList,_onLoad,_context,1); break;\n\t\t\tcase 4:this.FreeDrawBlock(); break;\n\t\t\tcase 5:game.world.Explode(_urlList,_onLoad,_context,10,false); break;\n\t\t\tcase 6:game.world.Explode(_urlList,_onLoad,_context,10,true); break\n\t\t}\n\t};\n\t\n\tProc.prototype.FreeDrawBlock = function() {\n\t\tvar _0x1673xf = this.freeaw.pop();\n\t\tvar _0x1673x1c = this.freeDr.pop();\n\t\tvar _0x1673x2c = $(\"#heit\").text();\n\t\tvar _arraybuffer = $(\"#colo\").text();\n\t\t\n\t\tvar _context;\n\t\tvar _0x1673xa;\n\t\tvar _urlList;\n\t\tvar _onLoad;\n\t\t\n\t\tif (_0x1673xf.x < _0x1673x1c.x) {\n\t\t\t_context = _0x1673x1c.x;\n\t\t\t_0x1673xa = _0x1673xf.x\n\t\t} else {\n\t\t\t_context = _0x1673xf.x;\n\t\t\t_0x1673xa = _0x1673x1c.x;\n\t\t}\n\t\tif (_0x1673xf.z < _0x1673x1c.z) {\n\t\t\t_urlList = _0x1673x1c.z;\n\t\t\t_onLoad = _0x1673xf.z;\n\t\t} else {\n\t\t\t_urlList = _0x1673xf.z;\n\t\t\t_onLoad = _0x1673x1c.z;\n\t\t}\n\t\tfor (var _request2 = _0x1673xa; _request2 < _context; _request2++) {\n\t\t\tfor (var _mouseMove = _onLoad; _mouseMove < _urlList; _mouseMove++) {\n\t\t\t\tfor (var _request=0;_request<_0x1673x2c;_request++) {\n\t\t\t\t\tthis.Add(_request2,_request,_mouseMove,_arraybuffer);\n\t\t\t\t\tthis.lastBuffer.push( new THREE.Vector3(_request2,_request,_mouseMove));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\t\n\tProc.prototype.Add = function(_urlList,_arraybuffer,_onLoad,_context) {\n\t\tgame.world.AddBlock(_urlList,_arraybuffer,_onLoad,_context);\n\t\tthis.addBuffer.push( new THREE.Vector3(_urlList,_arraybuffer,_onLoad));\n\t};\n\t\n\tProc.prototype.UndoLast = function() {\n\t\tvar _urlList;\n\t\twhile ((_urlList=this.lastBuffer.pop())!=undefined) {\n\t\t\tgame.world.RemoveBlock(_urlList.x,_urlList.y,_urlList.z);\n\t\t\tthis.addBuffer.pop();\n\t\t}\n\t\tgame.world.RebuildDirtyChunks();\n\t};\n\t\n\tProc.prototype.Undo = function() {\n\t\tvar _urlList=this.addBuffer.pop();\n\t\tif (_urlList!=undefined) {\n\t\t\tgame.world.RemoveBlock(_urlList.x,_urlList.y,_urlList.z);\n\t\t\tthis.lastBuffer.pop();\n\t\t\tgame.world.RebuildDirtyChunks();\n\t\t}\n\t};\n\t\n\tProc.prototype.Remove = function(_urlList,_onLoad,_context) {\n\t\tgame.world.RemoveBlock(_urlList,_onLoad,_context);\n\t};\n\t\n\tProc.prototype.Block = function(_context,_urlList,_0x1673x1c,_mouseMove) {\n\t\tvar _width=$(\"#width\").text();\n\t\tvar _height=$(\"#height\").text();\n\t\tvar _arraybuffer=$(\"#color2\").text();\n\t\tthis.lastBuffer=[];\n\t\tif (_width==1) {\n\t\t\tfor (var _request=0;_request<_height;_request++) {\n\t\t\t\tif (_mouseMove==0) {\n\t\t\t\t\tthis.Add(_context,_urlList+_request,_0x1673x1c,_arraybuffer);\n\t\t\t\t\tthis.lastBuffer.push( new THREE.Vector3(_context,_urlList+_request,_0x1673x1c));\n\t\t\t\t} else {\n\t\t\t\t\tthis.Remove(_context,_urlList+_request,_0x1673x1c);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var _request=_context-_width/2;_request<_context+_width/2;_request++) {\n\t\t\t\tfor (var _0x1673xa=_0x1673x1c-_width/2;_0x1673xa<_0x1673x1c+_width/2;_0x1673xa++) {\n\t\t\t\t\tfor(var _request2=0;_request2<_height;_request2++) {\n\t\t\t\t\t\tif (_mouseMove==0) {\n\t\t\t\t\t\t\tthis.Add(_request,_urlList+_request2,_0x1673xa,_arraybuffer);\n\t\t\t\t\t\t\tthis.lastBuffer.push( new THREE.Vector3(_request,_urlList+_request2,_0x1673xa));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.Remove(_request,_urlList+_request2,_0x1673xa);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tProc.prototype.Mushroom = function() {\n\t\tvar _point=this.GetRandomPoint();\n\t\tvar _0x1673xa=this.landHeight;\n\t\tvar _arraybuffer=_0x1673xa+8;\n\t\tfor (var _mouseMove=0;_mouseMove<_arraybuffer;_mouseMove++) {\n\t\t\tfor (var _request=_arraybuffer-1;_request>_arraybuffer/2;_request--) {\n\t\t\t\tfor (var _urlList=0;_urlList<_arraybuffer;_urlList++) {\n\t\t\t\t\tif (Math.sqrt((_urlList-_arraybuffer/2)*(_urlList-_arraybuffer/2)+(_request-_arraybuffer/2)*(_request-_arraybuffer/2)+(_mouseMove-_arraybuffer/2)*(_mouseMove-_arraybuffer/2))<=_arraybuffer/2) {\n\t\t\t\t\t\tgame.world.AddBlock(_point.x+_urlList,_request,_point.z+_mouseMove,Math.random()>0.9?8:10);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar _onLoad=2;\n\t\tvar _context=6;\n\t\tfor (var _request=0;_request<_0x1673xa;_request++) {\n\t\t\tif (_context>_onLoad) { _context--; }\n\t\t\tfor (var _urlList=0;_urlList<_context;_urlList++) {\n\t\t\t\tfor (var _mouseMove=0;_mouseMove<_context;_mouseMove++) {\n\t\t\t\t\tgame.world.AddBlock(_point.x+_urlList+(_arraybuffer/_context),_0x1673xa+_request,_point.z+_mouseMove+(_arraybuffer/_context),8);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tProc.prototype.GetRandomPoint = function() {\n\t\treturn  new THREE.Vector3(Math.round(Math.random()*game.world.worldSize),0,Math.round(Math.random()*game.world.worldSize));\n\t};\n\t\n\tProc.prototype.Init = function(_context) {\n\t\tthis.worldSize=_context;\n\t\tthis.worldSpace= new Array(_context);\n\t\tfor (var _urlList=0; _urlList<this.worldSpace.length; _urlList++) {\n\t\t\tthis.worldSpace[_urlList]= new Array(_context);\n\t\t\tfor (var _onLoad=0;_onLoad<this.worldSpace[_urlList].length;_onLoad++) {\n\t\t\t\tthis.worldSpace[_urlList][_onLoad]=0;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tProc.prototype.CheckFreeSpace = function(_context,_arraybuffer,_onLoad) {\n\t\tfor (var _urlList=_context-_onLoad/2; _urlList<_context+_onLoad/2; _urlList++) {\n\t\t\tfor (var _0x1673xa=_arraybuffer-_onLoad/2; _0x1673xa<_arraybuffer+_onLoad/2; _0x1673xa++) {\n\t\t\t\tif (this.worldSpace[_urlList][_0x1673xa]!=0){ return 0; }\n\t\t\t}\n\t\t\tif (fail) { return 0; }\n\t\t}\n\t\treturn 1;\n\t};\n\t\n\tProc.prototype.Tree = function() {\n\t\tvar _context=Math.round(Math.random()*game.world.chunkHeight);\n\t\tvar _onLoad=3+Math.round(Math.random()*10);\n\t\tvar _request=this.GetRandomPoint();\n\t\tfor (var _mouseMove=this.landHeight; _mouseMove<this.landHeight+_context; _mouseMove++) {\n\t\t\tif (_onLoad>3) { _onLoad--; }\n\t\t\tfor (var _urlList=0;_urlList<_onLoad;_urlList++) {\n\t\t\t\tfor (var _0x1673xa=0; _0x1673xa<_onLoad; _0x1673xa++) {\n\t\t\t\t\tvar _arraybuffer=Math.round(Math.sin(_mouseMove));\n\t\t\t\t\tgame.world.AddBlock(_request.x+_urlList+_arraybuffer,_mouseMove,_request.z+_0x1673xa+_arraybuffer,7);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tProc.prototype.GetRand = function(_context,_urlList) {\n\t\treturn Math.round(_context+Math.random()*(_urlList-_context));\n\t};\n\t\n\tProc.prototype.Rock = function() {\n\t\tvar _point=this.GetRandomPoint();\n\t\tvar _request2=this.GetRand(10,40);var _0x1673xa=this.GetRand(10,40);\n\t\tvar _request=this.GetRand(this.landHeight+5,game.world.chunkHeight);\n\t\tvar _onLoad=0;\n\t\tvar _arraybuffer=this.GetRand(1,_request2/this.GetRand(3,6));\n\t\tvar _context=this.GetRand(1,_0x1673xa/this.GetRand(3,6));\n\t\tvar _urlList=5;\n\t\tfor (var _x=-_urlList; _x<_request2+_urlList; _x++) {\n\t\t\tfor (var _0x1673xf=-_urlList; _0x1673xf<_0x1673xa+_urlList; _0x1673xf++) {\n\t\t\t\tif (Math.random()>0.9) {\n\t\t\t\t\tgame.world.AddBlock(_point.x+_x,this.landHeight,_point.z+_0x1673xf,Math.random()>0.5?0:1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var _x=0; _x<_request2; _x++) {\n\t\t\tfor (var _0x1673xf=0; _0x1673xf<_0x1673xa; _0x1673xf++) {\n\t\t\t\t_onLoad=0;\n\t\t\t\tif ((_x<_arraybuffer||_0x1673xf<_context||_x>_request2-_arraybuffer||_0x1673xf>_0x1673xa-_context)) {\n\t\t\t\t\t_onLoad=this.GetRand(2,_request);\n\t\t\t\t} else {\n\t\t\t\t\t_onLoad=_request;\n\t\t\t\t}\n\t\t\t\tfor (var _0x1673x1c=this.landHeight; _0x1673x1c<_onLoad; _0x1673x1c++) {\n\t\t\t\t\tif (_0x1673x1c>_onLoad-2) {\n\t\t\t\t\t\tMath.random()>0.9?false:game.world.AddBlock(_point.x+_x,_0x1673x1c,_point.z+_0x1673xf,Math.random()>0.9?2:3);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (_0x1673x1c<this.landHeight+4) {\n\t\t\t\t\t\t\tMath.random()<0.5?game.world.AddBlock(_point.x+_x,_0x1673x1c,_point.z+_0x1673xf,Math.random()>0.9?11:12):game.world.AddBlock(_point.x+_x,_0x1673x1c,_point.z+_0x1673xf,Math.random()>0.9?0:1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tMath.random()>0.1?game.world.AddBlock(_point.x+_x,_0x1673x1c,_point.z+_0x1673xf,Math.random()>0.9?11:12):false;\n\t\t\t\t\t\t\tif (Math.random()>0.95) {\n\t\t\t\t\t\t\t\tgame.world.AddBlock(_point.x+_x,_0x1673x1c+2,_point.z+_0x1673xf,Math.random()>0.9?2:11);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tProc.prototype.Flower3 = function() {\n\t\tvar _point = this.GetRandomPoint();\n\t\tvar _0x1673xa=1+Math.round(Math.random()*2);\n\t\tvar _onLoad=0;\n\t\tfor (var _context=0;_context<_0x1673xa+2;_context++) {\n\t\t\tfor (var _request=0;_request<_onLoad;_request++) {\n\t\t\t\tgame.world.AddBlock(_point.x+_context,this.landHeight+1,_point.z+_request,5);\n\t\t\t\tgame.world.AddBlock(_point.x+_context,this.landHeight+1,_point.z-_request,5);\n\t\t\t\tgame.world.AddBlock(_point.x+(_0x1673xa+1)*2-_context,this.landHeight+1,_point.z-_request,5);\n\t\t\t\tgame.world.AddBlock(_point.x+(_0x1673xa+1)*2-_context,this.landHeight+1,_point.z+_request,5);\n\t\t\t}\n\t\t\t_onLoad++;\n\t\t}\n\t\tvar _request2=this.landHeight;\n\t\tvar _urlList=_request2+6+Math.round(Math.random()*4);\n\t\tfor (var _arraybuffer=_request2;_arraybuffer<_urlList;_arraybuffer++) {\n\t\t\tgame.world.AddBlock(_point.x+_0x1673xa+1,_arraybuffer,_point.z,5);\n\t\t\tif (_arraybuffer%2) {\n\t\t\t\tif (Math.random()>0.5) {\n\t\t\t\t\tgame.world.AddBlock(_point.x+_0x1673xa+1,_arraybuffer,_point.z+1,6);\n\t\t\t\t\tgame.world.AddBlock(_point.x+_0x1673xa+2,_arraybuffer,_point.z,10);\n\t\t\t\t} else {\n\t\t\t\t\tgame.world.AddBlock(_point.x+_0x1673xa+1,_arraybuffer,_point.z-1,6);\n\t\t\t\t\tgame.world.AddBlock(_point.x+_0x1673xa,_arraybuffer,_point.z,10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgame.world.AddBlock(_point.x+_0x1673xa+1,_urlList,_point.z,Math.random()>0.5?10:6);\n\t};\n\t\n\tProc.prototype.Flower2 = function() {\n\t\tvar _point=this.GetRandomPoint();\n\t\tvar _0x1673xa=1+Math.round(Math.random()*2);\n\t\tvar _onLoad=0;\n\t\tfor (var _context=0;_context<_0x1673xa+2;_context++) {\n\t\t\tfor (var _request=0;_request<_onLoad;_request++) {\n\t\t\t\tgame.world.AddBlock(_point.x+_context,this.landHeight,_point.z+_request,5);\n\t\t\t\tgame.world.AddBlock(_point.x+_context,this.landHeight,_point.z-_request,5);\n\t\t\t\tgame.world.AddBlock(_point.x+(_0x1673xa+1)*2-_context,this.landHeight,_point.z-_request,5);\n\t\t\t\tgame.world.AddBlock(_point.x+(_0x1673xa+1)*2-_context,this.landHeight,_point.z+_request,5);\n\t\t\t}\n\t\t\t_onLoad++;\n\t\t}\n\t\tvar _request2=this.landHeight;\n\t\tvar _urlList=_request2+1+Math.round(Math.random()*4);\n\t\tfor (var _arraybuffer=_request2+1;_arraybuffer<_urlList;_arraybuffer++) {\n\t\t\tgame.world.AddBlock(_point.x+_0x1673xa+1,_arraybuffer,_point.z,5)\n\t\t}\n\t\tgame.world.AddBlock(_point.x+_0x1673xa+1,_urlList,_point.z+1,8);\n\t\tgame.world.AddBlock(_point.x+_0x1673xa+1,_urlList,_point.z-1,8);\n\t\tgame.world.AddBlock(_point.x+_0x1673xa+2,_urlList,_point.z,8);\n\t\tgame.world.AddBlock(_point.x+_0x1673xa,_urlList,_point.z,8);\n\t\tgame.world.AddBlock(_point.x+_0x1673xa+1,_urlList,_point.z,Math.random()>0.5?6:9);\n\t};\n\t\n\tProc.prototype.Flower1 = function() {\n\t\tvar _urlList=this.GetRand(2,4);var _onLoad=this.GetRandomPoint();\n\t\tfor (var _context=this.landHeight;_context<this.landHeight+_urlList;_context++) {\n\t\t\tgame.world.AddBlock(_onLoad.x,_context,_onLoad.z,4);\n\t\t}\n\t\tgame.world.AddBlock(_onLoad.x,_context,_onLoad.z,6);\n\t};\n\t\n\tProc.prototype.Grass = function() {\n\t\tvar _0x1673xa=this.GetRandomPoint();\n\t\tvar _onLoad=2+Math.round(Math.random()*2);var _context=0;\n\t\tfor (var _urlList=0;_urlList<_onLoad+2;_urlList++) {\n\t\t\tfor (var _arraybuffer=0;_arraybuffer<_context;_arraybuffer++) {\n\t\t\t\tgame.world.AddBlock(_0x1673xa.x+_urlList,this.landHeight+_arraybuffer,_0x1673xa.z,5);\n\t\t\t\tgame.world.AddBlock(_0x1673xa.x+(_onLoad+1)*2-_urlList,this.landHeight+_arraybuffer,_0x1673xa.z,5);\n\t\t\t}\n\t\t\t_context++;\n\t\t}\n\t};\n\t\n\tProc.prototype.Land = function(_onLoad) {\n\t\tvar _context=0;\n\t\tfor (var _mouseMove=0;_mouseMove<this.landHeight;_mouseMove++) {\n\t\t\tfor (var _urlList=0;_urlList<_onLoad;_urlList++) {\n\t\t\t\tfor (var _0x1673xa=0;_0x1673xa<_onLoad;_0x1673xa++) {\n\t\t\t\t\tvar _arraybuffer=Math.random()*10>9?true:false;\n\t\t\t\t\tif (_mouseMove==this.landHeight-1) {\n\t\t\t\t\t\tif (_arraybuffer) {\n\t\t\t\t\t\t\t_context=2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_context=3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_context=0;\n\t\t\t\t\t}\n\t\t\t\t\tgame.world.AddBlock(_urlList,_mouseMove,_0x1673xa,_context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\n// ----------------------- GL MATRIX --------------------\n\n// function glMatrix() {\n\tglMatrixArrayType=typeof Float32Array!=\"undefined\"?Float32Array:typeof WebGLFloatArray!=\"undefined\"?WebGLFloatArray:Array;var vec3={};vec3.create=function(a){var b=new glMatrixArrayType(3);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2]}return b};vec3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b};vec3.add=function(a,b,c){if(!c||a==c){a[0]+=b[0];a[1]+=b[1];a[2]+=b[2];return a}c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];return c};\n\tvec3.subtract=function(a,b,c){if(!c||a==c){a[0]-=b[0];a[1]-=b[1];a[2]-=b[2];return a}c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c};vec3.negate=function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b};vec3.scale=function(a,b,c){if(!c||a==c){a[0]*=b;a[1]*=b;a[2]*=b;return a}c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};\n\tvec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g==1){b[0]=c;b[1]=d;b[2]=e;return b}}else{b[0]=0;b[1]=0;b[2]=0;return b}g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};vec3.cross=function(a,b,c){c||(c=a);var d=a[0],e=a[1];a=a[2];var g=b[0],f=b[1];b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c};vec3.length=function(a){var b=a[0],c=a[1];a=a[2];return Math.sqrt(b*b+c*c+a*a)};vec3.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]};\n\tvec3.direction=function(a,b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1];a=a[2]-b[2];b=Math.sqrt(d*d+e*e+a*a);if(!b){c[0]=0;c[1]=0;c[2]=0;return c}b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c};vec3.lerp=function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);return d};vec3.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\"]\"};var mat3={};\n\tmat3.create=function(a){var b=new glMatrixArrayType(9);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9]}return b};mat3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b};mat3.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a};\n\tmat3.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b};mat3.toMat4=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=0;b[4]=a[3];b[5]=a[4];b[6]=a[5];b[7]=0;b[8]=a[6];b[9]=a[7];b[10]=a[8];b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};\n\tmat3.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\", \"+a[4]+\", \"+a[5]+\", \"+a[6]+\", \"+a[7]+\", \"+a[8]+\"]\"};var mat4={};mat4.create=function(a){var b=new glMatrixArrayType(16);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15]}return b};\n\tmat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};\n\tmat4.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]=a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b};\n\tmat4.determinant=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],i=a[7],j=a[8],k=a[9],l=a[10],o=a[11],m=a[12],n=a[13],p=a[14];a=a[15];return m*k*h*e-j*n*h*e-m*f*l*e+g*n*l*e+j*f*p*e-g*k*p*e-m*k*d*i+j*n*d*i+m*c*l*i-b*n*l*i-j*c*p*i+b*k*p*i+m*f*d*o-g*n*d*o-m*c*h*o+b*n*h*o+g*c*p*o-b*f*p*o-j*f*d*a+g*k*d*a+j*c*h*a-b*k*h*a-g*c*l*a+b*f*l*a};\n\tmat4.inverse=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],i=a[6],j=a[7],k=a[8],l=a[9],o=a[10],m=a[11],n=a[12],p=a[13],r=a[14],s=a[15],A=c*h-d*f,B=c*i-e*f,t=c*j-g*f,u=d*i-e*h,v=d*j-g*h,w=e*j-g*i,x=k*p-l*n,y=k*r-o*n,z=k*s-m*n,C=l*r-o*p,D=l*s-m*p,E=o*s-m*r,q=1/(A*E-B*D+t*C+u*z-v*y+w*x);b[0]=(h*E-i*D+j*C)*q;b[1]=(-d*E+e*D-g*C)*q;b[2]=(p*w-r*v+s*u)*q;b[3]=(-l*w+o*v-m*u)*q;b[4]=(-f*E+i*z-j*y)*q;b[5]=(c*E-e*z+g*y)*q;b[6]=(-n*w+r*t-s*B)*q;b[7]=(k*w-o*t+m*B)*q;b[8]=(f*D-h*z+j*x)*q;\n\tb[9]=(-c*D+d*z-g*x)*q;b[10]=(n*v-p*t+s*A)*q;b[11]=(-k*v+l*t-m*A)*q;b[12]=(-f*C+h*y-i*x)*q;b[13]=(c*C-d*y+e*x)*q;b[14]=(-n*u+p*B-r*A)*q;b[15]=(k*u-l*B+o*A)*q;return b};mat4.toRotationMat=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};\n\tmat4.toMat3=function(a,b){b||(b=mat3.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b};mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,o=-k*g+h*i,m=j*g-f*i,n=c*l+d*o+e*m;if(!n)return null;n=1/n;b||(b=mat3.create());b[0]=l*n;b[1]=(-k*d+e*j)*n;b[2]=(h*d-e*f)*n;b[3]=o*n;b[4]=(k*c-e*i)*n;b[5]=(-h*c+e*g)*n;b[6]=m*n;b[7]=(-j*c+d*i)*n;b[8]=(f*c-d*g)*n;return b};\n\tmat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],o=a[9],m=a[10],n=a[11],p=a[12],r=a[13],s=a[14];a=a[15];var A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14];b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*o+u*r;c[2]=A*g+B*j+t*m+u*s;c[3]=A*f+B*k+t*n+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*o+y*r;c[6]=v*g+w*j+x*m+y*s;c[7]=v*f+w*k+x*n+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*o+E*r;c[10]=z*\n\tg+C*j+D*m+E*s;c[11]=z*f+C*k+D*n+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*o+b*r;c[14]=q*g+F*j+G*m+b*s;c[15]=q*f+F*k+G*n+b*a;return c};mat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1];b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c};\n\tmat4.multiplyVec4=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[3]=a[3]*d+a[7]*e+a[11]*g+a[15]*b;return c};\n\tmat4.translate=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[12]=a[0]*d+a[4]*e+a[8]*b+a[12];a[13]=a[1]*d+a[5]*e+a[9]*b+a[13];a[14]=a[2]*d+a[6]*e+a[10]*b+a[14];a[15]=a[3]*d+a[7]*e+a[11]*b+a[15];return a}var g=a[0],f=a[1],h=a[2],i=a[3],j=a[4],k=a[5],l=a[6],o=a[7],m=a[8],n=a[9],p=a[10],r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=o;c[8]=m;c[9]=n;c[10]=p;c[11]=r;c[12]=g*d+j*e+m*b+a[12];c[13]=f*d+k*e+n*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+o*e+r*b+a[15];return c};\n\tmat4.scale=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[0]*=d;a[1]*=d;a[2]*=d;a[3]*=d;a[4]*=e;a[5]*=e;a[6]*=e;a[7]*=e;a[8]*=b;a[9]*=b;a[10]*=b;a[11]*=b;return a}c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};\n\tmat4.rotate=function(a,b,c,d){var e=c[0],g=c[1];c=c[2];var f=Math.sqrt(e*e+g*g+c*c);if(!f)return null;if(f!=1){f=1/f;e*=f;g*=f;c*=f}var h=Math.sin(b),i=Math.cos(b),j=1-i;b=a[0];f=a[1];var k=a[2],l=a[3],o=a[4],m=a[5],n=a[6],p=a[7],r=a[8],s=a[9],A=a[10],B=a[11],t=e*e*j+i,u=g*e*j+c*h,v=c*e*j-g*h,w=e*g*j-c*h,x=g*g*j+i,y=c*g*j+e*h,z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;if(d){if(a!=d){d[12]=a[12];d[13]=a[13];d[14]=a[14];d[15]=a[15]}}else d=a;d[0]=b*t+o*u+r*v;d[1]=f*t+m*u+s*v;d[2]=k*t+n*u+A*v;d[3]=l*t+p*u+B*\n\tv;d[4]=b*w+o*x+r*y;d[5]=f*w+m*x+s*y;d[6]=k*w+n*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+o*e+r*g;d[9]=f*z+m*e+s*g;d[10]=k*z+n*e+A*g;d[11]=l*z+p*e+B*g;return d};mat4.rotateX=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[4],g=a[5],f=a[6],h=a[7],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[0]=a[0];c[1]=a[1];c[2]=a[2];c[3]=a[3];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[4]=e*b+i*d;c[5]=g*b+j*d;c[6]=f*b+k*d;c[7]=h*b+l*d;c[8]=e*-d+i*b;c[9]=g*-d+j*b;c[10]=f*-d+k*b;c[11]=h*-d+l*b;return c};\n\tmat4.rotateY=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[4]=a[4];c[5]=a[5];c[6]=a[6];c[7]=a[7];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*-d;c[1]=g*b+j*-d;c[2]=f*b+k*-d;c[3]=h*b+l*-d;c[8]=e*d+i*b;c[9]=g*d+j*b;c[10]=f*d+k*b;c[11]=h*d+l*b;return c};\n\tmat4.rotateZ=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[4],j=a[5],k=a[6],l=a[7];if(c){if(a!=c){c[8]=a[8];c[9]=a[9];c[10]=a[10];c[11]=a[11];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*d;c[1]=g*b+j*d;c[2]=f*b+k*d;c[3]=h*b+l*d;c[4]=e*-d+i*b;c[5]=g*-d+j*b;c[6]=f*-d+k*b;c[7]=h*-d+l*b;return c};\n\tmat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b=a*b;return mat4.frustum(-b,b,-a,a,c,d,e)};\n\tmat4.ortho=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/i;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/j;f[11]=0;f[12]=-(a+b)/h;f[13]=-(d+c)/i;f[14]=-(g+e)/j;f[15]=1;return f};\n\tmat4.lookAt=function(a,b,c,d){d||(d=mat4.create());var e=a[0],g=a[1];a=a[2];var f=c[0],h=c[1],i=c[2];c=b[1];var j=b[2];if(e==b[0]&&g==c&&a==j)return mat4.identity(d);var k,l,o,m;c=e-b[0];j=g-b[1];b=a-b[2];m=1/Math.sqrt(c*c+j*j+b*b);c*=m;j*=m;b*=m;k=h*b-i*j;i=i*c-f*b;f=f*j-h*c;if(m=Math.sqrt(k*k+i*i+f*f)){m=1/m;k*=m;i*=m;f*=m}else f=i=k=0;h=j*f-b*i;l=b*k-c*f;o=c*i-j*k;if(m=Math.sqrt(h*h+l*l+o*o)){m=1/m;h*=m;l*=m;o*=m}else o=l=h=0;d[0]=k;d[1]=h;d[2]=c;d[3]=0;d[4]=i;d[5]=l;d[6]=j;d[7]=0;d[8]=f;d[9]=\n\to;d[10]=b;d[11]=0;d[12]=-(k*e+i*g+f*a);d[13]=-(h*e+l*g+o*a);d[14]=-(c*e+j*g+b*a);d[15]=1;return d};mat4.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\", \"+a[4]+\", \"+a[5]+\", \"+a[6]+\", \"+a[7]+\", \"+a[8]+\", \"+a[9]+\", \"+a[10]+\", \"+a[11]+\", \"+a[12]+\", \"+a[13]+\", \"+a[14]+\", \"+a[15]+\"]\"};quat4={};quat4.create=function(a){var b=new glMatrixArrayType(4);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3]}return b};quat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b};\n\tquat4.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a==b){a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return a}b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};quat4.inverse=function(a,b){if(!b||a==b){a[0]*=1;a[1]*=1;a[2]*=1;return a}b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};quat4.length=function(a){var b=a[0],c=a[1],d=a[2];a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};\n\tquat4.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(f==0){b[0]=0;b[1]=0;b[2]=0;b[3]=0;return b}f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};quat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2];a=a[3];var f=b[0],h=b[1],i=b[2];b=b[3];c[0]=d*b+a*f+e*i-g*h;c[1]=e*b+a*h+g*f-d*i;c[2]=g*b+a*i+d*h-e*f;c[3]=a*b-d*f-e*h-g*i;return c};\n\tquat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=a[0];var f=a[1],h=a[2];a=a[3];var i=a*d+f*g-h*e,j=a*e+h*d-b*g,k=a*g+b*e-f*d;d=-b*d-f*e-h*g;c[0]=i*a+d*-b+j*-h-k*-f;c[1]=j*a+d*-f+k*-b-i*-h;c[2]=k*a+d*-h+i*-f-j*-b;return c};quat4.toMat3=function(a,b){b||(b=mat3.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=k+g;b[4]=1-(j+e);b[5]=d-f;b[6]=c-h;b[7]=d+f;b[8]=1-(j+l);return b};\n\tquat4.toMat4=function(a,b){b||(b=mat4.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=0;b[4]=k+g;b[5]=1-(j+e);b[6]=d-f;b[7]=0;b[8]=c-h;b[9]=d+f;b[10]=1-(j+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};quat4.slerp=function(a,b,c,d){d||(d=a);var e=c;if(a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]<0)e=-1*c;d[0]=1-c*a[0]+e*b[0];d[1]=1-c*a[1]+e*b[1];d[2]=1-c*a[2]+e*b[2];d[3]=1-c*a[3]+e*b[3];return d};\n\tquat4.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\"]\"};\n// }\n\n// ----------------------- BUFFERS --------------------\n\nfunction initBuffers() {\n\ttriangleVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);\n\tvar vertices = [\n\t  0.0,  1.0,  0.0,\n\t -1.0, -1.0,  0.0,\n\t  1.0, -1.0,  0.0\n  ];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\ttriangleVertexPositionBuffer.itemSize = 3;\n\ttriangleVertexPositionBuffer.numItems = 3;\n\tsquareVertexPositionBuffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);\n\tvertices = [\n\t  1.0,  1.0,  0.0,\n\t  -1.0,  1.0,  0.0,\n\t  1.0, -1.0,  0.0,\n\t  -1.0, -1.0,  0.0\n\t];\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n\tsquareVertexPositionBuffer.itemSize = 3;\n\tsquareVertexPositionBuffer.numItems = 4;\n}\n\n// --------------------- DRAW SCENE ------------------\n\nfunction drawScene() {\n\tgl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\tmat4.perspective(45 + Math.sin(Date.now() / 300) * 10, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);\n\tmat4.identity(mvMatrix);\n\tmat4.translate(mvMatrix, [-1.5, 0.0, -7.0]);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);\n\tgl.vertexAttribPointer(program.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\tsetMatrixUniforms();\n\tgl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);\n\tmat4.translate(mvMatrix, [3.0, 0.0+ Math.sin(Date.now() / 400) * 2, 0.0+ Math.sin(Date.now() / 500) * 2]);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);\n\tgl.vertexAttribPointer(program.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n\tsetMatrixUniforms();\n\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);\n}\n\n// ------------------- RENDERER LOADER -----------------\n\nfunction RendererLoader(canvas, vertexShaderPath, fragmentShaderPath) {\n\tthis.canvas = canvas;\n\tthis.textLoader = new TextLoader([vertexShaderPath, fragmentShaderPath]);\n\tthis.renderer = null;\n}\n\nRendererLoader.prototype.load = function(callback) {\n\tvar self = this; this.callback = callback; this.textLoader.load(function() {  self.invalidate(); });\n};\n\nRendererLoader.prototype.invalidate = function() {\n  var vertexShader = this.textLoader.getTextByIndex(0);\n  var fragmentShader = this.textLoader.getTextByIndex(1);\n\t\n  if (!this.renderer && vertexShader && fragmentShader) {\n\tgl = this.canvas.getContext(\"webgl\", { alpha: true, antialias: true } );\n\tif (!gl) { console.log(\"!gl. Could not initialise WebGL\"); }\n\tgl.viewportWidth = this.canvas.width;\n\tgl.viewportHeight = this.canvas.height;\n\tvar vs = compileShader(gl, vertexShader, gl.VERTEX_SHADER);\n\tvar fs = compileShader(gl, fragmentShader, gl.FRAGMENT_SHADER);\n\tprogram = createProgram(gl, vs, fs);\n\tgl.enable(gl.DEPTH_TEST);\n\tgl.clearColor(0.0, 0.0, 0.0, 1.0);\n\tgl.useProgram(program);\n\tprogram.vertexPositionAttribute = gl.getAttribLocation(program, \"aVertexPosition\");\n\tgl.enableVertexAttribArray(program.vertexPositionAttribute);\n\tprogram.pMatrixUniform = gl.getUniformLocation(program, \"uPMatrix\");\n\tprogram.mvMatrixUniform = gl.getUniformLocation(program, \"uMVMatrix\");\n\tthis.renderer = new Renderer(this.canvas, gl, program);\n\tthis.callback(this.renderer);\n  }\n};\n\n// --------------------- TEXTLOADER ----------------------\n\nfunction TextLoader(paths) { this.paths = paths; this.texts = {}; }\n\nTextLoader.prototype.load = function(callback) {\n\tthis.callback = callback;\n\tfor (var _n = 0; _n < this.paths.length; _n++) { \n\t  var path = this.paths[_n]; if (!this.texts[path]) { this.xhr(path, this.getOnTextLoadedFunc(_n)); }\n\t}\n};\n\nTextLoader.prototype.getOnTextLoadedFunc = function(_n) {\n\tvar self = this;\n\treturn function(text) {\n\t  var path = self.paths[_n];\n\t  self.texts[path] = text;\n\t  // alert(text);\n\t  self.callback && self.callback(_n);\n  };\n};\n\nTextLoader.prototype.getTextByIndex = function(_n) { return this.getTextByPath(this.paths[_n]); };\nTextLoader.prototype.getTextByPath = function(path) { return this.texts[path]; };\n\nTextLoader.prototype.xhr = function(url, callback) {\n\tvar xhr = new XMLHttpRequest();\n\txhr.open('GET', url, true);\n\txhr.responseType = 'text';\n\txhr.onload = function() { callback(this.response); };\n\txhr.send();\n};\n\n// ----------------------- WEBGL UTIL -----------------\n\nfunction compileShader(gl, shaderSource, shaderType) {\n\tvar shader = gl.createShader(shaderType);\n\tgl.shaderSource(shader, shaderSource);\n\tgl.compileShader(shader);\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { alert(\"could not compile shader:\" + gl.getShaderInfoLog(shader)); }\n\treturn shader;\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader) {\n\tvar program = gl.createProgram();\n\tgl.attachShader(program, vertexShader);\n\tgl.attachShader(program, fragmentShader);\n\tgl.linkProgram(program);\n\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) { alert(\"program filed to link:\" + gl.getProgramInfoLog(program)); }\n\treturn program;\n}\n\nfunction createStaticGlBuff(gl, values) {\n\tvar buff = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, buff);\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(values), gl.STATIC_DRAW);\n\treturn buff;\n}\n\n// ----------------------- RENDERER --------------------\n\nfunction Renderer(canvas, gl, program) {\n\tthis.canvas = canvas;\n\tthis.gl = gl;\n\tthis.program = program;\n\tthis.initAttributesAndUniforms();\n}\nRenderer.prototype.initAttributesAndUniforms = function() {\n\tthis.createVertexAttribute('aVertexPosition');\n\tthis.createVertexAttribute('aVertexColor');\n\tthis.createVertexAttribute('aVertexGroup');\n\tthis.createUniform('uViewMatrix');\n\tthis.createUniform('uModelMatrix');\n\tthis.createUniform('uModelMatrix2');\n\tthis.createUniform('uModelColor');\n};\nRenderer.prototype.createVertexAttribute = function(name) {\n\tthis[name] = this.gl.getAttribLocation(this.program, name);\n\tthis.gl.enableVertexAttribArray(this[name]);\n};\nRenderer.prototype.createUniform = function(name) { this[name] = this.gl.getUniformLocation(this.program, name); };\nRenderer.prototype.resize = function() {\n\tif (this.canvas.width != this.canvas.clientWidth || this.canvas.height != this.canvas.clientHeight) {\n      this.canvas.width = this.canvas.clientWidth;\n      this.canvas.height = this.canvas.clientHeight;\n      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n\t}\n\treturn this;\n};\nRenderer.prototype.clear = function() { this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT); return this; };\nRenderer.prototype.clearColor = function(r, g, b, a) { this.gl.clearColor(r, g, b, a); return this; };\nRenderer.prototype.setColorVector = function(colorVector) { this.gl.uniform4fv(this.uModelColor, colorVector.v); return this; };\nRenderer.prototype.setBlendingEnabled = function(blend) {\n\tif (blend) {\n\t  this.gl.enable(this.gl.BLEND);\n\t  this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE)\n\t} else { this.gl.disable(this.gl.BLEND) }\n\treturn this;\n};\nRenderer.prototype.setViewMatrix = function(viewMatrix) {\n\tthis.viewMatrix = viewMatrix;\n\tthis.gl.uniformMatrix4fv(this.uViewMatrix, this.gl.FALSE, viewMatrix.m); return this;\n};\nRenderer.prototype.getViewMatrix = function() { return this.viewMatrix; };\nRenderer.prototype.setModelMatrix = function(modelMatrix) {\n\tthis.gl.uniformMatrix4fv(this.uModelMatrix, this.gl.FALSE, modelMatrix.m); return this;\n};\nRenderer.prototype.setModelMatrix2 = function(modelMatrix2) {\n\tthis.gl.uniformMatrix4fv(this.uModelMatrix2, this.gl.FALSE, modelMatrix2.m); return this;\n};\nRenderer.prototype.setStamp = function(stamp) {\n\tthis.modelStamp = stamp;\n\tstamp.prepareToDraw(this.gl, this.aVertexPosition, this.aVertexColor, this.aVertexGroup); return this;\n};\nRenderer.prototype.drawStamp = function() { this.modelStamp.draw(this.gl); return this; };\n\n\n// ------------------------ MAIN ----------------------\n\n\"use strict\";\n\nconst TYPE_OBJECT = 0;\nconst TYPE_MAP = 1;\nconst WEAPON_ROCKET = 0;\nconst WEAPON_SHOTGUN = 1;\nconst WEAPON_NONE = 2;\nconst MAX_HP = 100;\nconst MODEL_STAND = 0;\nconst MODEL_JUMP = 1;\nconst MODEL_RUN1 = 2;\nconst MODEL_RUN2 = 3;\nconst MODEL_SHOOT = 4;\nconst MODEL_FALL = 5;\nconst MOVE_FORWARD = 0;\nconst MOVE_BACKWARD = 1;\nconst MOVE_LEFT = 2;\nconst MOVE_RIGHT = 3;\nconst MOVE_UP = 4;\nconst MOVE_DOWN = 5;\nconst CHUNK_WORLD = 0;\nconst CHUNK_OBJECT = 1;\nconst CHUNK_FF = 2;\nconst PHYS_REGULAR=0;\nconst PHYS_SMOKE=1;\nconst PHYS_MISSILE=2;\nconst PHYS_SNOW=3;\nconst PHYS_GRENADE=4;\nconst PHYS_DIE=5;\nconst PHYS_SHOT=6;\n\n\nvar canvas = document.createElement('canvas');\ncanvas.id = 'canvas';\n// resizeCanvas();\ndocument.body.appendChild(canvas);\naddEventListener(\"load\", main);\n\nvar game, gl, program;\nvar mvMatrix = mat4.create();\nvar pMatrix = mat4.create();\nvar triangleVertexPositionBuffer;\nvar squareVertexPositionBuffer;\n\t\nfunction resizeCanvas() {\n\tvar w = window.innerWidth;\n\tvar h = window.innerHeight;\n\tcanvas.style.width = w + \"px\";\n\tcanvas.style.height = h + \"px\";\n\tcanvas.width = w;\n\tcanvas.height = h;\n}\n\nfunction main() { canvas = this.canvas; game = new Game(); game.Init();\n\t// new RendererLoader(this.canvas, 'shaders/vox-vertex-shader.txt', 'shaders/vox-fragment-shader.txt').load(this.onRendererLoaded.bind(this));\n}\nfunction onRendererLoaded(r) { initBuffers(); this.renderer = r; this.loop(); }\nfunction loop() { drawScene(); requestAnimationFrame(loop, canvas); }\n\nfunction setMatrixUniforms() {\n\tgl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);\n\tgl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);\n}\n\n/////* _________________________________ Game 2 ___________________________________ */////\n\nfunction Game() {\n\t\n\tthis.mode = \"edit\";\n\t\n\tthis.container, this.scene, this.camera, this.renderer, this.controls, this.stats, this.clock;\n\tthis.world = this.phys = this.sound = this.player = this.weapons = this.proc = this.rollOverMesh = this.composer = undefined;\n\tthis.isShiftDown = this.isADown = this.raycaster = this.mouse = this.keyboard = this.box = this.inputTime = 0;\n\tvar screenWidth = window.innerWidth;\n\tvar screenHeight = window.innerHeight;\n\tthis.viewAngle = 10;\n\tthis.aspect = screenWidth/screenHeight;\n\tthis.near = 10;\n\tthis.far = 3000;\n\tthis.invMaxFps = 1/60;\n\tthis.frameDelta = 0;\n\tthis.objects = [];\n\t\n\tGame.prototype.initScene = function() {\n\t\tthis.scene= new THREE.Scene();\n\t\tthis.camera= new THREE.PerspectiveCamera(20,this.aspect,this.near,this.far);\n\t\tthis.scene.add(this.camera);\n\t};\n\t\n\tGame.prototype.Init = function(_request) {\n\t\t// container\n\t\tthis.contain = document.createElement('div');\n\t\tthis.contain.id = 'container';\n\t\tthis.contain.setAttribute('style', 'position: absolute; z-index: 1; top: 0px;');\n\t\tdocument.body.appendChild(this.contain);\n\t\t\n\t\t// stats\n\t\tthis.clock = new THREE.Clock();\n\t\tthis.stats = new Stats();\n\t\tthis.stats.domElement.setAttribute('style', 'position: absolute; bottom: 5px; z-index: 120;');\n\t\tthis.contain.appendChild(this.stats.domElement);\n\t\t\n\t\t// editor\n\t\tthis.editor = document.createElement('div');\n\t\tthis.editor.id = 'editor';\n\t\tthis.editor.setAttribute('style', 'position: absolute; top: -16px; z-index: 120; color: #FF0000;');\n\t\tvar str = \"<br><span id='key1'>1: Rocket Launcher</span> | <span id='key2'>2: Shotgun</span> | <span id='key3'>3: None</span> | <span> Mouse2: Grenade </span> <br><br>\";\n\t\tthis.editor.insertAdjacentHTML( 'afterbegin' , str );\n\t\tdocument.body.appendChild(this.editor);\n\t\t\n\t\t// phys\n\t\tthis.phyz = document.createElement('div');\n\t\tthis.phyz.id = 'phys';\n\t\tthis.phyz.setAttribute('style', 'position: absolute; z-index: 110;');\n\t\tthis.contain.appendChild(this.phyz);\n\t\t\n\t\tthis.initScene();\n\t\t\n\t\t// screen\n\t\tvar _box = new THREE.BoxGeometry(1,1,1);\n\t\tvar _material = new THREE.MeshBasicMaterial({ color:65280,opacity:0.5,transparent:true });\n\t\tthis.rollOverMesh = new THREE.Mesh(_box,_material);\n\t\tthis.scene.add(this.rollOverMesh);\n\t\n\t\t// render\n\t\tthis.renderer = new THREE.WebGLRenderer({antialias:true});\n\t\tthis.renderer.setSize(this.screenWidth,this.screenHeight);\n\t\tthis.renderer.shadowMap.enabled = true;\n\t\tthis.renderer.shadowMap.type=THREE.PCFSoftShadowMap;\n\t\tthis.container = document.getElementById(\"container\");\n\t\tthis.container.appendChild(this.renderer.domElement);\n\t\tthis.scene.fog = new THREE.Fog(16751018,100,3000);\n\t\tthis.renderer.setClearColor(16753089,1);\n\t\tTHREEx.WindowResize(this.renderer,this.camera);\n\t\t\n\t\t\n\t\t// add lighting\n\t\tvar _Alight = new THREE.AmbientLight(15643078);\n\t\tthis.scene.add(_Alight);\n\t\t\n\t\tvar _Hlight = new THREE.HemisphereLight(16777215,16777215,0.1);\n\t\t_Hlight.color.setHSL(0.6,1,0.6);\n\t\t_Hlight.groundColor.setHSL(0.095,1,0.75);\n\t\t_Hlight.position.set(0,500,0);\n\t\tgame.scene.add(_Hlight);\n\t\t\n\t\tvar _Dlight = new THREE.DirectionalLight(10066329,0.4);\n\t\t_Dlight.color.setHSL(0.1,1,0.95);\n\t\t_Dlight.position.set(23,23,10);\n\t\t_Dlight.position.multiplyScalar(10);\n\t\tgame.scene.add(_Dlight);\n\t\t_Dlight.castShadow = true;\n\t\t_Dlight.shadowMapWidth = 512;\n\t\t_Dlight.shadowMapHeight = 512;\n\t\t\n\t\tvar _shadow = 150;\n\t\t_Dlight.shadowCameraLeft = -_shadow;\n\t\t_Dlight.shadowCameraRight = _shadow;\n\t\t_Dlight.shadowCameraTop = _shadow;\n\t\t_Dlight.shadowCameraBottom = -_shadow;\n\t\t_Dlight.shadowCameraFar = 3500;\n\t\t_Dlight.shadowBias = -0.0001;\n\t\t_Dlight.shadowDarkness = 0.45;\n\t\t\n\t\tthis.world = new World();\n\t\tconsole.log(\"World init...\");\n\t\tthis.world.Init();\n\t\t\n\t\tthis.sound = new SoundLoader();\n\t\tthis.sound.Add({ file:\"sound/rocket_explode.mp3\",name: \"rocket_explode\" });\n\t\tthis.sound.Add({ file:\"sound/rocket_shoot.mp3\",name: \"rocket_shoot\" });\n\t\tthis.sound.Add({ file:\"sound/shotgun_shoot.mp3\",name: \"shotgun_shoot\" });\n\t\tthis.sound.Add({ file:\"sound/brick1.mp3\",name: \"brick1\" });\n\t\tthis.sound.Add({ file:\"sound/brick2.mp3\",name: \"brick2\" });\n\t\tthis.sound.Add({ file:\"sound/grenade_explode.mp3\",name: \"grenade_explode\" });\n\t\tthis.sound.Add({ file:\"sound/pickup.mp3\",name: \"pickup\" });\n\t\tthis.sound.Add({ file:\"sound/throw.mp3\",name: \"threw\" }); // js cmd?!!!\n\t\tthis.sound.Add({ file:\"sound/die.mp3\",name: \"die2\" });\n\t\t\n\t\tthis.phys = new Phys();\n\t\tthis.phys.Init();\n\t\tthis.player = new Player();\n\t\tthis.weapons = new Weapon();\n\t\tthis.proc = new Proc();\n\t\tthis.raycaster = new THREE.Raycaster();\n\t\tthis.mouse = new THREE.Vector2();\n\t\t\n\t\t// load models\n\t\tvar _vox = new Vox();\n\t\t_vox.LoadModel(\"objects/player_stand.vox\",function(_x,_y,_c) { game.player.standChunk = _c, game.player.shootChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_jump.vox\",function(_x,_y,_c) { game.player.jumpChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_run1.vox\",function(_x,_y,_c) { game.player.run1Chunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_run2.vox\",function(_x,_y,_c) { game.player.run2Chunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_fall.vox\",function(_x,_y,_c) { game.player.fallChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_stand_rocket.vox\",function(_x,_y,_c) { game.player.standRocketChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_jump_rocket.vox\",function(_x,_y,_c) { game.player.jumpRocketChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_run1_rocket.vox\",function(_x,_y,_c) { game.player.run1RocketChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_run2_rocket.vox\",function(_x,_y,_c) { game.player.run2RocketChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_shoot_rocket.vox\",function(_x,_y,_c) { game.player.shootRocketChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_fall_rocket.vox\",function(_x,_y,_c) { game.player.fallRocketChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_stand_shotgun.vox\",function(_x,_y,_c) { game.player.standShotgunChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_jump_shotgun.vox\",function(_x,_y,_c) { game.player.jumpShotgunChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_run1_shotgun.vox\",function(_x,_y,_c) { game.player.run1ShotgunChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_run2_shotgun.vox\",function(_x,_y,_c) { game.player.run2ShotgunChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_shoot_shotgun.vox\",function(_x,_y,_c) { game.player.shootShotgunChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/player_fall_shotgun.vox\",function(_x,_y,_c) { game.player.fallShotgunChunk = _c },Player,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/shotgun.vox\",function(_x,_y,_c) { game.weapons.shotgunChunk = _c },Weapon,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"objects/rocket.vox\",function(_x,_y,_c) { game.weapons.rocketChunk = _c },Weapon,TYPE_OBJECT);\n\t\t_vox.LoadModel(\"maps/map_test2.vox\",function(_c) {\n\t\t\tgame.player.Init(\"test\");\n\t\t\tgame.weapons.Init();\n\t\t\tgame.weapons.Create(WEAPON_ROCKET, new THREE.Vector3(163,125,12));\n\t\t\tgame.weapons.Create(WEAPON_SHOTGUN, new THREE.Vector3(9,124,169));\n\t\t},\"Map3\",TYPE_MAP);\n\t\t\n\t\tthis.onWindowResize();\n\t\tthis.animate();\n\t};\n\t\n\tGame.prototype.onWindowResize = function() {\n\t\tthis.camera.aspect = window.innerWidth/window.innerHeight;\n\t\tthis.camera.updateProjectionMatrix();\n\t\tthis.renderer.setSize(window.innerWidth,window.innerHeight);\n\t};\n\t\n\tGame.prototype.getDistance = function(_vec1,_vec2) {\n\t\tvar _xd = _vec1.x - _vec2.x;\n\t\tvar _yd = _vec1.y - _vec2.y;\n\t\tvar _zd = _vec1.z - _vec2.z;\n\t\treturn Math.sqrt(_xd * _xd + _yd * _yd + _zd * _zd);\n\t};\n\t\n\tGame.prototype.render = function() { this.renderer.render(this.scene,this.camera); };\n\t\n\tGame.prototype.animate = function() {\n\t\tthis.animId = requestAnimationFrame(this.animate.bind(this));\n\t\tthis.render();\n\t\tthis.update();\n\t};\n\t\n\tGame.prototype.update = function() {\n\t\tvar _delta = this.clock.getDelta();\n\t\tvar _arraybuffer = this.clock.getElapsedTime()*10;\n\t\tthis.frameDelta += _delta;\n\t\twhile (this.frameDelta >= this.invMaxFps) {\n\t\t\tthis.player.Draw(_arraybuffer,this.invMaxFps);\n\t\t\tthis.weapons.Draw(_arraybuffer,this.invMaxFps);\n\t\t\tthis.phys.Draw(_arraybuffer,this.invMaxFps);\n\t\t\tthis.frameDelta-=this.invMaxFps;\n\t\t\tthis.world.Draw(_arraybuffer,_delta);\n\t\t\tif ((game.world.blocks[98][67][83]>>8)!=0) {\n\t\t\t\tif (Math.random()>0.8) {\n\t\t\t\t\tvar _0x1673xa=game.phys.Get();\n\t\t\t\t\tif (_0x1673xa!=undefined) {\n\t\t\t\t\t\t_0x1673xa.gravity = 1;\n\t\t\t\t\t\tvar _onLoad=15;\n\t\t\t\t\t\tvar _context=169;\n\t\t\t\t\t\tvar _urlList=189;\n\t\t\t\t\t\tif (lfsr.rand()>0.5) {\n\t\t\t\t\t\t\t_onLoad=36;\n\t\t\t\t\t\t\t_context=152;\n\t\t\t\t\t\t\t_urlList=229;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_0x1673xa.Create(86+lfsr.rand()*5,67,88,_onLoad,_context,_urlList,-1,10,PHYS_SMOKE,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Math.random()>0.7) {\n\t\t\t\t\tvar _0x1673xa=game.phys.Get();\n\t\t\t\t\tif (_0x1673xa!=undefined) {\n\t\t\t\t\t\t_0x1673xa.gravity = 1;\n\t\t\t\t\t\tvar _onLoad=15;\n\t\t\t\t\t\tvar _context=169;\n\t\t\t\t\t\tvar _urlList=189;\n\t\t\t\t\t\tif (lfsr.rand()>0.5) {\n\t\t\t\t\t\t\t_onLoad=255;\n\t\t\t\t\t\t\t_context=255;\n\t\t\t\t\t\t\t_urlList=255;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_0x1673xa.Create(85+lfsr.rand()*7,36,87+lfsr.rand()*5,_onLoad,_context,_urlList,0.5,5,PHYS_SMOKE,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.stats.update();\n\t};\n\n\tGame.prototype.rand = function(_context,_urlList,_arraybuffer) {\n\t\tvar _onLoad,_arraybuffer=_arraybuffer||0;\n\t\tif (_context<0) {\n\t\t\t_onLoad=_context+Math.random()*(Math.abs(_context)+_urlList);\n\t\t} else {\n\t\t\t_onLoad=_context+Math.random()*_urlList};\n\t\t\treturn _onLoad.toFixed(_arraybuffer)*1;\n\t};\n};\n\n\n/////* _______________________________ MeshBlock ____________________________________ */////\n\n\nfunction MeshBlock() {\n\tthis.mesh = undefined;\n\tthis.helper = undefined;\n\tthis.gravity = 19.82;\n\tthis.mass = 1;\n\tthis.airDensity = 1.2;\n\tthis.e = -0.2;\n\tthis.area = 0.1;\n\tthis.active = 1;\n\tthis.chunk = undefined;\n\tthis.bounces_orig = 2;\n\tthis.bounces = this.bounces_orig;\n\tthis.avg_ay = -2;\n\tthis.vy = 0;\n\tthis.remove = 0;\n\t\n\tMeshBlock.prototype.Draw = function(_onLoad,_0x1673x1c) {\n\t\tthis.mesh.updateMatrixWorld();\n\t\tfor (var _0x1673xa=0; _0x1673xa<this.chunk.blockList.length; _0x1673xa+=this.off) {\n\t\t\tvar _chunk=this.chunk.blockList[_0x1673xa];\n\t\t\tvar _urlList= new THREE.Vector3(_chunk.x,_chunk.y,_chunk.z);\n\t\t\t_urlList.applyMatrix4(this.mesh.matrixWorld);\n\t\t\tvar _request=_urlList.x+game.world.blockSize*8|0;\n\t\t\tvar _arraybuffer=_urlList.y|0;\n\t\t\tvar _urlList2=_urlList.z+game.world.blockSize*8|0;\n\t\t\tif (game.world.IsWithinWorld(_request,_arraybuffer,_urlList2)) {\n\t\t\t\tif ((game.world.blocks[_request][_arraybuffer][_urlList2]>>8)!=0) {\n\t\t\t\t\tgame.world.PlaceObject(_request,_arraybuffer,_urlList2,this.chunk);\n\t\t\t\t\tthis.active=0;\n\t\t\t\t\tthis.remove=1;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_arraybuffer<=0) {\n\t\t\t\tgame.world.PlaceObject(_request,0,_urlList2,this.chunk);\n\t\t\t\tthis.remove=1;\n\t\t\t\tthis.active=0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tvar _context=this.mass*this.gravity;\n\t\t_context+=-1*0.5*this.airDensity*this.area*this.vy*this.vy;\n\t\tvar _0x1673x2c=this.vy*_0x1673x1c+(0.5*this.avg_ay*_0x1673x1c*_0x1673x1c);\n\t\tthis.mesh.position.y+=_0x1673x2c*10;\n\t\tvar _mouseMove=_context/this.mass;\n\t\tthis.avg_ay=0.5*(_mouseMove+this.avg_ay);\n\t\tthis.vy-=this.avg_ay*_0x1673x1c;\n\t};\n\t\n\tMeshBlock.prototype.Create = function(_urlList){\n\t\tthis.mesh=_urlList.mesh;\n\t\tthis.mesh.chunk=_urlList;\n\t\tthis.chunk=_urlList;\n\t\tthis.active=1;\n\t\tthis.off=1;\n\t\tif (this.chunk.blockList.length>100) {\n\t\t\tthis.off=this.chunk.blockList.length/500|0;\n\t\t\tif (this.off<1) { this.off=1; }\n\t\t}\n\t};\n};\n\n\n/////* _______________________________ PhysicsBlock ____________________________________ *///// \n\n\nfunction PhysBlock() {\n\tthis.life = 0;\n\tthis.mesh = undefined;\n\tthis.color = \"0xFFFFFF\";\n\tthis.active = 0;\n\tthis.gravity = 9.82;\n\tthis.e = -0.3;\n\tthis.mass = 0.1;\n\tthis.airDensity = 1.2;\n\tthis.drag = -5.95;\n\tthis.area = 1/1000;\n\tthis.vy = 0;\n\tthis.avg_ay = 0;\n\tthis.vx = 0;\n\tthis.vz = 0;\n\tthis.avg_ax = 0;\n\tthis.avg_az = 0;\n\tthis.bounces = 0;\n\tthis.bounces_orig = 0;\n\tthis.fx_ = 0;\n\tthis.fz_ = 0;\n\tthis.type = PHYS_REGULAR;\n\tthis.ray = undefined;\n\t\n\tPhysBlock.prototype.Init = function() {\n\t\tvar _context = new THREE.BoxGeometry(game.world.blockSize,game.world.blockSize,game.world.blockSize);\n\t\tvar _urlList = new THREE.MeshLambertMaterial();\n\t\tthis.mesh = new THREE.Mesh(_context,_urlList);game.scene.add(this.mesh);\n\t\tthis.mesh.visible = false;\n\t\tthis.mesh.castShadow = true;\n\t\tthis.bounces_orig=0; // (1+lfsr.rand()+2)|0;\n\t\tthis.fx_=Math.random()-0.5;\n\t\tthis.fz_=Math.random()-0.5;\n\t};\n\t\t\n\tPhysBlock.prototype.Create = function(_mesh,_0x1673x1c,_request2,_urlList,_0x1673xa,_0x1673x2c,_context,_urlList2,_request,_urlList3,_mouseMove) {\n\t\tthis.type = _request?_request:PHYS_REGULAR;\n\t\tif (this.type!=PHYS_MISSILE&&this.type!=PHYS_SNOW&&this.type!=PHYS_GRENADE&&this.type!=PHYS_SHOT) {\n\t\t\tthis.life=_urlList2?lfsr.rand()*_urlList2:lfsr.rand()*3\n\t\t} else {\n\t\t\tthis.life = _urlList2\n\t\t}\n\t\tthis.mass = _mouseMove?_mouseMove:0.1;\n\t\tthis.bounces = _urlList3?_urlList3:this.bounces_orig;\n\t\tthis.avg_ay = 0;\n\t\tthis.avg_ax = 0;\n\t\tthis.avg_az = 0;\n\t\tif (this.type==PHYS_MISSILE||this.type==PHYS_GRENADE||this.type==PHYS_SHOT) {\n\t\t\tvar _0x1673xf= new THREE.Vector3(0,2,50);\n\t\t\tvar _0x1673x10=_0x1673xf.applyMatrix4(game.player.mesh.matrix);\n\t\t\tvar _arraybuffer=_0x1673xf.sub(game.player.mesh.position);\n\t\t\tthis.ray = new THREE.Raycaster(_0x1673x10,_arraybuffer.clone().normalize());\n\t\t\tthis.vx =_context+this.ray.ray.direction.x;\n\t\t\tthis.vy=_context;\n\t\t\tthis.vz=_context+this.ray.ray.direction.z}else {this.vx=_context;this.vy=_context;this.vz=_context};\n\t\t\tvar _onLoad=game.world.rgbToHex(_urlList,_0x1673xa,_0x1673x2c);\n\t\t\tthis.mesh.material.color.setHex(_onLoad);\n\t\t\tthis.mesh.material.needsUpdate = true;\n\t\t\tthis.mesh.position.set(_mesh,_0x1673x1c,_request2);\n\t\t\tthis.mesh.visible = true;\n\t\t\tthis.mesh.scale.set(1,1,1);\n\t};\n\t\t\t\n\tPhysBlock.prototype.Draw = function(_mouseMove,_0x1673x2b) {\n\t\tthis.life-=_0x1673x2b;\n\t\t\n\t\tif (this.life <= 0 || this.bounces == 0) {\n\t\t\tif (this.mesh.children.length > 0) {\n\t\t\t\tfor (var _0x1673x13=0; _0x1673x13<this.mesh.children.length; _0x1673x13++) {\n\t\t\t\t\tvar _0x1673x29 = this.mesh.children[_0x1673x13];\n\t\t\t\t\t_0x1673x29.intensity = 2;\n\t\t\t\t\t_0x1673x29.hex=16724787;\n\t\t\t\t\tgame.scene.add(_0x1673x29);\n\t\t\t\t\t_0x1673x29.position.set(this.mesh.position.x,this.mesh.position.y,this.mesh.position.z);\n\t\t\t\t\tthis.mesh.remove(_0x1673x29);\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tgame.scene.remove(_0x1673x29);\n\t\t\t\t\t},300);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.type==PHYS_MISSILE) {\n\t\t\t\tvar _posx=this.mesh.position.x+game.world.blockSize*8|0;\n\t\t\t\tvar _posy=this.mesh.position.y|0;\n\t\t\t\tvar _posz=this.mesh.position.z+game.world.blockSize*8|0;\n\t\t\t\tgame.world.Explode(_posx,_posy,_posz,8,0);\n\t\t\t\tgame.sound.PlaySound(\"rocket_explode\",this.mesh.position,600);\n\t\t\t} else {\n\t\t\t\tif (this.type==PHYS_GRENADE) {\n\t\t\t\t\tvar _posx=this.mesh.position.x+game.world.blockSize*8|0;\n\t\t\t\t\tvar _posy=this.mesh.position.y|0;\n\t\t\t\t\tvar _posz=this.mesh.position.z+game.world.blockSize*8|0;\n\t\t\t\t\tif (game.world.IsWithinWorld(_posx,_posy,_posz)) {\n\t\t\t\t\t\tgame.world.Explode(_posx,_posy,_posz,15,0);\n\t\t\t\t\t\tgame.sound.PlaySound(\"grenade_explode\",this.mesh.position,600);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.type==PHYS_SHOT) {\n\t\t\t\t\t\tvar _posx=this.mesh.position.x+game.world.blockSize*8|0;\n\t\t\t\t\t\tvar _posy=this.mesh.position.y|0;\n\t\t\t\t\t\tvar _posz=this.mesh.position.z+game.world.blockSize*8|0;\n\t\t\t\t\t\tif (game.world.IsWithinWorld(_posx,_posy,_posz)) {\n\t\t\t\t\t\t\tgame.world.Explode(_posx,_posy,_posz,2,0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (this.type==PHYS_SNOW) {\n\t\t\t\t\t\t\tvar _posx=this.mesh.position.x+game.world.blockSize*8|0;\n\t\t\t\t\t\t\tvar _posy=this.mesh.position.y-3|0;\n\t\t\t\t\t\t\tvar _posz=this.mesh.position.z+game.world.blockSize*8|0;\n\t\t\t\t\t\t\tif (game.world.IsWithinWorld(_posx,_posy,_posz)) {\n\t\t\t\t\t\t\t\tgame.world.blocks[_posx][_posy][_posz]=255<<24|255<<16|255<<8;\n\t\t\t\t\t\t\t\tgame.world.GetChunk(_posx,_posz).dirty = true;\n\t\t\t\t\t\t\t\tgame.world.RebuildDirtyChunks();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (this.type==PHYS_REGULAR) { }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.mesh.visible = false;\n\t\t\tthis.active = 0;\n\t\t\tthis.life = 0;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar _posx = this.mesh.position.x + game.world.blockSize*8|0;\n\t\tvar _posy = this.mesh.position.y|0;\n\t\tvar _posz = this.mesh.position.z + game.world.blockSize*8|0;\n\t\tvar _arraybuffer = this.mass*this.gravity;\n\t\tvar _0x1673xa,_urlList;\n\t\t\n\t\t// missile\n\t\tif (this.type==PHYS_MISSILE) {\n\t\t\t_0x1673xa=this.mass*this.gravity;_urlList=this.mass*this.gravity;\n\t\t} else {\n\t\t\t_0x1673xa=this.mass*this.gravity*lfsr.rand()-0.5;\n\t\t\t_urlList=this.mass*this.gravity*lfsr.rand()-0.5;\n\t\t}\n\t\t\n\t\t_arraybuffer += -1*0.5*this.airDensity*this.area*this.vy*this.vy;\n\t\t_0x1673xa += -1*0.5*this.airDensity*this.area*this.vx*this.vx;\n\t\t_urlList += -1*0.5*this.airDensity*this.area*this.vz*this.vz;\n\t\tvar _urlList2 = this.vy*_0x1673x2b+(0.5*this.avg_ay*_0x1673x2b*_0x1673x2b);\n\t\tvar _0x1673x10 = this.vx*_0x1673x2b+(0.5*this.avg_ax*_0x1673x2b*_0x1673x2b);\n\t\tvar _0x1673xf = this.vz*_0x1673x2b+(0.5*this.avg_az*_0x1673x2b*_0x1673x2b);\n\t\t\n\t\t// die\n\t\tif (this.type==PHYS_REGULAR||this.type==PHYS_DIE) {\n\t\t\tthis.mesh.position.x+=_0x1673x10*10*this.fx_;\n\t\t\tthis.mesh.position.z+=_0x1673xf*10*this.fz_;\n\t\t\tthis.mesh.position.y+=_urlList2*10;\n\t\t} else {\n\t\t\t// smoke\n\t\t\tif ( this.type==PHYS_SMOKE) {\n\t\t\t\tthis.mesh.position.y+=_urlList2*10;\n\t\t\t\tthis.mesh.position.x+=Math.sin(_0x1673x10)*this.fx_;\n\t\t\t\tthis.mesh.position.z+=Math.sin(_0x1673xf)*this.fz_;\n\t\t\t} else {\n\t\t\t\t// snow\n\t\t\t\tif (this.type==PHYS_SNOW) {\n\t\t\t\t\tthis.mesh.position.y+=_urlList2*10;\n\t\t\t\t\tthis.mesh.position.x+=Math.sin(_0x1673x10)*this.fx_;\n\t\t\t\t\tthis.mesh.position.z+=Math.sin(_0x1673xf)*this.fz_;\n\t\t\t\t} else {\n\t\t\t\t\t// shot\n\t\t\t\t\tif (this.type==PHYS_SHOT) {\n\t\t\t\t\t\tthis.mesh.position.x+=_0x1673x10*10*this.ray.ray.direction.x;\n\t\t\t\t\t\tthis.mesh.position.z+=_0x1673xf*10*this.ray.ray.direction.z;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// missile\n\t\t\t\t\t\tif (this.type==PHYS_MISSILE) {\n\t\t\t\t\t\t\tthis.mesh.position.x+=_0x1673x10*10*this.ray.ray.direction.x;\n\t\t\t\t\t\t\tthis.mesh.position.z+=_0x1673xf*10*this.ray.ray.direction.z;\n\t\t\t\t\t\t\tvar _0x1673x27=game.phys.Get();\n\t\t\t\t\t\t\tif (_0x1673x27!=undefined) {\n\t\t\t\t\t\t\t\t_0x1673x27.gravity= -2;\n\t\t\t\t\t\t\t\t_0x1673x27.Create(this.mesh.position.x,this.mesh.position.y,this.mesh.position.z,230,230,230,lfsr.rand()*1,1,PHYS_SMOKE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// grenade\n\t\t\t\t\t\t\tif (this.type==PHYS_GRENADE) {\n\t\t\t\t\t\t\t\tthis.mesh.position.x+=_0x1673x10*10*this.ray.ray.direction.x;\n\t\t\t\t\t\t\t\tthis.mesh.position.z+=_0x1673xf*10*this.ray.ray.direction.z;\n\t\t\t\t\t\t\t\tthis.mesh.position.y+=_urlList2*20;\n\t\t\t\t\t\t\t\tif (lfsr.rand()>0.7) {\n\t\t\t\t\t\t\t\t\tvar _0x1673x27=game.phys.Get();\n\t\t\t\t\t\t\t\t\tif (_0x1673x27!=undefined) {\n\t\t\t\t\t\t\t\t\t\t_0x1673x27.gravity= -2;\n\t\t\t\t\t\t\t\t\t\tvar _0x1673x1b=200;\n\t\t\t\t\t\t\t\t\t\tvar _0x1673xe=(100+lfsr.rand()*155)|0;\n\t\t\t\t\t\t\t\t\t\tvar _0x1673x1f=0;\n\t\t\t\t\t\t\t\t\t\t_0x1673x27.Create(this.mesh.position.x,this.mesh.position.y,this.mesh.position.z,_0x1673x1b,_0x1673xe,_0x1673x1f,lfsr.rand()*1,0.5,PHYS_SMOKE);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar _0x1673x14=_arraybuffer/this.mass;\n\t\tthis.avg_ay=0.5*(_0x1673x14+this.avg_ay);\n\t\tthis.vy-=this.avg_ay*_0x1673x2b;\n\t\tvar _0x1673x1d=_0x1673xa/this.mass;\n\t\tthis.avg_ax=0.5*(_0x1673x1d+this.avg_ax);\n\t\tthis.vx-=this.avg_ax*_0x1673x2b;\n\t\tvar _urlList3=_urlList/this.mass;\n\t\tthis.avg_az=0.5*(_urlList3+this.avg_az);\n\t\tthis.vz-=this.avg_az*_0x1673x2b;\n\t\tthis.mesh.rotation.set(this.vx,this.vy,this.vz);\n\t\t\n\t\tif (this.type==PHYS_MISSILE) {\n\t\t\tif (game.world.IsWithinWorld(_posx,_posy,_posz)) {\n\t\t\t\tfor (var _n=0;_n<2;_n++) {\n\t\t\t\t\tfor (var _mesh=0;_mesh<2;_mesh++) {\n\t\t\t\t\t\tif (game.world.IsWithinWorld(_posx+_n,_posy,_posz+_mesh)) {\n\t\t\t\t\t\t\tif ((game.world.blocks[_posx+_n][_posy][_posz+_mesh]>>8)!=0) {\n\t\t\t\t\t\t\t\tthis.life=0;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.type==PHYS_SHOT) {\n\t\t\t\tif (game.world.IsWithinWorld(_posx,_posy,_posz)) {\n\t\t\t\t\tfor (var _n=-2;_n<4;_n++) { \n\t\t\t\t\t\tfor (var _mesh=-2;_mesh<4;_mesh++) {\n\t\t\t\t\t\t\tif (game.world.IsWithinWorld(_posx+_n,_posy,_posz+_mesh)) {\n\t\t\t\t\t\t\t\tif ((game.world.blocks[_posx+_n][_posy][_posz+_mesh]>>8)!=0) {\n\t\t\t\t\t\t\t\t\tthis.life=0;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.type==PHYS_GRENADE) {\n\t\t\t\t\tvar _posx = this.mesh.position.x+game.world.blockSize*8|0;\n\t\t\t\t\tvar _posy = this.mesh.position.y|0;\n\t\t\t\t\tvar _posz = this.mesh.position.z+game.world.blockSize*8|0;\n\t\t\t\t\tif (this.mesh.position.y<=0) {\n\t\t\t\t\t\tthis.mesh.position.y=1;\n\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\tthis.vy*=this.e;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (game.world.IsWithinWorld(_posx,_posy,_posz)) {\n\t\t\t\t\t\tfor (var _n = 0; _n < 2; _n++) {\n\t\t\t\t\t\t\tfor (var _mesh= 0; _mesh < 2; _mesh++) {\n\t\t\t\t\t\t\t\tfor (var _onLoad = 0; _onLoad < 2; _onLoad++) {\n\t\t\t\t\t\t\t\t\tif (game.world.IsWithinWorld(_posx+_n,_posy+_onLoad,_posz+_mesh)) {\n\t\t\t\t\t\t\t\t\t\tif (this.mesh.position.y<=0&&this.vy<0) {\n\t\t\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t\t\t\tthis.vy*=-this.e;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif ((game.world.blocks[_posx+_n][_posy+_onLoad][_posz+_mesh]>>8)!=0) {\n\t\t\t\t\t\t\t\t\t\t\tif (this.vy<0) {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vy*=this.e;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (this.vx<0) {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vx*=0.9;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vx*= -0.9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (this.vz<0){\n\t\t\t\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vz*=0.9;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vz*= -0.9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.type==PHYS_DIE) {\n\t\t\t\t\t\tif (game.world.IsWithinWorld(_posx,_posy,_posz)) {\n\t\t\t\t\t\t\tif ((game.world.blocks[_posx][_posy][_posz]>>8)!=0&&this.vy<0) {\n\t\t\t\t\t\t\t\tthis.mesh.position.y+=game.world.blockSize*4;\n\t\t\t\t\t\t\t\tthis.mesh.rotation.set(0,0,0);\n\t\t\t\t\t\t\t\tthis.vy*=this.e;\n\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (game.world.IsWithinWorld(_posx,_posy,_posz)) {\n\t\t\t\t\t\t\tif ((game.world.blocks[_posx][_posy][_posz]>>8)!=0&&game.world.IsBlockHidden(_posx,_posy,_posz)) {\n\t\t\t\t\t\t\t\tthis.mesh.visible = false;\n\t\t\t\t\t\t\t\tthis.active = 0;\n\t\t\t\t\t\t\t\tthis.life = 0;\n\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif ((game.world.blocks[_posx][_posy][_posz]>>8)!=0&&this.vx<0) {\n\t\t\t\t\t\t\t\t\tthis.mesh.rotation.set(0,0,0);\n\t\t\t\t\t\t\t\t\tthis.vx*=this.e;\n\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif ((game.world.blocks[_posx][_posy][_posz]>>8)!=0&&this.vz<0) {\n\t\t\t\t\t\t\t\t\t\tthis.mesh.rotation.set(0,0,0);\n\t\t\t\t\t\t\t\t\t\tthis.vz*=this.e;\n\t\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif ((game.world.blocks[_posx][_posy][_posz]>>8)!=0&&this.vy<0) {\n\t\t\t\t\t\t\t\t\t\t\tthis.mesh.position.y=_posy+game.world.blockSize*4;\n\t\t\t\t\t\t\t\t\t\t\tthis.mesh.rotation.set(0,0,0);\n\t\t\t\t\t\t\t\t\t\t\tthis.vy*=this.e;\n\t\t\t\t\t\t\t\t\t\t\tthis.bounces--;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n/////* _________________________________ Physics ______________________________________ *///// \n\n\nfunction Phys() {\n\t\n\tthis.blocks = new Array();\n\tthis.meshes = new Array();\n\tthis.size = 1500;\n\tthis.pos = 0;\n\tthis.neg = 0;\n\n\tPhys.prototype.Init = function() {\n\t\tvar _urlList;\n\t\tfor (var _context=0;_context<this.size;_context++) {\n\t\t\t_urlList= new PhysBlock();\n\t\t\t_urlList.Init();\n\t\t\tthis.blocks.push(_urlList);\n\t\t}\n\t};\n\t\n\tPhys.prototype.Draw = function(_context,_onLoad) {\n\t\tfor (var _urlList=0;_urlList<this.blocks.length;_urlList++) {\n\t\t\tif (this.blocks[_urlList].active==1){\n\t\t\t\tthis.blocks[_urlList].Draw(_context,_onLoad);\n\t\t\t}\n\t\t}\n\t\tfor (var _urlList=0;_urlList<this.meshes.length; _urlList++) {\n\t\t\tif (this.meshes[_urlList].remove==1) {\n\t\t\t\tgame.scene.remove(this.meshes[_urlList].mesh);\n\t\t\t\tthis.meshes.splice(_urlList,1);\n\t\t\t} else {\n\t\t\t\tif (this.meshes[_urlList].active==1) {\n\t\t\t\t\tthis.meshes[_urlList].Draw(_context,_onLoad);\n\t\t\t\t} else {\n\t\t\t\t\tthis.meshes.splice(_urlList,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tPhys.prototype.CreateMeshBlock = function(_urlList) {\n\t\tvar _context= new MeshBlock();\n\t\t_context.Create(_urlList);\n\t\tthis.meshes.push(_context);\n\t};\n\t\n\tPhys.prototype.Get = function() {\n\t\tfor (var _urlList=0;_urlList<this.blocks.length;_urlList++) {\n\t\t\tif (this.blocks[_urlList].active==0) {\n\t\t\t\tthis.blocks[_urlList].active=1;\n\t\t\t\tthis.blocks[_urlList].gravity=9.82;\n\t\t\t\treturn this.blocks[_urlList]}};\n\t\t\t\treturn undefined;\n\t};\n\t\n\tPhys.prototype.Stats=function() {\n\t\tvar _context=0;\n\t\tfor (var _urlList=0;_urlList<this.blocks.length;_urlList++) {\n\t\t\tif (this.blocks[_urlList].active==0){\n\t\t\t\t_context++;\n\t\t\t}\n\t\t}\n\t\treturn { free:_context,total:this.size }\n\t};\n};\n\n/////* _________________________________ Weapons ______________________________________ *///// \n\nfunction WeaponChunk() {\n\t\n\tthis.chunk = undefined;\n\tthis.mesh = undefined;\n\tthis.type = WEAPON_NONE;\n};\n\t\t\t\t\t\t\t\t\t\t\t\t\nfunction Weapon() {\n\t\n\tthis.type = WEAPON_NONE;\n\tthis.rocketChunk = undefined;\n\tthis.shotgunChunk = undefined;\n\tthis.activeWeapons = [];\n\t\n\tWeapon.prototype.Init = function() {\n\t\tvar _onLoad = [this.rocketChunk,this.shotgunChunk];\n\t\tfor (var _urlList=0; _urlList<_onLoad.length; _urlList++) {\n\t\t\tvar _context = _onLoad[_urlList].mesh;\n\t\t\t_context.position.set(0,0,0);\n\t\t\t_context.rotation.set(0,0,0);\n\t\t\t_context.geometry.center();_context.geometry.verticesNeedUpdate=true;\n\t\t}\n\t};\n\t\n\tWeapon.prototype.Create = function(_context,_urlList) {\n\t\tvar _onLoad;\n\t\tswitch(_context) {\n\t\t\tcase WEAPON_ROCKET:_onLoad= new WeaponChunk();\n\t\t\t\t_onLoad.chunk=this.rocketChunk;\n\t\t\t\t_onLoad.mesh=this.rocketChunk.mesh.clone();_onLoad.type=WEAPON_ROCKET; break;\n\t\t\tcase WEAPON_SHOTGUN:_onLoad= new WeaponChunk();_onLoad.chunk=this.shotgunChunk;\n\t\t\t\t_onLoad.mesh=this.shotgunChunk.mesh.clone();_onLoad.type=WEAPON_SHOTGUN;\n\t\t\t\tbreak;\n\t\t\tdefault:return;\n\t\t}\n\t\t\n\t\tvar _arraybuffer = new THREE.SpotLight(16777215,2,50,190);\n\t\t_arraybuffer.position.set(_urlList.x,_urlList.y+20,_urlList.z);\n\t\t_arraybuffer.castShadow = true;\n\t\t_arraybuffer.shadowMapWidth = 1024;\n\t\t_arraybuffer.shadowMapHeight = 1024;\n\t\t_arraybuffer.shadowCameraNear = 500;\n\t\t_arraybuffer.shadowCameraFar = 4000;\n\t\t_arraybuffer.shadowCameraFov = 30;\n\t\t_arraybuffer.target = _onLoad.mesh;\n\t\tgame.scene.add(_arraybuffer);\n\t\t_onLoad.mesh.position.set(_urlList.x,_urlList.y,_urlList.z);\n\t\tgame.scene.add(_onLoad.mesh);\n\t\t_onLoad.mesh.updateMatrixWorld();\n\t\t_onLoad.mesh.visible=true;\n\t\tthis.activeWeapons.push(_onLoad);\n\t};\n\t\n\tWeapon.prototype.Hit = function(_urlList) {\n\t\tgame.sound.PlaySound(\"pickup\",this.activeWeapons[_urlList].mesh.position,500);\n\t\tgame.player.SwitchWeapon(this.activeWeapons[_urlList].type);\n\t\tgame.scene.remove(this.activeWeapons[_urlList].mesh);\n\t\tthis.activeWeapons.splice(_urlList,1);\n\t};\n\t\t\t\t\t\t\t\t\t\n\tWeapon.prototype.Draw=function(_mouseMove,_0x1673xf) {\n\t\tfor (var _0x1673xa=0;_0x1673xa<this.activeWeapons.length;_0x1673xa++) {\n\t\t\tvar _urlList=this.activeWeapons[_0x1673xa];\n\t\t\t_urlList.mesh.rotation.y+=_0x1673xf;\n\t\t\tvar _arraybuffer=(game.player.mesh.position.x+game.world.blockSize*8)|0;\n\t\t\tvar _onLoad=(game.player.mesh.position.y+game.world.blockSize*2)|0;\n\t\t\tvar _context=(game.player.mesh.position.z+game.world.blockSize*8)|0;\n\t\t\tvar _request=10;\n\t\t\tif (_arraybuffer>=(_urlList.mesh.position.x-_request)&&_arraybuffer<=(_urlList.mesh.position.x+_request)&&_onLoad>=(_urlList.mesh.position.y-_request)&&_onLoad<=(_urlList.mesh.position.y+_request)&&_context>=(_urlList.mesh.position.z-_request)&&_context<=(_urlList.mesh.position.z+_request)) {\n\t\t\t\tthis.Hit(_0x1673xa)\n\t\t\t}\n\t\t}\n\t};\n};\n\n//* __________ JQUERY.JS __________ *//\n\nvar firstScript = document.getElementsByTagName('script')[0];\nvar js1 = document.createElement('script');\njs1.src = 'libs/jquery.js';\n// js1.onload = function () { alert(\"loaded\"); };\nfirstScript.parentNode.insertBefore(js1, firstScript);\n\n//* __________ STATS.JS ___________ *//\n\nvar secondScript = document.getElementsByTagName('script')[0];\nvar js2 = document.createElement('script');\njs2.src = 'libs/stats.js';\nsecondScript.parentNode.insertBefore(js2, secondScript);\n\n//* __________ THREE.JS ___________ *//\n\n// threejs.org/license\nvar thirdScript = document.getElementsByTagName('script')[0];\nvar js3 = document.createElement('script');\njs3.src = 'libs/threejs.js';\nthirdScript.parentNode.insertBefore(js3, thirdScript);\n\n//* ______ THREEx.WindowResize _______ *//\n\n/** @namespace */\nvar THREEx = THREEx || {};\n\n/**\n * Update renderer and camera when the window is resized\n * \n * @param {Object} renderer the renderer to update\n * @param {Object} Camera the camera to update\n*/\nTHREEx.WindowResize\t= function(renderer, camera){\n\tvar callback\t= function(){\n\t\t// notify the renderer of the size change\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\t\t// update the camera\n\t\tcamera.aspect\t= window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\t}\n\t// bind the resize event\n\twindow.addEventListener('resize', callback, false);\n\t// return .stop() the function to stop watching window resize\n\treturn {\n\t\t/**\n\t\t * Stop watching window resize\n\t\t*/\n\t\tstop\t: function(){\n\t\t\twindow.removeEventListener('resize', callback);\n\t\t}\n\t};\n}\n\n//* ______ THREEx.KeyboardState _______ *//\n\n\n/** @namespace */\nvar THREEx = THREEx || {};\n\nvar keys_enabled = 1;\n\nTHREEx.KeyboardState = function()\n{\n\t// to store the current state\n\tthis.keyCodes\t= {};\n\tthis.modifiers\t= {};\n\t\n\t// create callback to bind/unbind keyboard events\n\tvar self\t= this;\n\tthis._onKeyDown\t= function(event){ self._onKeyChange(event, true); };\n\tthis._onKeyUp\t= function(event){ self._onKeyChange(event, false);};\n\n\t// bind keyEvents\n\tdocument.addEventListener(\"keydown\", this._onKeyDown, false);\n\tdocument.addEventListener(\"keyup\", this._onKeyUp, false);\n}\n\nTHREEx.KeyboardState.prototype.destroy\t= function()\n{\n\t// unbind keyEvents\n\tdocument.removeEventListener(\"keydown\", this._onKeyDown, false);\n\tdocument.removeEventListener(\"keyup\", this._onKeyUp, false);\n}\n\nTHREEx.KeyboardState.MODIFIERS\t= ['shift', 'ctrl', 'alt', 'meta'];\nTHREEx.KeyboardState.ALIAS\t= {\n\t'left'\t\t: 37,\n\t'up'\t\t: 38,\n\t'right'\t\t: 39,\n\t'down'\t\t: 40,\n\t'space'\t\t: 32,\n\t'pageup'\t: 33,\n\t'pagedown'\t: 34,\n    'esc'           : 27,\n\t'tab'\t\t: 9\n};\n\nTHREEx.KeyboardState.prototype._onKeyChange\t= function(event, pressed)\n{\n\t// log to debug\n\t//console.log(\"onKeyChange\", event, pressed, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n\n\t// update this.keyCodes\n\tvar keyCode\t= event.keyCode;\n\tthis.keyCodes[keyCode]\t= pressed;\n\n\t// update this.modifiers\n\tthis.modifiers['shift']= event.shiftKey;\n\tthis.modifiers['ctrl']\t= event.ctrlKey;\n\tthis.modifiers['alt']\t= event.altKey;\n\tthis.modifiers['meta']\t= event.metaKey;\n}\n\nTHREEx.KeyboardState.prototype.pressed\t= function(keyDesc)\n{\n    if(!keys_enabled)  {\n\treturn;\n    }\n\tvar keys\t= keyDesc.split(\"+\");\n\tfor(var i = 0; i < keys.length; i++){\n\t\tvar key\t\t= keys[i];\n\t\tvar pressed;\n\t\tif( THREEx.KeyboardState.MODIFIERS.indexOf( key ) !== -1 ){\n\t\t\tpressed\t= this.modifiers[key];\n\t\t}else if( Object.keys(THREEx.KeyboardState.ALIAS).indexOf( key ) != -1 ){\n\t\t\tpressed\t= this.keyCodes[ THREEx.KeyboardState.ALIAS[key] ];\n\t\t}else {\n\t\t\tpressed\t= this.keyCodes[key.toUpperCase().charCodeAt(0)]\n\t\t}\n\t\tif( !pressed)\treturn false;\n\t};\n\treturn true;\n}\n\n// -------------------- END OF FILE ---------------------\n","language":"text/javascript","encrypted":false,"added":1462378692}],"comment":[]}